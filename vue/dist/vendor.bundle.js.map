{"version":3,"sources":["webpack:///webpack/bootstrap fedf9b6069caf22def95","webpack:///../~/webpack/~/node-libs-browser/~/events/events.js","webpack:///../~/object-assign/index.js","webpack:///../~/flux/index.js","webpack:///../~/ractive/ractive.js","webpack:///../~/flux/lib/Dispatcher.js","webpack:///../~/flux/lib/invariant.js"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wC;;;;;;;;;;;;;;;;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH,qBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;AC5SA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,sBAAsB;AACtC;AACA;;AAEA,kBAAiB,iBAAiB;AAClC;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;ACTA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA,mBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,gEAA+D,KAAK;AACpE,kCAAiC,EAAE,OAAO;AAC1C,wCAAuC,aAAa,IAAI,IAAI;AAC5D,kCAAiC,UAAU;AAC3C,2CAA0C,IAAI,IAAI,IAAI;AACtD,6BAA4B,KAAK,GAAG,OAAO,qCAAqC,OAAO,+CAA+C,OAAO;AAC7I;AACA,6DAA4D,KAAK,GAAG,SAAS,UAAU,SAAS;AAChG,8BAA6B,KAAK,yCAAyC;AAC3E,2FAA0F,QAAQ,KAAK,MAAM;AAC7G,mCAAkC,WAAW,oCAAoC,YAAY;AAC7F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,KAAK,IAAI;AACtC;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA4B;AAC5B,kBAAiB;AACjB;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,WAAU;AACV,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAQ,GAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,wBAAwB;AACvC;AACA;AACA;AACA,gBAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA,6BAA4B;AAC5B;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,qDAAqD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA,kCAAiC,UAAU,EAAE,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sEAAqE,EAAE,cAAc,EAAE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA,kDAAiD;AACjD;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,iEAAiE;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD,OAAO,KAAK;AACnE;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA4D,WAAW;AACvE;AACA,WAAU,aAAa,SAAS,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,OAAM;AACN;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,wBAAwB;AACzD;AACA;AACA;AACA,WAAU,MAAM;AAChB;AACA,eAAc,MAAM,cAAc;AAClC;AACA,yBAAwB,MAAM,kBAAkB,SAAS;AACzD,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA2D,QAAQ,MAAM,MAAM;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA,uCAAsC,GAAG;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAwG;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,KAAK,KAAK;AACtC,qCAAoC,KAAK,KAAK;AAC9C;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA,mCAAkC,GAAG;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA,qCAAoC;AACpC;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,QAAO;AACP;AACA;AACA,SAAQ;AACR,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,IAAI;AACR;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,OAAM;AACN;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,4CAA4C;AACnF;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,iBAAiB;AAChC;AACA;AACA,WAAU,eAAe;AACzB;AACA;AACA,WAAU,SAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,IAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD;AAClD;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,eAAc,sBAAsB;AACpC,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,uCAAsC,+BAA+B;AACrE;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA,cAAa,iDAAiD;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,KAAI;AACJ;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc,SAAS;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc,SAAS;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,+BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAuB;AACvB;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,yBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,sDAAsD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAqC,0BAA0B,yBAAyB;AACxF;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,8BAA6B,UAAU;AACvC;AACA;AACA,OAAM;AACN;AACA,OAAM;AACN;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAmE;AACnE;AACA;AACA;AACA;AACA,iBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,qBAAoB,sBAAsB;AAC1C;AACA,KAAI;AACJ;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,MAAK;AACL;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,SAAS;AAC3B;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;;AAEA,wLAAuL;AACvL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,SAAQ;AACR,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN,MAAK;AACL;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,uBAAsB;AACtB;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,OAAM;AACN;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA,iBAAgB;AAChB;AACA,iDAAgD,KAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,gDAA+C,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA,2DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,iEAAgE,OAAO;AACvE;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,YAAY,KAAK,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,OAAM;AACN,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD,KAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAqB,KAAK,KAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA0C;AAC1C;AACA,KAAI;AACJ;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,SAAQ;AACR;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO,aAAa,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,6BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA,kCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA,6BAA4B;AAC5B;AACA,KAAI;AACJ,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;;AAGF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC;;;;;;;;;;;;AClhcD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,uBAAsB;AACtB;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,2CAA0C,yBAAyB,EAAE;AACrE;AACA;;AAEA,2BAA0B;AAC1B;AACA;AACA;;AAEA","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\t__webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t0:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap fedf9b6069caf22def95\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/webpack/~/node-libs-browser/~/events/events.js\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\n\nfunction ToObject(val) {\n\tif (val == null) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nmodule.exports = Object.assign || function (target, source) {\n\tvar pendingException;\n\tvar from;\n\tvar keys;\n\tvar to = ToObject(target);\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = arguments[s];\n\t\tkeys = Object.keys(Object(from));\n\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\ttry {\n\t\t\t\tto[keys[i]] = from[keys[i]];\n\t\t\t} catch (err) {\n\t\t\t\tif (pendingException === undefined) {\n\t\t\t\t\tpendingException = err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pendingException) {\n\t\tthrow pendingException;\n\t}\n\n\treturn to;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/object-assign/index.js\n ** module id = 2\n ** module chunks = 0\n **/","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nmodule.exports.Dispatcher = require('./lib/Dispatcher')\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/flux/index.js\n ** module id = 3\n ** module chunks = 0\n **/","/*\n\tractive.js v0.6.0\n\t2014-10-08 - commit 150e82d0 \n\n\thttp://ractivejs.org\n\thttp://twitter.com/RactiveJS\n\n\tReleased under the MIT License.\n*/\n\n( function( global ) {\n\n\t'use strict';\n\n\tvar noConflict = global.Ractive;\n\n\t/* config/defaults/options.js */\n\tvar options = function() {\n\n\t\tvar defaultOptions = {\n\t\t\t// render placement:\n\t\t\tel: void 0,\n\t\t\tappend: false,\n\t\t\t// template:\n\t\t\ttemplate: {\n\t\t\t\tv: 1,\n\t\t\t\tt: []\n\t\t\t},\n\t\t\tyield: null,\n\t\t\t// parse:\n\t\t\tpreserveWhitespace: false,\n\t\t\tsanitize: false,\n\t\t\tstripComments: true,\n\t\t\t// data & binding:\n\t\t\tdata: {},\n\t\t\tcomputed: {},\n\t\t\tmagic: false,\n\t\t\tmodifyArrays: true,\n\t\t\tadapt: [],\n\t\t\tisolated: false,\n\t\t\ttwoway: true,\n\t\t\tlazy: false,\n\t\t\t// transitions:\n\t\t\tnoIntro: false,\n\t\t\ttransitionsEnabled: true,\n\t\t\tcomplete: void 0,\n\t\t\t// css:\n\t\t\tnoCssTransform: false,\n\t\t\t// debug:\n\t\t\tdebug: false\n\t\t};\n\t\treturn defaultOptions;\n\t}();\n\n\t/* config/defaults/easing.js */\n\tvar easing = {\n\t\tlinear: function( pos ) {\n\t\t\treturn pos;\n\t\t},\n\t\teaseIn: function( pos ) {\n\t\t\treturn Math.pow( pos, 3 );\n\t\t},\n\t\teaseOut: function( pos ) {\n\t\t\treturn Math.pow( pos - 1, 3 ) + 1;\n\t\t},\n\t\teaseInOut: function( pos ) {\n\t\t\tif ( ( pos /= 0.5 ) < 1 ) {\n\t\t\t\treturn 0.5 * Math.pow( pos, 3 );\n\t\t\t}\n\t\t\treturn 0.5 * ( Math.pow( pos - 2, 3 ) + 2 );\n\t\t}\n\t};\n\n\t/* circular.js */\n\tvar circular = [];\n\n\t/* utils/hasOwnProperty.js */\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\n\t/* utils/isArray.js */\n\tvar isArray = function() {\n\n\t\tvar toString = Object.prototype.toString;\n\t\t// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n\t\treturn function( thing ) {\n\t\t\treturn toString.call( thing ) === '[object Array]';\n\t\t};\n\t}();\n\n\t/* utils/isObject.js */\n\tvar isObject = function() {\n\n\t\tvar toString = Object.prototype.toString;\n\t\treturn function( thing ) {\n\t\t\treturn thing && toString.call( thing ) === '[object Object]';\n\t\t};\n\t}();\n\n\t/* utils/isNumeric.js */\n\tvar isNumeric = function( thing ) {\n\t\treturn !isNaN( parseFloat( thing ) ) && isFinite( thing );\n\t};\n\n\t/* config/defaults/interpolators.js */\n\tvar interpolators = function( circular, hasOwnProperty, isArray, isObject, isNumeric ) {\n\n\t\tvar interpolators, interpolate, cssLengthPattern;\n\t\tcircular.push( function() {\n\t\t\tinterpolate = circular.interpolate;\n\t\t} );\n\t\tcssLengthPattern = /^([+-]?[0-9]+\\.?(?:[0-9]+)?)(px|em|ex|%|in|cm|mm|pt|pc)$/;\n\t\tinterpolators = {\n\t\t\tnumber: function( from, to ) {\n\t\t\t\tvar delta;\n\t\t\t\tif ( !isNumeric( from ) || !isNumeric( to ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tfrom = +from;\n\t\t\t\tto = +to;\n\t\t\t\tdelta = to - from;\n\t\t\t\tif ( !delta ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\treturn from;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn function( t ) {\n\t\t\t\t\treturn from + t * delta;\n\t\t\t\t};\n\t\t\t},\n\t\t\tarray: function( from, to ) {\n\t\t\t\tvar intermediate, interpolators, len, i;\n\t\t\t\tif ( !isArray( from ) || !isArray( to ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tintermediate = [];\n\t\t\t\tinterpolators = [];\n\t\t\t\ti = len = Math.min( from.length, to.length );\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tinterpolators[ i ] = interpolate( from[ i ], to[ i ] );\n\t\t\t\t}\n\t\t\t\t// surplus values - don't interpolate, but don't exclude them either\n\t\t\t\tfor ( i = len; i < from.length; i += 1 ) {\n\t\t\t\t\tintermediate[ i ] = from[ i ];\n\t\t\t\t}\n\t\t\t\tfor ( i = len; i < to.length; i += 1 ) {\n\t\t\t\t\tintermediate[ i ] = to[ i ];\n\t\t\t\t}\n\t\t\t\treturn function( t ) {\n\t\t\t\t\tvar i = len;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tintermediate[ i ] = interpolators[ i ]( t );\n\t\t\t\t\t}\n\t\t\t\t\treturn intermediate;\n\t\t\t\t};\n\t\t\t},\n\t\t\tobject: function( from, to ) {\n\t\t\t\tvar properties, len, interpolators, intermediate, prop;\n\t\t\t\tif ( !isObject( from ) || !isObject( to ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tproperties = [];\n\t\t\t\tintermediate = {};\n\t\t\t\tinterpolators = {};\n\t\t\t\tfor ( prop in from ) {\n\t\t\t\t\tif ( hasOwnProperty.call( from, prop ) ) {\n\t\t\t\t\t\tif ( hasOwnProperty.call( to, prop ) ) {\n\t\t\t\t\t\t\tproperties.push( prop );\n\t\t\t\t\t\t\tinterpolators[ prop ] = interpolate( from[ prop ], to[ prop ] );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tintermediate[ prop ] = from[ prop ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor ( prop in to ) {\n\t\t\t\t\tif ( hasOwnProperty.call( to, prop ) && !hasOwnProperty.call( from, prop ) ) {\n\t\t\t\t\t\tintermediate[ prop ] = to[ prop ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlen = properties.length;\n\t\t\t\treturn function( t ) {\n\t\t\t\t\tvar i = len,\n\t\t\t\t\t\tprop;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tprop = properties[ i ];\n\t\t\t\t\t\tintermediate[ prop ] = interpolators[ prop ]( t );\n\t\t\t\t\t}\n\t\t\t\t\treturn intermediate;\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t\treturn interpolators;\n\t}( circular, hasOwn, isArray, isObject, isNumeric );\n\n\t/* config/svg.js */\n\tvar svg = function() {\n\n\t\tvar svg;\n\t\tif ( typeof document === 'undefined' ) {\n\t\t\tsvg = false;\n\t\t} else {\n\t\t\tsvg = document && document.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' );\n\t\t}\n\t\treturn svg;\n\t}();\n\n\t/* utils/warn.js */\n\tvar warn = function() {\n\n\t\t/* global console */\n\t\tvar warn, warned = {};\n\t\tif ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' ) {\n\t\t\twarn = function( message, allowDuplicates ) {\n\t\t\t\tif ( !allowDuplicates ) {\n\t\t\t\t\tif ( warned[ message ] ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\twarned[ message ] = true;\n\t\t\t\t}\n\t\t\t\tconsole.warn( message );\n\t\t\t};\n\t\t} else {\n\t\t\twarn = function() {};\n\t\t}\n\t\treturn warn;\n\t}();\n\n\t/* config/errors.js */\n\tvar errors = {\n\t\tmissingParser: 'Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser',\n\t\tmergeComparisonFail: 'Merge operation: comparison failed. Falling back to identity checking',\n\t\tnoComponentEventArguments: 'Components currently only support simple events - you cannot include arguments. Sorry!',\n\t\tnoTemplateForPartial: 'Could not find template for partial \"{name}\"',\n\t\tnoNestedPartials: 'Partials ({{>{name}}}) cannot contain nested inline partials',\n\t\tevaluationError: 'Error evaluating \"{uniqueString}\": {err}',\n\t\tbadArguments: 'Bad arguments \"{arguments}\". I\\'m not allowed to argue unless you\\'ve paid.',\n\t\tfailedComputation: 'Failed to compute \"{key}\": {err}',\n\t\tmissingPlugin: 'Missing \"{name}\" {plugin} plugin. You may need to download a {plugin} via http://docs.ractivejs.org/latest/plugins#{plugin}s',\n\t\tbadRadioInputBinding: 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',\n\t\tnoRegistryFunctionReturn: 'A function was specified for \"{name}\" {registry}, but no {registry} was returned',\n\t\tdefaultElSpecified: 'The <{name}/> component has a default `el` property; it has been disregarded',\n\t\tnoElementProxyEventWildcards: 'Only component proxy-events may contain \"*\" wildcards, <{element} on-{event}/> is not valid.',\n\t\tmethodDepricated: 'The method \"{depricated}\" has been depricated in favor of \"{replacement}\" and will likely be removed in a future release.'\n\t};\n\n\t/* utils/log.js */\n\tvar log = function( consolewarn, errors ) {\n\n\t\tvar log = {\n\t\t\twarn: function( options, passthru ) {\n\t\t\t\tif ( !options.debug && !passthru ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.logger( getMessage( options ), options.allowDuplicates );\n\t\t\t},\n\t\t\terror: function( options ) {\n\t\t\t\tthis.errorOnly( options );\n\t\t\t\tif ( !options.debug ) {\n\t\t\t\t\tthis.warn( options, true );\n\t\t\t\t}\n\t\t\t},\n\t\t\terrorOnly: function( options ) {\n\t\t\t\tif ( options.debug ) {\n\t\t\t\t\tthis.critical( options );\n\t\t\t\t}\n\t\t\t},\n\t\t\tcritical: function( options ) {\n\t\t\t\tvar err = options.err || new Error( getMessage( options ) );\n\t\t\t\tthis.thrower( err );\n\t\t\t},\n\t\t\tlogger: consolewarn,\n\t\t\tthrower: function( err ) {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t};\n\n\t\tfunction getMessage( options ) {\n\t\t\tvar message = errors[ options.message ] || options.message || '';\n\t\t\treturn interpolate( message, options.args );\n\t\t}\n\t\t// simple interpolation. probably quicker (and better) out there,\n\t\t// but log is not in golden path of execution, only exceptions\n\t\tfunction interpolate( message, args ) {\n\t\t\treturn message.replace( /{([^{}]*)}/g, function( a, b ) {\n\t\t\t\treturn args[ b ];\n\t\t\t} );\n\t\t}\n\t\treturn log;\n\t}( warn, errors );\n\n\t/* Ractive/prototype/shared/hooks/Hook.js */\n\tvar Ractive$shared_hooks_Hook = function( log ) {\n\n\t\tvar deprications = {\n\t\t\tconstruct: {\n\t\t\t\tdepricated: 'beforeInit',\n\t\t\t\treplacement: 'onconstruct'\n\t\t\t},\n\t\t\trender: {\n\t\t\t\tdepricated: 'init',\n\t\t\t\treplacement: 'onrender'\n\t\t\t},\n\t\t\tcomplete: {\n\t\t\t\tdepricated: 'complete',\n\t\t\t\treplacement: 'oncomplete'\n\t\t\t}\n\t\t};\n\n\t\tfunction Hook( event ) {\n\t\t\tthis.event = event;\n\t\t\tthis.method = 'on' + event;\n\t\t\tthis.depricate = deprications[ event ];\n\t\t}\n\t\tHook.prototype.fire = function( ractive, arg ) {\n\t\t\tfunction call( method ) {\n\t\t\t\tif ( ractive[ method ] ) {\n\t\t\t\t\targ ? ractive[ method ]( arg ) : ractive[ method ]();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcall( this.method );\n\t\t\tif ( this.depricate && call( this.depricate.depricated ) ) {\n\t\t\t\tlog.warn( {\n\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\tmessage: 'methodDepricated',\n\t\t\t\t\targs: this.depricate\n\t\t\t\t} );\n\t\t\t}\n\t\t\targ ? ractive.fire( this.event, arg ) : ractive.fire( this.event );\n\t\t};\n\t\treturn Hook;\n\t}( log );\n\n\t/* utils/removeFromArray.js */\n\tvar removeFromArray = function( array, member ) {\n\t\tvar index = array.indexOf( member );\n\t\tif ( index !== -1 ) {\n\t\t\tarray.splice( index, 1 );\n\t\t}\n\t};\n\n\t/* utils/Promise.js */\n\tvar Promise = function() {\n\n\t\tvar __export;\n\t\tvar _Promise, PENDING = {},\n\t\t\tFULFILLED = {},\n\t\t\tREJECTED = {};\n\t\tif ( typeof Promise === 'function' ) {\n\t\t\t// use native Promise\n\t\t\t_Promise = Promise;\n\t\t} else {\n\t\t\t_Promise = function( callback ) {\n\t\t\t\tvar fulfilledHandlers = [],\n\t\t\t\t\trejectedHandlers = [],\n\t\t\t\t\tstate = PENDING,\n\t\t\t\t\tresult, dispatchHandlers, makeResolver, fulfil, reject, promise;\n\t\t\t\tmakeResolver = function( newState ) {\n\t\t\t\t\treturn function( value ) {\n\t\t\t\t\t\tif ( state !== PENDING ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult = value;\n\t\t\t\t\t\tstate = newState;\n\t\t\t\t\t\tdispatchHandlers = makeDispatcher( state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result );\n\t\t\t\t\t\t// dispatch onFulfilled and onRejected handlers asynchronously\n\t\t\t\t\t\twait( dispatchHandlers );\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tfulfil = makeResolver( FULFILLED );\n\t\t\t\treject = makeResolver( REJECTED );\n\t\t\t\ttry {\n\t\t\t\t\tcallback( fulfil, reject );\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t}\n\t\t\t\tpromise = {\n\t\t\t\t\t// `then()` returns a Promise - 2.2.7\n\t\t\t\t\tthen: function( onFulfilled, onRejected ) {\n\t\t\t\t\t\tvar promise2 = new _Promise( function( fulfil, reject ) {\n\t\t\t\t\t\t\tvar processResolutionHandler = function( handler, handlers, forward ) {\n\t\t\t\t\t\t\t\t// 2.2.1.1\n\t\t\t\t\t\t\t\tif ( typeof handler === 'function' ) {\n\t\t\t\t\t\t\t\t\thandlers.push( function( p1result ) {\n\t\t\t\t\t\t\t\t\t\tvar x;\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tx = handler( p1result );\n\t\t\t\t\t\t\t\t\t\t\tresolve( promise2, x, fulfil, reject );\n\t\t\t\t\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Forward the result of promise1 to promise2, if resolution handlers\n\t\t\t\t\t\t\t\t\t// are not given\n\t\t\t\t\t\t\t\t\thandlers.push( forward );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t// 2.2\n\t\t\t\t\t\t\tprocessResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );\n\t\t\t\t\t\t\tprocessResolutionHandler( onRejected, rejectedHandlers, reject );\n\t\t\t\t\t\t\tif ( state !== PENDING ) {\n\t\t\t\t\t\t\t\t// If the promise has resolved already, dispatch the appropriate handlers asynchronously\n\t\t\t\t\t\t\t\twait( dispatchHandlers );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t\treturn promise2;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tpromise[ 'catch' ] = function( onRejected ) {\n\t\t\t\t\treturn this.then( null, onRejected );\n\t\t\t\t};\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t\t_Promise.all = function( promises ) {\n\t\t\t\treturn new _Promise( function( fulfil, reject ) {\n\t\t\t\t\tvar result = [],\n\t\t\t\t\t\tpending, i, processPromise;\n\t\t\t\t\tif ( !promises.length ) {\n\t\t\t\t\t\tfulfil( result );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tprocessPromise = function( i ) {\n\t\t\t\t\t\tpromises[ i ].then( function( value ) {\n\t\t\t\t\t\t\tresult[ i ] = value;\n\t\t\t\t\t\t\tif ( !--pending ) {\n\t\t\t\t\t\t\t\tfulfil( result );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, reject );\n\t\t\t\t\t};\n\t\t\t\t\tpending = i = promises.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tprocessPromise( i );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t};\n\t\t\t_Promise.resolve = function( value ) {\n\t\t\t\treturn new _Promise( function( fulfil ) {\n\t\t\t\t\tfulfil( value );\n\t\t\t\t} );\n\t\t\t};\n\t\t\t_Promise.reject = function( reason ) {\n\t\t\t\treturn new _Promise( function( fulfil, reject ) {\n\t\t\t\t\treject( reason );\n\t\t\t\t} );\n\t\t\t};\n\t\t}\n\t\t__export = _Promise;\n\t\t// TODO use MutationObservers or something to simulate setImmediate\n\t\tfunction wait( callback ) {\n\t\t\tsetTimeout( callback, 0 );\n\t\t}\n\n\t\tfunction makeDispatcher( handlers, result ) {\n\t\t\treturn function() {\n\t\t\t\tvar handler;\n\t\t\t\twhile ( handler = handlers.shift() ) {\n\t\t\t\t\thandler( result );\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction resolve( promise, x, fulfil, reject ) {\n\t\t\t// Promise Resolution Procedure\n\t\t\tvar then;\n\t\t\t// 2.3.1\n\t\t\tif ( x === promise ) {\n\t\t\t\tthrow new TypeError( 'A promise\\'s fulfillment handler cannot return the same promise' );\n\t\t\t}\n\t\t\t// 2.3.2\n\t\t\tif ( x instanceof _Promise ) {\n\t\t\t\tx.then( fulfil, reject );\n\t\t\t} else if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {\n\t\t\t\ttry {\n\t\t\t\t\tthen = x.then;\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\treject( e );\n\t\t\t\t\t// 2.3.3.2\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// 2.3.3.3\n\t\t\t\tif ( typeof then === 'function' ) {\n\t\t\t\t\tvar called, resolvePromise, rejectPromise;\n\t\t\t\t\tresolvePromise = function( y ) {\n\t\t\t\t\t\tif ( called ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcalled = true;\n\t\t\t\t\t\tresolve( promise, y, fulfil, reject );\n\t\t\t\t\t};\n\t\t\t\t\trejectPromise = function( r ) {\n\t\t\t\t\t\tif ( called ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcalled = true;\n\t\t\t\t\t\treject( r );\n\t\t\t\t\t};\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthen.call( x, resolvePromise, rejectPromise );\n\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\tif ( !called ) {\n\t\t\t\t\t\t\t// 2.3.3.3.4.1\n\t\t\t\t\t\t\treject( e );\n\t\t\t\t\t\t\t// 2.3.3.3.4.2\n\t\t\t\t\t\t\tcalled = true;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfulfil( x );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfulfil( x );\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* utils/normaliseRef.js */\n\tvar normaliseRef = function() {\n\n\t\tvar regex = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\n\t\treturn function normaliseRef( ref ) {\n\t\t\treturn ( ref || '' ).replace( regex, '.$1' );\n\t\t};\n\t}();\n\n\t/* shared/getInnerContext.js */\n\tvar getInnerContext = function( fragment ) {\n\t\tdo {\n\t\t\tif ( fragment.context !== undefined ) {\n\t\t\t\treturn fragment.context;\n\t\t\t}\n\t\t} while ( fragment = fragment.parent );\n\t\treturn '';\n\t};\n\n\t/* utils/isEqual.js */\n\tvar isEqual = function( a, b ) {\n\t\tif ( a === null && b === null ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( typeof a === 'object' || typeof b === 'object' ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a === b;\n\t};\n\n\t/* shared/createComponentBinding.js */\n\tvar createComponentBinding = function( circular, isEqual ) {\n\n\t\tvar runloop;\n\t\tcircular.push( function() {\n\t\t\treturn runloop = circular.runloop;\n\t\t} );\n\t\tvar Binding = function( ractive, keypath, otherInstance, otherKeypath ) {\n\t\t\tvar this$0 = this;\n\t\t\tthis.root = ractive;\n\t\t\tthis.keypath = keypath;\n\t\t\tthis.otherInstance = otherInstance;\n\t\t\tthis.otherKeypath = otherKeypath;\n\t\t\tthis.unlock = function() {\n\t\t\t\treturn this$0.updating = false;\n\t\t\t};\n\t\t\tthis.bind();\n\t\t\tthis.value = this.root.viewmodel.get( this.keypath );\n\t\t};\n\t\tBinding.prototype = {\n\t\t\tshuffle: function( newIndices, value ) {\n\t\t\t\tthis.propagateChange( value, newIndices );\n\t\t\t},\n\t\t\tsetValue: function( value ) {\n\t\t\t\tthis.propagateChange( value );\n\t\t\t},\n\t\t\tpropagateChange: function( value, newIndices ) {\n\t\t\t\t// Only *you* can prevent infinite loops\n\t\t\t\tif ( this.updating || this.counterpart && this.counterpart.updating ) {\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\t\t\tthis.updating = true;\n\t\t\t\t\t// TODO maybe the case that `value === this.value` - should that result\n\t\t\t\t\t// in an update rather than a set?\n\t\t\t\t\trunloop.addViewmodel( this.otherInstance.viewmodel );\n\t\t\t\t\tif ( newIndices ) {\n\t\t\t\t\t\tthis.otherInstance.viewmodel.smartUpdate( this.otherKeypath, value, newIndices );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.otherInstance.viewmodel.set( this.otherKeypath, value );\n\t\t\t\t\t}\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\t// TODO will the counterpart update after this line, during\n\t\t\t\t\t// the runloop end cycle? may be a problem...\n\t\t\t\t\trunloop.scheduleTask( this.unlock );\n\t\t\t\t}\n\t\t\t},\n\t\t\tbind: function() {\n\t\t\t\tthis.root.viewmodel.register( this.keypath, this );\n\t\t\t},\n\t\t\trebind: function( newKeypath ) {\n\t\t\t\tthis.unbind();\n\t\t\t\tthis.keypath = newKeypath;\n\t\t\t\tthis.counterpart.otherKeypath = newKeypath;\n\t\t\t\tthis.bind();\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tthis.root.viewmodel.unregister( this.keypath, this );\n\t\t\t}\n\t\t};\n\t\treturn function createComponentBinding( component, parentInstance, parentKeypath, childKeypath ) {\n\t\t\tvar hash, childInstance, bindings, parentToChildBinding, childToParentBinding;\n\t\t\thash = parentKeypath + '=' + childKeypath;\n\t\t\tbindings = component.bindings;\n\t\t\tif ( bindings[ hash ] ) {\n\t\t\t\t// TODO does this ever happen?\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchildInstance = component.instance;\n\t\t\tparentToChildBinding = new Binding( parentInstance, parentKeypath, childInstance, childKeypath );\n\t\t\tbindings.push( parentToChildBinding );\n\t\t\tif ( childInstance.twoway ) {\n\t\t\t\tchildToParentBinding = new Binding( childInstance, childKeypath, parentInstance, parentKeypath );\n\t\t\t\tbindings.push( childToParentBinding );\n\t\t\t\tparentToChildBinding.counterpart = childToParentBinding;\n\t\t\t\tchildToParentBinding.counterpart = parentToChildBinding;\n\t\t\t}\n\t\t\tbindings[ hash ] = parentToChildBinding;\n\t\t};\n\t}( circular, isEqual );\n\n\t/* shared/resolveRef.js */\n\tvar resolveRef = function( normaliseRef, getInnerContext, createComponentBinding ) {\n\n\t\tvar __export;\n\t\tvar ancestorErrorMessage, getOptions;\n\t\tancestorErrorMessage = 'Could not resolve reference - too many \"../\" prefixes';\n\t\tgetOptions = {\n\t\t\tevaluateWrapped: true\n\t\t};\n\t\t__export = function resolveRef( ractive, ref, fragment, isParentLookup ) {\n\t\t\tvar context, key, index, keypath, parentValue, hasContextChain, parentKeys, childKeys, parentKeypath, childKeypath;\n\t\t\tref = normaliseRef( ref );\n\t\t\t// If a reference begins '~/', it's a top-level reference\n\t\t\tif ( ref.substr( 0, 2 ) === '~/' ) {\n\t\t\t\treturn ref.substring( 2 );\n\t\t\t}\n\t\t\t// If a reference begins with '.', it's either a restricted reference or\n\t\t\t// an ancestor reference...\n\t\t\tif ( ref.charAt( 0 ) === '.' ) {\n\t\t\t\treturn resolveAncestorReference( getInnerContext( fragment ), ref );\n\t\t\t}\n\t\t\t// ...otherwise we need to find the keypath\n\t\t\tkey = ref.split( '.' )[ 0 ];\n\t\t\t// get() in viewmodel creation means no fragment (yet)\n\t\t\tfragment = fragment || {};\n\t\t\tdo {\n\t\t\t\tcontext = fragment.context;\n\t\t\t\tif ( !context ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\thasContextChain = true;\n\t\t\t\tparentValue = ractive.viewmodel.get( context, getOptions );\n\t\t\t\tif ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) && key in parentValue ) {\n\t\t\t\t\treturn context + '.' + ref;\n\t\t\t\t}\n\t\t\t} while ( fragment = fragment.parent );\n\t\t\t// Root/computed property?\n\t\t\tif ( key in ractive.data || key in ractive.viewmodel.computations ) {\n\t\t\t\treturn ref;\n\t\t\t}\n\t\t\t// If this is an inline component, and it's not isolated, we\n\t\t\t// can try going up the scope chain\n\t\t\tif ( ractive._parent && !ractive.isolated ) {\n\t\t\t\thasContextChain = true;\n\t\t\t\tfragment = ractive.component.parentFragment;\n\t\t\t\t// Special case - index refs\n\t\t\t\tif ( fragment.indexRefs && ( index = fragment.indexRefs[ ref ] ) !== undefined ) {\n\t\t\t\t\t// Create an index ref binding, so that it can be rebound letter if necessary.\n\t\t\t\t\t// It doesn't have an alias since it's an implicit binding, hence `...[ ref ] = ref`\n\t\t\t\t\tractive.component.indexRefBindings[ ref ] = ref;\n\t\t\t\t\tractive.viewmodel.set( ref, index, true );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tkeypath = resolveRef( ractive._parent, ref, fragment, true );\n\t\t\t\tif ( keypath ) {\n\t\t\t\t\t// We need to create an inter-component binding\n\t\t\t\t\t// If parent keypath is 'one.foo' and child is 'two.foo', we bind\n\t\t\t\t\t// 'one' to 'two' as it's more efficient and avoids edge cases\n\t\t\t\t\tparentKeys = keypath.split( '.' );\n\t\t\t\t\tchildKeys = ref.split( '.' );\n\t\t\t\t\twhile ( parentKeys.length > 1 && childKeys.length > 1 && parentKeys[ parentKeys.length - 1 ] === childKeys[ childKeys.length - 1 ] ) {\n\t\t\t\t\t\tparentKeys.pop();\n\t\t\t\t\t\tchildKeys.pop();\n\t\t\t\t\t}\n\t\t\t\t\tparentKeypath = parentKeys.join( '.' );\n\t\t\t\t\tchildKeypath = childKeys.join( '.' );\n\t\t\t\t\tractive.viewmodel.set( childKeypath, ractive._parent.viewmodel.get( parentKeypath ), true );\n\t\t\t\t\tcreateComponentBinding( ractive.component, ractive._parent, parentKeypath, childKeypath );\n\t\t\t\t\treturn ref;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If there's no context chain, and the instance is either a) isolated or\n\t\t\t// b) an orphan, then we know that the keypath is identical to the reference\n\t\t\tif ( !isParentLookup && !hasContextChain ) {\n\t\t\t\t// the data object needs to have a property by this name,\n\t\t\t\t// to prevent future failed lookups\n\t\t\t\tractive.viewmodel.set( ref, undefined );\n\t\t\t\treturn ref;\n\t\t\t}\n\t\t\tif ( ractive.viewmodel.get( ref ) !== undefined ) {\n\t\t\t\treturn ref;\n\t\t\t}\n\t\t};\n\n\t\tfunction resolveAncestorReference( baseContext, ref ) {\n\t\t\tvar contextKeys;\n\t\t\t// {{.}} means 'current context'\n\t\t\tif ( ref === '.' )\n\t\t\t\treturn baseContext;\n\t\t\tcontextKeys = baseContext ? baseContext.split( '.' ) : [];\n\t\t\t// ancestor references (starting \"../\") go up the tree\n\t\t\tif ( ref.substr( 0, 3 ) === '../' ) {\n\t\t\t\twhile ( ref.substr( 0, 3 ) === '../' ) {\n\t\t\t\t\tif ( !contextKeys.length ) {\n\t\t\t\t\t\tthrow new Error( ancestorErrorMessage );\n\t\t\t\t\t}\n\t\t\t\t\tcontextKeys.pop();\n\t\t\t\t\tref = ref.substring( 3 );\n\t\t\t\t}\n\t\t\t\tcontextKeys.push( ref );\n\t\t\t\treturn contextKeys.join( '.' );\n\t\t\t}\n\t\t\t// not an ancestor reference - must be a restricted reference (prepended with \".\" or \"./\")\n\t\t\tif ( !baseContext ) {\n\t\t\t\treturn ref.replace( /^\\.\\/?/, '' );\n\t\t\t}\n\t\t\treturn baseContext + ref.replace( /^\\.\\//, '.' );\n\t\t}\n\t\treturn __export;\n\t}( normaliseRef, getInnerContext, createComponentBinding );\n\n\t/* global/TransitionManager.js */\n\tvar TransitionManager = function( removeFromArray ) {\n\n\t\tvar TransitionManager = function( callback, parent ) {\n\t\t\tthis.callback = callback;\n\t\t\tthis.parent = parent;\n\t\t\tthis.intros = [];\n\t\t\tthis.outros = [];\n\t\t\tthis.children = [];\n\t\t\tthis.totalChildren = this.outroChildren = 0;\n\t\t\tthis.detachQueue = [];\n\t\t\tthis.outrosComplete = false;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.addChild( this );\n\t\t\t}\n\t\t};\n\t\tTransitionManager.prototype = {\n\t\t\taddChild: function( child ) {\n\t\t\t\tthis.children.push( child );\n\t\t\t\tthis.totalChildren += 1;\n\t\t\t\tthis.outroChildren += 1;\n\t\t\t},\n\t\t\tdecrementOutros: function() {\n\t\t\t\tthis.outroChildren -= 1;\n\t\t\t\tcheck( this );\n\t\t\t},\n\t\t\tdecrementTotal: function() {\n\t\t\t\tthis.totalChildren -= 1;\n\t\t\t\tcheck( this );\n\t\t\t},\n\t\t\tadd: function( transition ) {\n\t\t\t\tvar list = transition.isIntro ? this.intros : this.outros;\n\t\t\t\tlist.push( transition );\n\t\t\t},\n\t\t\tremove: function( transition ) {\n\t\t\t\tvar list = transition.isIntro ? this.intros : this.outros;\n\t\t\t\tremoveFromArray( list, transition );\n\t\t\t\tcheck( this );\n\t\t\t},\n\t\t\tinit: function() {\n\t\t\t\tthis.ready = true;\n\t\t\t\tcheck( this );\n\t\t\t},\n\t\t\tdetachNodes: function() {\n\t\t\t\tthis.detachQueue.forEach( detach );\n\t\t\t\tthis.children.forEach( detachNodes );\n\t\t\t}\n\t\t};\n\n\t\tfunction detach( element ) {\n\t\t\telement.detach();\n\t\t}\n\n\t\tfunction detachNodes( tm ) {\n\t\t\ttm.detachNodes();\n\t\t}\n\n\t\tfunction check( tm ) {\n\t\t\tif ( !tm.ready || tm.outros.length || tm.outroChildren )\n\t\t\t\treturn;\n\t\t\t// If all outros are complete, and we haven't already done this,\n\t\t\t// we notify the parent if there is one, otherwise\n\t\t\t// start detaching nodes\n\t\t\tif ( !tm.outrosComplete ) {\n\t\t\t\tif ( tm.parent ) {\n\t\t\t\t\ttm.parent.decrementOutros( tm );\n\t\t\t\t} else {\n\t\t\t\t\ttm.detachNodes();\n\t\t\t\t}\n\t\t\t\ttm.outrosComplete = true;\n\t\t\t}\n\t\t\t// Once everything is done, we can notify parent transition\n\t\t\t// manager and call the callback\n\t\t\tif ( !tm.intros.length && !tm.totalChildren ) {\n\t\t\t\tif ( typeof tm.callback === 'function' ) {\n\t\t\t\t\ttm.callback();\n\t\t\t\t}\n\t\t\t\tif ( tm.parent ) {\n\t\t\t\t\ttm.parent.decrementTotal();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn TransitionManager;\n\t}( removeFromArray );\n\n\t/* global/runloop.js */\n\tvar runloop = function( circular, Hook, removeFromArray, Promise, resolveRef, TransitionManager ) {\n\n\t\tvar __export;\n\t\tvar batch, runloop, unresolved = [],\n\t\t\tchangeHook = new Hook( 'change' );\n\t\trunloop = {\n\t\t\tstart: function( instance, returnPromise ) {\n\t\t\t\tvar promise, fulfilPromise;\n\t\t\t\tif ( returnPromise ) {\n\t\t\t\t\tpromise = new Promise( function( f ) {\n\t\t\t\t\t\treturn fulfilPromise = f;\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tbatch = {\n\t\t\t\t\tpreviousBatch: batch,\n\t\t\t\t\ttransitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),\n\t\t\t\t\tviews: [],\n\t\t\t\t\ttasks: [],\n\t\t\t\t\tviewmodels: []\n\t\t\t\t};\n\t\t\t\tif ( instance ) {\n\t\t\t\t\tbatch.viewmodels.push( instance.viewmodel );\n\t\t\t\t}\n\t\t\t\treturn promise;\n\t\t\t},\n\t\t\tend: function() {\n\t\t\t\tflushChanges();\n\t\t\t\tbatch.transitionManager.init();\n\t\t\t\tbatch = batch.previousBatch;\n\t\t\t},\n\t\t\taddViewmodel: function( viewmodel ) {\n\t\t\t\tif ( batch ) {\n\t\t\t\t\tif ( batch.viewmodels.indexOf( viewmodel ) === -1 ) {\n\t\t\t\t\t\tbatch.viewmodels.push( viewmodel );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tviewmodel.applyChanges();\n\t\t\t\t}\n\t\t\t},\n\t\t\tregisterTransition: function( transition ) {\n\t\t\t\ttransition._manager = batch.transitionManager;\n\t\t\t\tbatch.transitionManager.add( transition );\n\t\t\t},\n\t\t\taddView: function( view ) {\n\t\t\t\tbatch.views.push( view );\n\t\t\t},\n\t\t\taddUnresolved: function( thing ) {\n\t\t\t\tunresolved.push( thing );\n\t\t\t},\n\t\t\tremoveUnresolved: function( thing ) {\n\t\t\t\tremoveFromArray( unresolved, thing );\n\t\t\t},\n\t\t\t// synchronise node detachments with transition ends\n\t\t\tdetachWhenReady: function( thing ) {\n\t\t\t\tbatch.transitionManager.detachQueue.push( thing );\n\t\t\t},\n\t\t\tscheduleTask: function( task ) {\n\t\t\t\tif ( !batch ) {\n\t\t\t\t\ttask();\n\t\t\t\t} else {\n\t\t\t\t\tbatch.tasks.push( task );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tcircular.runloop = runloop;\n\t\t__export = runloop;\n\n\t\tfunction flushChanges() {\n\t\t\tvar i, thing, changeHash;\n\t\t\tfor ( i = 0; i < batch.viewmodels.length; i += 1 ) {\n\t\t\t\tthing = batch.viewmodels[ i ];\n\t\t\t\tchangeHash = thing.applyChanges();\n\t\t\t\tif ( changeHash ) {\n\t\t\t\t\tchangeHook.fire( thing.ractive, changeHash );\n\t\t\t\t}\n\t\t\t}\n\t\t\tbatch.viewmodels.length = 0;\n\t\t\tattemptKeypathResolution();\n\t\t\t// Now that changes have been fully propagated, we can update the DOM\n\t\t\t// and complete other tasks\n\t\t\tfor ( i = 0; i < batch.views.length; i += 1 ) {\n\t\t\t\tbatch.views[ i ].update();\n\t\t\t}\n\t\t\tbatch.views.length = 0;\n\t\t\tfor ( i = 0; i < batch.tasks.length; i += 1 ) {\n\t\t\t\tbatch.tasks[ i ]();\n\t\t\t}\n\t\t\tbatch.tasks.length = 0;\n\t\t\t// If updating the view caused some model blowback - e.g. a triple\n\t\t\t// containing <option> elements caused the binding on the <select>\n\t\t\t// to update - then we start over\n\t\t\tif ( batch.viewmodels.length )\n\t\t\t\treturn flushChanges();\n\t\t}\n\n\t\tfunction attemptKeypathResolution() {\n\t\t\tvar i, item, keypath, resolved;\n\t\t\ti = unresolved.length;\n\t\t\t// see if we can resolve any unresolved references\n\t\t\twhile ( i-- ) {\n\t\t\t\titem = unresolved[ i ];\n\t\t\t\tif ( item.keypath ) {\n\t\t\t\t\t// it resolved some other way. TODO how? two-way binding? Seems\n\t\t\t\t\t// weird that we'd still end up here\n\t\t\t\t\tunresolved.splice( i, 1 );\n\t\t\t\t}\n\t\t\t\tif ( keypath = resolveRef( item.root, item.ref, item.parentFragment ) ) {\n\t\t\t\t\t( resolved || ( resolved = [] ) ).push( {\n\t\t\t\t\t\titem: item,\n\t\t\t\t\t\tkeypath: keypath\n\t\t\t\t\t} );\n\t\t\t\t\tunresolved.splice( i, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( resolved ) {\n\t\t\t\tresolved.forEach( resolve );\n\t\t\t}\n\t\t}\n\n\t\tfunction resolve( resolved ) {\n\t\t\tresolved.item.resolve( resolved.keypath );\n\t\t}\n\t\treturn __export;\n\t}( circular, Ractive$shared_hooks_Hook, removeFromArray, Promise, resolveRef, TransitionManager );\n\n\t/* utils/createBranch.js */\n\tvar createBranch = function() {\n\n\t\tvar numeric = /^\\s*[0-9]+\\s*$/;\n\t\treturn function( key ) {\n\t\t\treturn numeric.test( key ) ? [] : {};\n\t\t};\n\t}();\n\n\t/* viewmodel/prototype/get/magicAdaptor.js */\n\tvar viewmodel$get_magicAdaptor = function( runloop, createBranch, isArray ) {\n\n\t\tvar __export;\n\t\tvar magicAdaptor, MagicWrapper;\n\t\ttry {\n\t\t\tObject.defineProperty( {}, 'test', {\n\t\t\t\tvalue: 0\n\t\t\t} );\n\t\t\tmagicAdaptor = {\n\t\t\t\tfilter: function( object, keypath, ractive ) {\n\t\t\t\t\tvar keys, key, parentKeypath, parentWrapper, parentValue;\n\t\t\t\t\tif ( !keypath ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tkeys = keypath.split( '.' );\n\t\t\t\t\tkey = keys.pop();\n\t\t\t\t\tparentKeypath = keys.join( '.' );\n\t\t\t\t\t// If the parent value is a wrapper, other than a magic wrapper,\n\t\t\t\t\t// we shouldn't wrap this property\n\t\t\t\t\tif ( ( parentWrapper = ractive.viewmodel.wrapped[ parentKeypath ] ) && !parentWrapper.magic ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tparentValue = ractive.get( parentKeypath );\n\t\t\t\t\t// if parentValue is an array that doesn't include this member,\n\t\t\t\t\t// we should return false otherwise lengths will get messed up\n\t\t\t\t\tif ( isArray( parentValue ) && /^[0-9]+$/.test( key ) ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' );\n\t\t\t\t},\n\t\t\t\twrap: function( ractive, property, keypath ) {\n\t\t\t\t\treturn new MagicWrapper( ractive, property, keypath );\n\t\t\t\t}\n\t\t\t};\n\t\t\tMagicWrapper = function( ractive, value, keypath ) {\n\t\t\t\tvar keys, objKeypath, template, siblings;\n\t\t\t\tthis.magic = true;\n\t\t\t\tthis.ractive = ractive;\n\t\t\t\tthis.keypath = keypath;\n\t\t\t\tthis.value = value;\n\t\t\t\tkeys = keypath.split( '.' );\n\t\t\t\tthis.prop = keys.pop();\n\t\t\t\tobjKeypath = keys.join( '.' );\n\t\t\t\tthis.obj = objKeypath ? ractive.get( objKeypath ) : ractive.data;\n\t\t\t\ttemplate = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\t\t\t\t// Has this property already been wrapped?\n\t\t\t\tif ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {\n\t\t\t\t\t// Yes. Register this wrapper to this property, if it hasn't been already\n\t\t\t\t\tif ( siblings.indexOf( this ) === -1 ) {\n\t\t\t\t\t\tsiblings.push( this );\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// No, it hasn't been wrapped\n\t\t\t\tcreateAccessors( this, value, template );\n\t\t\t};\n\t\t\tMagicWrapper.prototype = {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn this.value;\n\t\t\t\t},\n\t\t\t\treset: function( value ) {\n\t\t\t\t\tif ( this.updating ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.updating = true;\n\t\t\t\t\tthis.obj[ this.prop ] = value;\n\t\t\t\t\t// trigger set() accessor\n\t\t\t\t\trunloop.addViewmodel( this.ractive.viewmodel );\n\t\t\t\t\tthis.ractive.viewmodel.mark( this.keypath );\n\t\t\t\t\tthis.updating = false;\n\t\t\t\t},\n\t\t\t\tset: function( key, value ) {\n\t\t\t\t\tif ( this.updating ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !this.obj[ this.prop ] ) {\n\t\t\t\t\t\tthis.updating = true;\n\t\t\t\t\t\tthis.obj[ this.prop ] = createBranch( key );\n\t\t\t\t\t\tthis.updating = false;\n\t\t\t\t\t}\n\t\t\t\t\tthis.obj[ this.prop ][ key ] = value;\n\t\t\t\t},\n\t\t\t\tteardown: function() {\n\t\t\t\t\tvar template, set, value, wrappers, index;\n\t\t\t\t\t// If this method was called because the cache was being cleared as a\n\t\t\t\t\t// result of a set()/update() call made by this wrapper, we return false\n\t\t\t\t\t// so that it doesn't get torn down\n\t\t\t\t\tif ( this.updating ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\ttemplate = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\t\t\t\t\tset = template && template.set;\n\t\t\t\t\tif ( !set ) {\n\t\t\t\t\t\t// most likely, this was an array member that was spliced out\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\twrappers = set._ractiveWrappers;\n\t\t\t\t\tindex = wrappers.indexOf( this );\n\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\twrappers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t\t// Last one out, turn off the lights\n\t\t\t\t\tif ( !wrappers.length ) {\n\t\t\t\t\t\tvalue = this.obj[ this.prop ];\n\t\t\t\t\t\tObject.defineProperty( this.obj, this.prop, this.originalDescriptor || {\n\t\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tthis.obj[ this.prop ] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t} catch ( err ) {\n\t\t\tmagicAdaptor = false;\n\t\t}\n\t\t__export = magicAdaptor;\n\n\t\tfunction createAccessors( originalWrapper, value, template ) {\n\t\t\tvar object, property, oldGet, oldSet, get, set;\n\t\t\tobject = originalWrapper.obj;\n\t\t\tproperty = originalWrapper.prop;\n\t\t\t// Is this template configurable?\n\t\t\tif ( template && !template.configurable ) {\n\t\t\t\t// Special case - array length\n\t\t\t\tif ( property === 'length' ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new Error( 'Cannot use magic mode with property \"' + property + '\" - object is not configurable' );\n\t\t\t}\n\t\t\t// Time to wrap this property\n\t\t\tif ( template ) {\n\t\t\t\toldGet = template.get;\n\t\t\t\toldSet = template.set;\n\t\t\t}\n\t\t\tget = oldGet || function() {\n\t\t\t\treturn value;\n\t\t\t};\n\t\t\tset = function( v ) {\n\t\t\t\tif ( oldSet ) {\n\t\t\t\t\toldSet( v );\n\t\t\t\t}\n\t\t\t\tvalue = oldGet ? oldGet() : v;\n\t\t\t\tset._ractiveWrappers.forEach( updateWrapper );\n\t\t\t};\n\n\t\t\tfunction updateWrapper( wrapper ) {\n\t\t\t\tvar keypath, ractive;\n\t\t\t\twrapper.value = value;\n\t\t\t\tif ( wrapper.updating ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tractive = wrapper.ractive;\n\t\t\t\tkeypath = wrapper.keypath;\n\t\t\t\twrapper.updating = true;\n\t\t\t\trunloop.start( ractive );\n\t\t\t\tractive.viewmodel.mark( keypath );\n\t\t\t\trunloop.end();\n\t\t\t\twrapper.updating = false;\n\t\t\t}\n\t\t\t// Create an array of wrappers, in case other keypaths/ractives depend on this property.\n\t\t\t// Handily, we can store them as a property of the set function. Yay JavaScript.\n\t\t\tset._ractiveWrappers = [ originalWrapper ];\n\t\t\tObject.defineProperty( object, property, {\n\t\t\t\tget: get,\n\t\t\t\tset: set,\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true\n\t\t\t} );\n\t\t}\n\t\treturn __export;\n\t}( runloop, createBranch, isArray );\n\n\t/* config/magic.js */\n\tvar magic = function( magicAdaptor ) {\n\n\t\treturn !!magicAdaptor;\n\t}( viewmodel$get_magicAdaptor );\n\n\t/* config/namespaces.js */\n\tvar namespaces = {\n\t\thtml: 'http://www.w3.org/1999/xhtml',\n\t\tmathml: 'http://www.w3.org/1998/Math/MathML',\n\t\tsvg: 'http://www.w3.org/2000/svg',\n\t\txlink: 'http://www.w3.org/1999/xlink',\n\t\txml: 'http://www.w3.org/XML/1998/namespace',\n\t\txmlns: 'http://www.w3.org/2000/xmlns/'\n\t};\n\n\t/* utils/createElement.js */\n\tvar createElement = function( svg, namespaces ) {\n\n\t\tvar createElement;\n\t\t// Test for SVG support\n\t\tif ( !svg ) {\n\t\t\tcreateElement = function( type, ns ) {\n\t\t\t\tif ( ns && ns !== namespaces.html ) {\n\t\t\t\t\tthrow 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';\n\t\t\t\t}\n\t\t\t\treturn document.createElement( type );\n\t\t\t};\n\t\t} else {\n\t\t\tcreateElement = function( type, ns ) {\n\t\t\t\tif ( !ns || ns === namespaces.html ) {\n\t\t\t\t\treturn document.createElement( type );\n\t\t\t\t}\n\t\t\t\treturn document.createElementNS( ns, type );\n\t\t\t};\n\t\t}\n\t\treturn createElement;\n\t}( svg, namespaces );\n\n\t/* config/isClient.js */\n\tvar isClient = function() {\n\n\t\tvar isClient = typeof document === 'object';\n\t\treturn isClient;\n\t}();\n\n\t/* utils/defineProperty.js */\n\tvar defineProperty = function( isClient ) {\n\n\t\tvar defineProperty;\n\t\ttry {\n\t\t\tObject.defineProperty( {}, 'test', {\n\t\t\t\tvalue: 0\n\t\t\t} );\n\t\t\tif ( isClient ) {\n\t\t\t\tObject.defineProperty( document.createElement( 'div' ), 'test', {\n\t\t\t\t\tvalue: 0\n\t\t\t\t} );\n\t\t\t}\n\t\t\tdefineProperty = Object.defineProperty;\n\t\t} catch ( err ) {\n\t\t\t// Object.defineProperty doesn't exist, or we're in IE8 where you can\n\t\t\t// only use it with DOM objects (what the fuck were you smoking, MSFT?)\n\t\t\tdefineProperty = function( obj, prop, desc ) {\n\t\t\t\tobj[ prop ] = desc.value;\n\t\t\t};\n\t\t}\n\t\treturn defineProperty;\n\t}( isClient );\n\n\t/* utils/defineProperties.js */\n\tvar defineProperties = function( createElement, defineProperty, isClient ) {\n\n\t\tvar defineProperties;\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tObject.defineProperties( {}, {\n\t\t\t\t\ttest: {\n\t\t\t\t\t\tvalue: 0\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} catch ( err ) {\n\t\t\t\t// TODO how do we account for this? noMagic = true;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t\tif ( isClient ) {\n\t\t\t\tObject.defineProperties( createElement( 'div' ), {\n\t\t\t\t\ttest: {\n\t\t\t\t\t\tvalue: 0\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\tdefineProperties = Object.defineProperties;\n\t\t} catch ( err ) {\n\t\t\tdefineProperties = function( obj, props ) {\n\t\t\t\tvar prop;\n\t\t\t\tfor ( prop in props ) {\n\t\t\t\t\tif ( props.hasOwnProperty( prop ) ) {\n\t\t\t\t\t\tdefineProperty( obj, prop, props[ prop ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn defineProperties;\n\t}( createElement, defineProperty, isClient );\n\n\t/* Ractive/prototype/shared/add.js */\n\tvar Ractive$shared_add = function( isNumeric ) {\n\n\t\treturn function add( root, keypath, d ) {\n\t\t\tvar value;\n\t\t\tif ( typeof keypath !== 'string' || !isNumeric( d ) ) {\n\t\t\t\tthrow new Error( 'Bad arguments' );\n\t\t\t}\n\t\t\tvalue = +root.get( keypath ) || 0;\n\t\t\tif ( !isNumeric( value ) ) {\n\t\t\t\tthrow new Error( 'Cannot add to a non-numeric value' );\n\t\t\t}\n\t\t\treturn root.set( keypath, value + d );\n\t\t};\n\t}( isNumeric );\n\n\t/* Ractive/prototype/add.js */\n\tvar Ractive$add = function( add ) {\n\n\t\treturn function Ractive$add( keypath, d ) {\n\t\t\treturn add( this, keypath, d === undefined ? 1 : +d );\n\t\t};\n\t}( Ractive$shared_add );\n\n\t/* utils/normaliseKeypath.js */\n\tvar normaliseKeypath = function( normaliseRef ) {\n\n\t\tvar leadingDot = /^\\.+/;\n\t\treturn function normaliseKeypath( keypath ) {\n\t\t\treturn normaliseRef( keypath ).replace( leadingDot, '' );\n\t\t};\n\t}( normaliseRef );\n\n\t/* config/vendors.js */\n\tvar vendors = [\n\t\t'o',\n\t\t'ms',\n\t\t'moz',\n\t\t'webkit'\n\t];\n\n\t/* utils/requestAnimationFrame.js */\n\tvar requestAnimationFrame = function( vendors ) {\n\n\t\tvar requestAnimationFrame;\n\t\t// If window doesn't exist, we don't need requestAnimationFrame\n\t\tif ( typeof window === 'undefined' ) {\n\t\t\trequestAnimationFrame = null;\n\t\t} else {\n\t\t\t// https://gist.github.com/paulirish/1579671\n\t\t\t( function( vendors, lastTime, window ) {\n\t\t\t\tvar x, setTimeout;\n\t\t\t\tif ( window.requestAnimationFrame ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor ( x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {\n\t\t\t\t\twindow.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];\n\t\t\t\t}\n\t\t\t\tif ( !window.requestAnimationFrame ) {\n\t\t\t\t\tsetTimeout = window.setTimeout;\n\t\t\t\t\twindow.requestAnimationFrame = function( callback ) {\n\t\t\t\t\t\tvar currTime, timeToCall, id;\n\t\t\t\t\t\tcurrTime = Date.now();\n\t\t\t\t\t\ttimeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );\n\t\t\t\t\t\tid = setTimeout( function() {\n\t\t\t\t\t\t\tcallback( currTime + timeToCall );\n\t\t\t\t\t\t}, timeToCall );\n\t\t\t\t\t\tlastTime = currTime + timeToCall;\n\t\t\t\t\t\treturn id;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}( vendors, 0, window ) );\n\t\t\trequestAnimationFrame = window.requestAnimationFrame;\n\t\t}\n\t\treturn requestAnimationFrame;\n\t}( vendors );\n\n\t/* utils/getTime.js */\n\tvar getTime = function() {\n\n\t\tvar getTime;\n\t\tif ( typeof window !== 'undefined' && window.performance && typeof window.performance.now === 'function' ) {\n\t\t\tgetTime = function() {\n\t\t\t\treturn window.performance.now();\n\t\t\t};\n\t\t} else {\n\t\t\tgetTime = function() {\n\t\t\t\treturn Date.now();\n\t\t\t};\n\t\t}\n\t\treturn getTime;\n\t}();\n\n\t/* shared/animations.js */\n\tvar animations = function( rAF, getTime, runloop ) {\n\n\t\tvar queue = [];\n\t\tvar animations = {\n\t\t\ttick: function() {\n\t\t\t\tvar i, animation, now;\n\t\t\t\tnow = getTime();\n\t\t\t\trunloop.start();\n\t\t\t\tfor ( i = 0; i < queue.length; i += 1 ) {\n\t\t\t\t\tanimation = queue[ i ];\n\t\t\t\t\tif ( !animation.tick( now ) ) {\n\t\t\t\t\t\t// animation is complete, remove it from the stack, and decrement i so we don't miss one\n\t\t\t\t\t\tqueue.splice( i--, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trunloop.end();\n\t\t\t\tif ( queue.length ) {\n\t\t\t\t\trAF( animations.tick );\n\t\t\t\t} else {\n\t\t\t\t\tanimations.running = false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tadd: function( animation ) {\n\t\t\t\tqueue.push( animation );\n\t\t\t\tif ( !animations.running ) {\n\t\t\t\t\tanimations.running = true;\n\t\t\t\t\trAF( animations.tick );\n\t\t\t\t}\n\t\t\t},\n\t\t\t// TODO optimise this\n\t\t\tabort: function( keypath, root ) {\n\t\t\t\tvar i = queue.length,\n\t\t\t\t\tanimation;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tanimation = queue[ i ];\n\t\t\t\t\tif ( animation.root === root && animation.keypath === keypath ) {\n\t\t\t\t\t\tanimation.stop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn animations;\n\t}( requestAnimationFrame, getTime, runloop );\n\n\t/* config/options/css/transform.js */\n\tvar transform = function() {\n\n\t\tvar __export;\n\t\tvar selectorsPattern = /(?:^|\\})?\\s*([^\\{\\}]+)\\s*\\{/g,\n\t\t\tcommentsPattern = /\\/\\*.*?\\*\\//g,\n\t\t\tselectorUnitPattern = /((?:(?:\\[[^\\]+]\\])|(?:[^\\s\\+\\>\\~:]))+)((?::[^\\s\\+\\>\\~]+)?\\s*[\\s\\+\\>\\~]?)\\s*/g,\n\t\t\tmediaQueryPattern = /^@media/,\n\t\t\tdataRvcGuidPattern = /\\[data-rvcguid=\"[a-z0-9-]+\"]/g;\n\t\t__export = function transformCss( css, guid ) {\n\t\t\tvar transformed, addGuid;\n\t\t\taddGuid = function( selector ) {\n\t\t\t\tvar selectorUnits, match, unit, dataAttr, base, prepended, appended, i, transformed = [];\n\t\t\t\tselectorUnits = [];\n\t\t\t\twhile ( match = selectorUnitPattern.exec( selector ) ) {\n\t\t\t\t\tselectorUnits.push( {\n\t\t\t\t\t\tstr: match[ 0 ],\n\t\t\t\t\t\tbase: match[ 1 ],\n\t\t\t\t\t\tmodifiers: match[ 2 ]\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\t// For each simple selector within the selector, we need to create a version\n\t\t\t\t// that a) combines with the guid, and b) is inside the guid\n\t\t\t\tdataAttr = '[data-rvcguid=\"' + guid + '\"]';\n\t\t\t\tbase = selectorUnits.map( extractString );\n\t\t\t\ti = selectorUnits.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tappended = base.slice();\n\t\t\t\t\t// Pseudo-selectors should go after the attribute selector\n\t\t\t\t\tunit = selectorUnits[ i ];\n\t\t\t\t\tappended[ i ] = unit.base + dataAttr + unit.modifiers || '';\n\t\t\t\t\tprepended = base.slice();\n\t\t\t\t\tprepended[ i ] = dataAttr + ' ' + prepended[ i ];\n\t\t\t\t\ttransformed.push( appended.join( ' ' ), prepended.join( ' ' ) );\n\t\t\t\t}\n\t\t\t\treturn transformed.join( ', ' );\n\t\t\t};\n\t\t\tif ( dataRvcGuidPattern.test( css ) ) {\n\t\t\t\ttransformed = css.replace( dataRvcGuidPattern, '[data-rvcguid=\"' + guid + '\"]' );\n\t\t\t} else {\n\t\t\t\ttransformed = css.replace( commentsPattern, '' ).replace( selectorsPattern, function( match, $1 ) {\n\t\t\t\t\tvar selectors, transformed;\n\t\t\t\t\t// don't transform media queries!\n\t\t\t\t\tif ( mediaQueryPattern.test( $1 ) )\n\t\t\t\t\t\treturn match;\n\t\t\t\t\tselectors = $1.split( ',' ).map( trim );\n\t\t\t\t\ttransformed = selectors.map( addGuid ).join( ', ' ) + ' ';\n\t\t\t\t\treturn match.replace( $1, transformed );\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn transformed;\n\t\t};\n\n\t\tfunction trim( str ) {\n\t\t\tif ( str.trim ) {\n\t\t\t\treturn str.trim();\n\t\t\t}\n\t\t\treturn str.replace( /^\\s+/, '' ).replace( /\\s+$/, '' );\n\t\t}\n\n\t\tfunction extractString( unit ) {\n\t\t\treturn unit.str;\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* config/options/css/css.js */\n\tvar css = function( transformCss ) {\n\n\t\tvar cssConfig = {\n\t\t\tname: 'css',\n\t\t\textend: extend,\n\t\t\tinit: function() {}\n\t\t};\n\n\t\tfunction extend( Parent, proto, options ) {\n\t\t\tvar guid = proto.constructor._guid,\n\t\t\t\tcss;\n\t\t\tif ( css = getCss( options.css, options, guid ) || getCss( Parent.css, Parent, guid ) ) {\n\t\t\t\tproto.constructor.css = css;\n\t\t\t}\n\t\t}\n\n\t\tfunction getCss( css, target, guid ) {\n\t\t\tif ( !css ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn target.noCssTransform ? css : transformCss( css, guid );\n\t\t}\n\t\treturn cssConfig;\n\t}( transform );\n\n\t/* utils/wrapMethod.js */\n\tvar wrapMethod = function() {\n\n\t\tvar __export;\n\t\t__export = function( method, superMethod, force ) {\n\t\t\tif ( force || needsSuper( method, superMethod ) ) {\n\t\t\t\treturn function() {\n\t\t\t\t\tvar hasSuper = '_super' in this,\n\t\t\t\t\t\t_super = this._super,\n\t\t\t\t\t\tresult;\n\t\t\t\t\tthis._super = superMethod;\n\t\t\t\t\tresult = method.apply( this, arguments );\n\t\t\t\t\tif ( hasSuper ) {\n\t\t\t\t\t\tthis._super = _super;\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn method;\n\t\t\t}\n\t\t};\n\n\t\tfunction needsSuper( method, superMethod ) {\n\t\t\treturn typeof superMethod === 'function' && /_super/.test( method );\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* config/options/data.js */\n\tvar data = function( wrap ) {\n\n\t\tvar __export;\n\t\tvar dataConfig = {\n\t\t\tname: 'data',\n\t\t\textend: extend,\n\t\t\tinit: init,\n\t\t\treset: reset\n\t\t};\n\t\t__export = dataConfig;\n\n\t\tfunction combine( Parent, target, options ) {\n\t\t\tvar value = options.data || {},\n\t\t\t\tparentValue = getAddedKeys( Parent.prototype.data );\n\t\t\tif ( typeof value !== 'object' && typeof value !== 'function' ) {\n\t\t\t\tthrow new TypeError( 'data option must be an object or a function, \"' + value + '\" is not valid' );\n\t\t\t}\n\t\t\treturn dispatch( parentValue, value );\n\t\t}\n\n\t\tfunction extend( Parent, proto, options ) {\n\t\t\tproto.data = combine( Parent, proto, options );\n\t\t}\n\n\t\tfunction init( Parent, ractive, options ) {\n\t\t\tvar value = options.data,\n\t\t\t\tresult = combine( Parent, ractive, options );\n\t\t\tif ( typeof result === 'function' ) {\n\t\t\t\tresult = result.call( ractive, value ) || value;\n\t\t\t}\n\t\t\treturn ractive.data = result || {};\n\t\t}\n\n\t\tfunction reset( ractive ) {\n\t\t\tvar result = this.init( ractive.constructor, ractive, ractive );\n\t\t\tif ( result ) {\n\t\t\t\tractive.data = result;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getAddedKeys( parent ) {\n\t\t\t// only for functions that had keys added\n\t\t\tif ( typeof parent !== 'function' || !Object.keys( parent ).length ) {\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t\t// copy the added keys to temp 'object', otherwise\n\t\t\t// parent would be interpreted as 'function' by dispatch\n\t\t\tvar temp = {};\n\t\t\tcopy( parent, temp );\n\t\t\t// roll in added keys\n\t\t\treturn dispatch( parent, temp );\n\t\t}\n\n\t\tfunction dispatch( parent, child ) {\n\t\t\tif ( typeof child === 'function' ) {\n\t\t\t\treturn extendFn( child, parent );\n\t\t\t} else if ( typeof parent === 'function' ) {\n\t\t\t\treturn fromFn( child, parent );\n\t\t\t} else {\n\t\t\t\treturn fromProperties( child, parent );\n\t\t\t}\n\t\t}\n\n\t\tfunction copy( from, to, fillOnly ) {\n\t\t\tfor ( var key in from ) {\n\t\t\t\tif ( fillOnly && key in to ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tto[ key ] = from[ key ];\n\t\t\t}\n\t\t}\n\n\t\tfunction fromProperties( child, parent ) {\n\t\t\tchild = child || {};\n\t\t\tif ( !parent ) {\n\t\t\t\treturn child;\n\t\t\t}\n\t\t\tcopy( parent, child, true );\n\t\t\treturn child;\n\t\t}\n\n\t\tfunction fromFn( child, parentFn ) {\n\t\t\treturn function( data ) {\n\t\t\t\tvar keys;\n\t\t\t\tif ( child ) {\n\t\t\t\t\t// Track the keys that our on the child,\n\t\t\t\t\t// but not on the data. We'll need to apply these\n\t\t\t\t\t// after the parent function returns.\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( var key in child ) {\n\t\t\t\t\t\tif ( !data || !( key in data ) ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// call the parent fn, use data if no return value\n\t\t\t\tdata = parentFn.call( this, data ) || data;\n\t\t\t\t// Copy child keys back onto data. The child keys\n\t\t\t\t// should take precedence over whatever the\n\t\t\t\t// parent did with the data.\n\t\t\t\tif ( keys && keys.length ) {\n\t\t\t\t\tdata = data || {};\n\t\t\t\t\tkeys.forEach( function( key ) {\n\t\t\t\t\t\tdata[ key ] = child[ key ];\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t\t};\n\t\t}\n\n\t\tfunction extendFn( childFn, parent ) {\n\t\t\tvar parentFn;\n\t\t\tif ( typeof parent !== 'function' ) {\n\t\t\t\t// copy props to data\n\t\t\t\tparentFn = function( data ) {\n\t\t\t\t\tfromProperties( data, parent );\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tparentFn = function( data ) {\n\t\t\t\t\t// give parent function it's own this._super context,\n\t\t\t\t\t// otherwise this._super is from child and\n\t\t\t\t\t// causes infinite loop\n\t\t\t\t\tparent = wrap( parent, function() {}, true );\n\t\t\t\t\treturn parent.call( this, data ) || data;\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn wrap( childFn, parentFn );\n\t\t}\n\t\treturn __export;\n\t}( wrapMethod );\n\n\t/* config/types.js */\n\tvar types = {\n\t\tTEXT: 1,\n\t\tINTERPOLATOR: 2,\n\t\tTRIPLE: 3,\n\t\tSECTION: 4,\n\t\tINVERTED: 5,\n\t\tCLOSING: 6,\n\t\tELEMENT: 7,\n\t\tPARTIAL: 8,\n\t\tCOMMENT: 9,\n\t\tDELIMCHANGE: 10,\n\t\tMUSTACHE: 11,\n\t\tTAG: 12,\n\t\tATTRIBUTE: 13,\n\t\tCLOSING_TAG: 14,\n\t\tCOMPONENT: 15,\n\t\tNUMBER_LITERAL: 20,\n\t\tSTRING_LITERAL: 21,\n\t\tARRAY_LITERAL: 22,\n\t\tOBJECT_LITERAL: 23,\n\t\tBOOLEAN_LITERAL: 24,\n\t\tGLOBAL: 26,\n\t\tKEY_VALUE_PAIR: 27,\n\t\tREFERENCE: 30,\n\t\tREFINEMENT: 31,\n\t\tMEMBER: 32,\n\t\tPREFIX_OPERATOR: 33,\n\t\tBRACKETED: 34,\n\t\tCONDITIONAL: 35,\n\t\tINFIX_OPERATOR: 36,\n\t\tINVOCATION: 40,\n\t\tSECTION_IF: 50,\n\t\tSECTION_UNLESS: 51,\n\t\tSECTION_EACH: 52,\n\t\tSECTION_WITH: 53,\n\t\tSECTION_IF_WITH: 54\n\t};\n\n\t/* utils/create.js */\n\tvar create = function() {\n\n\t\tvar create;\n\t\ttry {\n\t\t\tObject.create( null );\n\t\t\tcreate = Object.create;\n\t\t} catch ( err ) {\n\t\t\t// sigh\n\t\t\tcreate = function() {\n\t\t\t\tvar F = function() {};\n\t\t\t\treturn function( proto, props ) {\n\t\t\t\t\tvar obj;\n\t\t\t\t\tif ( proto === null ) {\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t\tF.prototype = proto;\n\t\t\t\t\tobj = new F();\n\t\t\t\t\tif ( props ) {\n\t\t\t\t\t\tObject.defineProperties( obj, props );\n\t\t\t\t\t}\n\t\t\t\t\treturn obj;\n\t\t\t\t};\n\t\t\t}();\n\t\t}\n\t\treturn create;\n\t}();\n\n\t/* parse/Parser/expressions/shared/errors.js */\n\tvar parse_Parser_expressions_shared_errors = {\n\t\texpectedExpression: 'Expected a JavaScript expression',\n\t\texpectedParen: 'Expected closing paren'\n\t};\n\n\t/* parse/Parser/expressions/primary/literal/numberLiteral.js */\n\tvar numberLiteral = function( types ) {\n\n\t\tvar numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\t\treturn function( parser ) {\n\t\t\tvar result;\n\t\t\tif ( result = parser.matchPattern( numberPattern ) ) {\n\t\t\t\treturn {\n\t\t\t\t\tt: types.NUMBER_LITERAL,\n\t\t\t\t\tv: result\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t}( types );\n\n\t/* parse/Parser/expressions/primary/literal/booleanLiteral.js */\n\tvar booleanLiteral = function( types ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar remaining = parser.remaining();\n\t\t\tif ( remaining.substr( 0, 4 ) === 'true' ) {\n\t\t\t\tparser.pos += 4;\n\t\t\t\treturn {\n\t\t\t\t\tt: types.BOOLEAN_LITERAL,\n\t\t\t\t\tv: 'true'\n\t\t\t\t};\n\t\t\t}\n\t\t\tif ( remaining.substr( 0, 5 ) === 'false' ) {\n\t\t\t\tparser.pos += 5;\n\t\t\t\treturn {\n\t\t\t\t\tt: types.BOOLEAN_LITERAL,\n\t\t\t\t\tv: 'false'\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t}( types );\n\n\t/* parse/Parser/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js */\n\tvar makeQuotedStringMatcher = function() {\n\n\t\tvar stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;\n\t\t// Match one or more characters until: \", ', \\, or EOL/EOF.\n\t\t// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\n\t\tstringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/;\n\t\t// Match one escape sequence, including the backslash.\n\t\tescapeSequencePattern = /^\\\\(?:['\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\t\t// Match one ES5 line continuation (backslash + line terminator).\n\t\tlineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\t\t// Helper for defining getDoubleQuotedString and getSingleQuotedString.\n\t\treturn function( okQuote ) {\n\t\t\treturn function( parser ) {\n\t\t\t\tvar start, literal, done, next;\n\t\t\t\tstart = parser.pos;\n\t\t\t\tliteral = '\"';\n\t\t\t\tdone = false;\n\t\t\t\twhile ( !done ) {\n\t\t\t\t\tnext = parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) || parser.matchString( okQuote );\n\t\t\t\t\tif ( next ) {\n\t\t\t\t\t\tif ( next === '\"' ) {\n\t\t\t\t\t\t\tliteral += '\\\\\"';\n\t\t\t\t\t\t} else if ( next === '\\\\\\'' ) {\n\t\t\t\t\t\t\tliteral += '\\'';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tliteral += next;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext = parser.matchPattern( lineContinuationPattern );\n\t\t\t\t\t\tif ( next ) {\n\t\t\t\t\t\t\t// convert \\(newline-like) into a \\u escape, which is allowed in JSON\n\t\t\t\t\t\t\tliteral += '\\\\u' + ( '000' + next.charCodeAt( 1 ).toString( 16 ) ).slice( -4 );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tliteral += '\"';\n\t\t\t\t// use JSON.parse to interpret escapes\n\t\t\t\treturn JSON.parse( literal );\n\t\t\t};\n\t\t};\n\t}();\n\n\t/* parse/Parser/expressions/primary/literal/stringLiteral/singleQuotedString.js */\n\tvar singleQuotedString = function( makeQuotedStringMatcher ) {\n\n\t\treturn makeQuotedStringMatcher( '\"' );\n\t}( makeQuotedStringMatcher );\n\n\t/* parse/Parser/expressions/primary/literal/stringLiteral/doubleQuotedString.js */\n\tvar doubleQuotedString = function( makeQuotedStringMatcher ) {\n\n\t\treturn makeQuotedStringMatcher( '\\'' );\n\t}( makeQuotedStringMatcher );\n\n\t/* parse/Parser/expressions/primary/literal/stringLiteral/_stringLiteral.js */\n\tvar stringLiteral = function( types, getSingleQuotedString, getDoubleQuotedString ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar start, string;\n\t\t\tstart = parser.pos;\n\t\t\tif ( parser.matchString( '\"' ) ) {\n\t\t\t\tstring = getDoubleQuotedString( parser );\n\t\t\t\tif ( !parser.matchString( '\"' ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tt: types.STRING_LITERAL,\n\t\t\t\t\tv: string\n\t\t\t\t};\n\t\t\t}\n\t\t\tif ( parser.matchString( '\\'' ) ) {\n\t\t\t\tstring = getSingleQuotedString( parser );\n\t\t\t\tif ( !parser.matchString( '\\'' ) ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tt: types.STRING_LITERAL,\n\t\t\t\t\tv: string\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t}( types, singleQuotedString, doubleQuotedString );\n\n\t/* parse/Parser/expressions/shared/patterns.js */\n\tvar patterns = {\n\t\tname: /^[a-zA-Z_$][a-zA-Z_$0-9]*/\n\t};\n\n\t/* parse/Parser/expressions/shared/key.js */\n\tvar key = function( getStringLiteral, getNumberLiteral, patterns ) {\n\n\t\tvar identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n\t\t// http://mathiasbynens.be/notes/javascript-properties\n\t\t// can be any name, string literal, or number literal\n\t\treturn function( parser ) {\n\t\t\tvar token;\n\t\t\tif ( token = getStringLiteral( parser ) ) {\n\t\t\t\treturn identifier.test( token.v ) ? token.v : '\"' + token.v.replace( /\"/g, '\\\\\"' ) + '\"';\n\t\t\t}\n\t\t\tif ( token = getNumberLiteral( parser ) ) {\n\t\t\t\treturn token.v;\n\t\t\t}\n\t\t\tif ( token = parser.matchPattern( patterns.name ) ) {\n\t\t\t\treturn token;\n\t\t\t}\n\t\t};\n\t}( stringLiteral, numberLiteral, patterns );\n\n\t/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePair.js */\n\tvar keyValuePair = function( types, getKey ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar start, key, value;\n\t\t\tstart = parser.pos;\n\t\t\t// allow whitespace between '{' and key\n\t\t\tparser.allowWhitespace();\n\t\t\tkey = getKey( parser );\n\t\t\tif ( key === null ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// allow whitespace between key and ':'\n\t\t\tparser.allowWhitespace();\n\t\t\t// next character must be ':'\n\t\t\tif ( !parser.matchString( ':' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// allow whitespace between ':' and value\n\t\t\tparser.allowWhitespace();\n\t\t\t// next expression must be a, well... expression\n\t\t\tvalue = parser.readExpression();\n\t\t\tif ( value === null ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tt: types.KEY_VALUE_PAIR,\n\t\t\t\tk: key,\n\t\t\t\tv: value\n\t\t\t};\n\t\t};\n\t}( types, key );\n\n\t/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePairs.js */\n\tvar keyValuePairs = function( getKeyValuePair ) {\n\n\t\treturn function getKeyValuePairs( parser ) {\n\t\t\tvar start, pairs, pair, keyValuePairs;\n\t\t\tstart = parser.pos;\n\t\t\tpair = getKeyValuePair( parser );\n\t\t\tif ( pair === null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tpairs = [ pair ];\n\t\t\tif ( parser.matchString( ',' ) ) {\n\t\t\t\tkeyValuePairs = getKeyValuePairs( parser );\n\t\t\t\tif ( !keyValuePairs ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn pairs.concat( keyValuePairs );\n\t\t\t}\n\t\t\treturn pairs;\n\t\t};\n\t}( keyValuePair );\n\n\t/* parse/Parser/expressions/primary/literal/objectLiteral/_objectLiteral.js */\n\tvar objectLiteral = function( types, getKeyValuePairs ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar start, keyValuePairs;\n\t\t\tstart = parser.pos;\n\t\t\t// allow whitespace\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( '{' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tkeyValuePairs = getKeyValuePairs( parser );\n\t\t\t// allow whitespace between final value and '}'\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( '}' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tt: types.OBJECT_LITERAL,\n\t\t\t\tm: keyValuePairs\n\t\t\t};\n\t\t};\n\t}( types, keyValuePairs );\n\n\t/* parse/Parser/expressions/shared/expressionList.js */\n\tvar expressionList = function( errors ) {\n\n\t\treturn function getExpressionList( parser ) {\n\t\t\tvar start, expressions, expr, next;\n\t\t\tstart = parser.pos;\n\t\t\tparser.allowWhitespace();\n\t\t\texpr = parser.readExpression();\n\t\t\tif ( expr === null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\texpressions = [ expr ];\n\t\t\t// allow whitespace between expression and ','\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( parser.matchString( ',' ) ) {\n\t\t\t\tnext = getExpressionList( parser );\n\t\t\t\tif ( next === null ) {\n\t\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t\t}\n\t\t\t\tnext.forEach( append );\n\t\t\t}\n\n\t\t\tfunction append( expression ) {\n\t\t\t\texpressions.push( expression );\n\t\t\t}\n\t\t\treturn expressions;\n\t\t};\n\t}( parse_Parser_expressions_shared_errors );\n\n\t/* parse/Parser/expressions/primary/literal/arrayLiteral.js */\n\tvar arrayLiteral = function( types, getExpressionList ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar start, expressionList;\n\t\t\tstart = parser.pos;\n\t\t\t// allow whitespace before '['\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( '[' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\texpressionList = getExpressionList( parser );\n\t\t\tif ( !parser.matchString( ']' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tt: types.ARRAY_LITERAL,\n\t\t\t\tm: expressionList\n\t\t\t};\n\t\t};\n\t}( types, expressionList );\n\n\t/* parse/Parser/expressions/primary/literal/_literal.js */\n\tvar literal = function( getNumberLiteral, getBooleanLiteral, getStringLiteral, getObjectLiteral, getArrayLiteral ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar literal = getNumberLiteral( parser ) || getBooleanLiteral( parser ) || getStringLiteral( parser ) || getObjectLiteral( parser ) || getArrayLiteral( parser );\n\t\t\treturn literal;\n\t\t};\n\t}( numberLiteral, booleanLiteral, stringLiteral, objectLiteral, arrayLiteral );\n\n\t/* parse/Parser/expressions/primary/reference.js */\n\tvar reference = function( types, patterns ) {\n\n\t\tvar dotRefinementPattern, arrayMemberPattern, getArrayRefinement, globals, keywords;\n\t\tdotRefinementPattern = /^\\.[a-zA-Z_$0-9]+/;\n\t\tgetArrayRefinement = function( parser ) {\n\t\t\tvar num = parser.matchPattern( arrayMemberPattern );\n\t\t\tif ( num ) {\n\t\t\t\treturn '.' + num;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tarrayMemberPattern = /^\\[(0|[1-9][0-9]*)\\]/;\n\t\t// if a reference is a browser global, we don't deference it later, so it needs special treatment\n\t\tglobals = /^(?:Array|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)$/;\n\t\t// keywords are not valid references, with the exception of `this`\n\t\tkeywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\t\treturn function( parser ) {\n\t\t\tvar startPos, ancestor, name, dot, combo, refinement, lastDotIndex;\n\t\t\tstartPos = parser.pos;\n\t\t\t// we might have a root-level reference\n\t\t\tif ( parser.matchString( '~/' ) ) {\n\t\t\t\tancestor = '~/';\n\t\t\t} else {\n\t\t\t\t// we might have ancestor refs...\n\t\t\t\tancestor = '';\n\t\t\t\twhile ( parser.matchString( '../' ) ) {\n\t\t\t\t\tancestor += '../';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !ancestor ) {\n\t\t\t\t// we might have an implicit iterator or a restricted reference\n\t\t\t\tdot = parser.matchString( '.' ) || '';\n\t\t\t}\n\t\t\tname = parser.matchPattern( /^@(?:index|key)/ ) || parser.matchPattern( patterns.name ) || '';\n\t\t\t// bug out if it's a keyword\n\t\t\tif ( keywords.test( name ) ) {\n\t\t\t\tparser.pos = startPos;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// if this is a browser global, stop here\n\t\t\tif ( !ancestor && !dot && globals.test( name ) ) {\n\t\t\t\treturn {\n\t\t\t\t\tt: types.GLOBAL,\n\t\t\t\t\tv: name\n\t\t\t\t};\n\t\t\t}\n\t\t\tcombo = ( ancestor || dot ) + name;\n\t\t\tif ( !combo ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\twhile ( refinement = parser.matchPattern( dotRefinementPattern ) || getArrayRefinement( parser ) ) {\n\t\t\t\tcombo += refinement;\n\t\t\t}\n\t\t\tif ( parser.matchString( '(' ) ) {\n\t\t\t\t// if this is a method invocation (as opposed to a function) we need\n\t\t\t\t// to strip the method name from the reference combo, else the context\n\t\t\t\t// will be wrong\n\t\t\t\tlastDotIndex = combo.lastIndexOf( '.' );\n\t\t\t\tif ( lastDotIndex !== -1 ) {\n\t\t\t\t\tcombo = combo.substr( 0, lastDotIndex );\n\t\t\t\t\tparser.pos = startPos + combo.length;\n\t\t\t\t} else {\n\t\t\t\t\tparser.pos -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tt: types.REFERENCE,\n\t\t\t\tn: combo.replace( /^this\\./, './' ).replace( /^this$/, '.' )\n\t\t\t};\n\t\t};\n\t}( types, patterns );\n\n\t/* parse/Parser/expressions/primary/bracketedExpression.js */\n\tvar bracketedExpression = function( types, errors ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar start, expr;\n\t\t\tstart = parser.pos;\n\t\t\tif ( !parser.matchString( '(' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\texpr = parser.readExpression();\n\t\t\tif ( !expr ) {\n\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( ')' ) ) {\n\t\t\t\tparser.error( errors.expectedParen );\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tt: types.BRACKETED,\n\t\t\t\tx: expr\n\t\t\t};\n\t\t};\n\t}( types, parse_Parser_expressions_shared_errors );\n\n\t/* parse/Parser/expressions/primary/_primary.js */\n\tvar primary = function( getLiteral, getReference, getBracketedExpression ) {\n\n\t\treturn function( parser ) {\n\t\t\treturn getLiteral( parser ) || getReference( parser ) || getBracketedExpression( parser );\n\t\t};\n\t}( literal, reference, bracketedExpression );\n\n\t/* parse/Parser/expressions/shared/refinement.js */\n\tvar refinement = function( types, errors, patterns ) {\n\n\t\treturn function getRefinement( parser ) {\n\t\t\tvar start, name, expr;\n\t\t\tstart = parser.pos;\n\t\t\tparser.allowWhitespace();\n\t\t\t// \".\" name\n\t\t\tif ( parser.matchString( '.' ) ) {\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tif ( name = parser.matchPattern( patterns.name ) ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tt: types.REFINEMENT,\n\t\t\t\t\t\tn: name\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tparser.error( 'Expected a property name' );\n\t\t\t}\n\t\t\t// \"[\" expression \"]\"\n\t\t\tif ( parser.matchString( '[' ) ) {\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\texpr = parser.readExpression();\n\t\t\t\tif ( !expr ) {\n\t\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t\t}\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\tif ( !parser.matchString( ']' ) ) {\n\t\t\t\t\tparser.error( 'Expected \\']\\'' );\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tt: types.REFINEMENT,\n\t\t\t\t\tx: expr\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t}( types, parse_Parser_expressions_shared_errors, patterns );\n\n\t/* parse/Parser/expressions/memberOrInvocation.js */\n\tvar memberOrInvocation = function( types, getPrimary, getExpressionList, getRefinement, errors ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar current, expression, refinement, expressionList;\n\t\t\texpression = getPrimary( parser );\n\t\t\tif ( !expression ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\twhile ( expression ) {\n\t\t\t\tcurrent = parser.pos;\n\t\t\t\tif ( refinement = getRefinement( parser ) ) {\n\t\t\t\t\texpression = {\n\t\t\t\t\t\tt: types.MEMBER,\n\t\t\t\t\t\tx: expression,\n\t\t\t\t\t\tr: refinement\n\t\t\t\t\t};\n\t\t\t\t} else if ( parser.matchString( '(' ) ) {\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\texpressionList = getExpressionList( parser );\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\tif ( !parser.matchString( ')' ) ) {\n\t\t\t\t\t\tparser.error( errors.expectedParen );\n\t\t\t\t\t}\n\t\t\t\t\texpression = {\n\t\t\t\t\t\tt: types.INVOCATION,\n\t\t\t\t\t\tx: expression\n\t\t\t\t\t};\n\t\t\t\t\tif ( expressionList ) {\n\t\t\t\t\t\texpression.o = expressionList;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn expression;\n\t\t};\n\t}( types, primary, expressionList, refinement, parse_Parser_expressions_shared_errors );\n\n\t/* parse/Parser/expressions/typeof.js */\n\tvar _typeof = function( types, errors, getMemberOrInvocation ) {\n\n\t\tvar getTypeof, makePrefixSequenceMatcher;\n\t\tmakePrefixSequenceMatcher = function( symbol, fallthrough ) {\n\t\t\treturn function( parser ) {\n\t\t\t\tvar expression;\n\t\t\t\tif ( expression = fallthrough( parser ) ) {\n\t\t\t\t\treturn expression;\n\t\t\t\t}\n\t\t\t\tif ( !parser.matchString( symbol ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\texpression = parser.readExpression();\n\t\t\t\tif ( !expression ) {\n\t\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ts: symbol,\n\t\t\t\t\to: expression,\n\t\t\t\t\tt: types.PREFIX_OPERATOR\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\t// create all prefix sequence matchers, return getTypeof\n\t\t( function() {\n\t\t\tvar i, len, matcher, prefixOperators, fallthrough;\n\t\t\tprefixOperators = '! ~ + - typeof'.split( ' ' );\n\t\t\tfallthrough = getMemberOrInvocation;\n\t\t\tfor ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {\n\t\t\t\tmatcher = makePrefixSequenceMatcher( prefixOperators[ i ], fallthrough );\n\t\t\t\tfallthrough = matcher;\n\t\t\t}\n\t\t\t// typeof operator is higher precedence than multiplication, so provides the\n\t\t\t// fallthrough for the multiplication sequence matcher we're about to create\n\t\t\t// (we're skipping void and delete)\n\t\t\tgetTypeof = fallthrough;\n\t\t}() );\n\t\treturn getTypeof;\n\t}( types, parse_Parser_expressions_shared_errors, memberOrInvocation );\n\n\t/* parse/Parser/expressions/logicalOr.js */\n\tvar logicalOr = function( types, getTypeof ) {\n\n\t\tvar getLogicalOr, makeInfixSequenceMatcher;\n\t\tmakeInfixSequenceMatcher = function( symbol, fallthrough ) {\n\t\t\treturn function( parser ) {\n\t\t\t\tvar start, left, right;\n\t\t\t\tleft = fallthrough( parser );\n\t\t\t\tif ( !left ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// Loop to handle left-recursion in a case like `a * b * c` and produce\n\t\t\t\t// left association, i.e. `(a * b) * c`.  The matcher can't call itself\n\t\t\t\t// to parse `left` because that would be infinite regress.\n\t\t\t\twhile ( true ) {\n\t\t\t\t\tstart = parser.pos;\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\tif ( !parser.matchString( symbol ) ) {\n\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\treturn left;\n\t\t\t\t\t}\n\t\t\t\t\t// special case - in operator must not be followed by [a-zA-Z_$0-9]\n\t\t\t\t\tif ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {\n\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\treturn left;\n\t\t\t\t\t}\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t// right operand must also consist of only higher-precedence operators\n\t\t\t\t\tright = fallthrough( parser );\n\t\t\t\t\tif ( !right ) {\n\t\t\t\t\t\tparser.pos = start;\n\t\t\t\t\t\treturn left;\n\t\t\t\t\t}\n\t\t\t\t\tleft = {\n\t\t\t\t\t\tt: types.INFIX_OPERATOR,\n\t\t\t\t\t\ts: symbol,\n\t\t\t\t\t\to: [\n\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\tright\n\t\t\t\t\t\t]\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\t// create all infix sequence matchers, and return getLogicalOr\n\t\t( function() {\n\t\t\tvar i, len, matcher, infixOperators, fallthrough;\n\t\t\t// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n\t\t\t// Each sequence matcher will initially fall through to its higher precedence\n\t\t\t// neighbour, and only attempt to match if one of the higher precedence operators\n\t\t\t// (or, ultimately, a literal, reference, or bracketed expression) already matched\n\t\t\tinfixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );\n\t\t\t// A typeof operator is higher precedence than multiplication\n\t\t\tfallthrough = getTypeof;\n\t\t\tfor ( i = 0, len = infixOperators.length; i < len; i += 1 ) {\n\t\t\t\tmatcher = makeInfixSequenceMatcher( infixOperators[ i ], fallthrough );\n\t\t\t\tfallthrough = matcher;\n\t\t\t}\n\t\t\t// Logical OR is the fallthrough for the conditional matcher\n\t\t\tgetLogicalOr = fallthrough;\n\t\t}() );\n\t\treturn getLogicalOr;\n\t}( types, _typeof );\n\n\t/* parse/Parser/expressions/conditional.js */\n\tvar conditional = function( types, getLogicalOr, errors ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar start, expression, ifTrue, ifFalse;\n\t\t\texpression = getLogicalOr( parser );\n\t\t\tif ( !expression ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tstart = parser.pos;\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( '?' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn expression;\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\tifTrue = parser.readExpression();\n\t\t\tif ( !ifTrue ) {\n\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( ':' ) ) {\n\t\t\t\tparser.error( 'Expected \":\"' );\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\tifFalse = parser.readExpression();\n\t\t\tif ( !ifFalse ) {\n\t\t\t\tparser.error( errors.expectedExpression );\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tt: types.CONDITIONAL,\n\t\t\t\to: [\n\t\t\t\t\texpression,\n\t\t\t\t\tifTrue,\n\t\t\t\t\tifFalse\n\t\t\t\t]\n\t\t\t};\n\t\t};\n\t}( types, logicalOr, parse_Parser_expressions_shared_errors );\n\n\t/* parse/Parser/utils/flattenExpression.js */\n\tvar flattenExpression = function( types, isObject ) {\n\n\t\tvar __export;\n\t\t__export = function( expression ) {\n\t\t\tvar refs = [],\n\t\t\t\tflattened;\n\t\t\textractRefs( expression, refs );\n\t\t\tflattened = {\n\t\t\t\tr: refs,\n\t\t\t\ts: stringify( this, expression, refs )\n\t\t\t};\n\t\t\treturn flattened;\n\t\t};\n\n\t\tfunction quoteStringLiteral( str ) {\n\t\t\treturn JSON.stringify( String( str ) );\n\t\t}\n\t\t// TODO maybe refactor this?\n\t\tfunction extractRefs( node, refs ) {\n\t\t\tvar i, list;\n\t\t\tif ( node.t === types.REFERENCE ) {\n\t\t\t\tif ( refs.indexOf( node.n ) === -1 ) {\n\t\t\t\t\trefs.unshift( node.n );\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist = node.o || node.m;\n\t\t\tif ( list ) {\n\t\t\t\tif ( isObject( list ) ) {\n\t\t\t\t\textractRefs( list, refs );\n\t\t\t\t} else {\n\t\t\t\t\ti = list.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\textractRefs( list[ i ], refs );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( node.x ) {\n\t\t\t\textractRefs( node.x, refs );\n\t\t\t}\n\t\t\tif ( node.r ) {\n\t\t\t\textractRefs( node.r, refs );\n\t\t\t}\n\t\t\tif ( node.v ) {\n\t\t\t\textractRefs( node.v, refs );\n\t\t\t}\n\t\t}\n\n\t\tfunction stringify( parser, node, refs ) {\n\t\t\tvar stringifyAll = function( item ) {\n\t\t\t\treturn stringify( parser, item, refs );\n\t\t\t};\n\t\t\tswitch ( node.t ) {\n\t\t\t\tcase types.BOOLEAN_LITERAL:\n\t\t\t\tcase types.GLOBAL:\n\t\t\t\tcase types.NUMBER_LITERAL:\n\t\t\t\t\treturn node.v;\n\t\t\t\tcase types.STRING_LITERAL:\n\t\t\t\t\treturn quoteStringLiteral( node.v );\n\t\t\t\tcase types.ARRAY_LITERAL:\n\t\t\t\t\treturn '[' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + ']';\n\t\t\t\tcase types.OBJECT_LITERAL:\n\t\t\t\t\treturn '{' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + '}';\n\t\t\t\tcase types.KEY_VALUE_PAIR:\n\t\t\t\t\treturn node.k + ':' + stringify( parser, node.v, refs );\n\t\t\t\tcase types.PREFIX_OPERATOR:\n\t\t\t\t\treturn ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( parser, node.o, refs );\n\t\t\t\tcase types.INFIX_OPERATOR:\n\t\t\t\t\treturn stringify( parser, node.o[ 0 ], refs ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( parser, node.o[ 1 ], refs );\n\t\t\t\tcase types.INVOCATION:\n\t\t\t\t\treturn stringify( parser, node.x, refs ) + '(' + ( node.o ? node.o.map( stringifyAll ).join( ',' ) : '' ) + ')';\n\t\t\t\tcase types.BRACKETED:\n\t\t\t\t\treturn '(' + stringify( parser, node.x, refs ) + ')';\n\t\t\t\tcase types.MEMBER:\n\t\t\t\t\treturn stringify( parser, node.x, refs ) + stringify( parser, node.r, refs );\n\t\t\t\tcase types.REFINEMENT:\n\t\t\t\t\treturn node.n ? '.' + node.n : '[' + stringify( parser, node.x, refs ) + ']';\n\t\t\t\tcase types.CONDITIONAL:\n\t\t\t\t\treturn stringify( parser, node.o[ 0 ], refs ) + '?' + stringify( parser, node.o[ 1 ], refs ) + ':' + stringify( parser, node.o[ 2 ], refs );\n\t\t\t\tcase types.REFERENCE:\n\t\t\t\t\treturn '_' + refs.indexOf( node.n );\n\t\t\t\tdefault:\n\t\t\t\t\tparser.error( 'Expected legal JavaScript' );\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}( types, isObject );\n\n\t/* parse/Parser/_Parser.js */\n\tvar Parser = function( circular, create, hasOwnProperty, getConditional, flattenExpression ) {\n\n\t\tvar Parser, ParseError, leadingWhitespace = /^\\s+/;\n\t\tParseError = function( message ) {\n\t\t\tthis.name = 'ParseError';\n\t\t\tthis.message = message;\n\t\t\ttry {\n\t\t\t\tthrow new Error( message );\n\t\t\t} catch ( e ) {\n\t\t\t\tthis.stack = e.stack;\n\t\t\t}\n\t\t};\n\t\tParseError.prototype = Error.prototype;\n\t\tParser = function( str, options ) {\n\t\t\tvar items, item, lineStart = 0;\n\t\t\tthis.str = str;\n\t\t\tthis.options = options || {};\n\t\t\tthis.pos = 0;\n\t\t\tthis.lines = this.str.split( '\\n' );\n\t\t\tthis.lineEnds = this.lines.map( function( line ) {\n\t\t\t\tvar lineEnd = lineStart + line.length + 1;\n\t\t\t\t// +1 for the newline\n\t\t\t\tlineStart = lineEnd;\n\t\t\t\treturn lineEnd;\n\t\t\t}, 0 );\n\t\t\t// Custom init logic\n\t\t\tif ( this.init )\n\t\t\t\tthis.init( str, options );\n\t\t\titems = [];\n\t\t\twhile ( this.pos < this.str.length && ( item = this.read() ) ) {\n\t\t\t\titems.push( item );\n\t\t\t}\n\t\t\tthis.leftover = this.remaining();\n\t\t\tthis.result = this.postProcess ? this.postProcess( items, options ) : items;\n\t\t};\n\t\tParser.prototype = {\n\t\t\tread: function( converters ) {\n\t\t\t\tvar pos, i, len, item;\n\t\t\t\tif ( !converters )\n\t\t\t\t\tconverters = this.converters;\n\t\t\t\tpos = this.pos;\n\t\t\t\tlen = converters.length;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tthis.pos = pos;\n\t\t\t\t\t// reset for each attempt\n\t\t\t\t\tif ( item = converters[ i ]( this ) ) {\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\treadExpression: function() {\n\t\t\t\t// The conditional operator is the lowest precedence operator (except yield,\n\t\t\t\t// assignment operators, and commas, none of which are supported), so we\n\t\t\t\t// start there. If it doesn't match, it 'falls through' to progressively\n\t\t\t\t// higher precedence operators, until it eventually matches (or fails to\n\t\t\t\t// match) a 'primary' - a literal or a reference. This way, the abstract syntax\n\t\t\t\t// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n\t\t\t\treturn getConditional( this );\n\t\t\t},\n\t\t\tflattenExpression: flattenExpression,\n\t\t\tgetLinePos: function( char ) {\n\t\t\t\tvar lineNum = 0,\n\t\t\t\t\tlineStart = 0,\n\t\t\t\t\tcolumnNum;\n\t\t\t\twhile ( char >= this.lineEnds[ lineNum ] ) {\n\t\t\t\t\tlineStart = this.lineEnds[ lineNum ];\n\t\t\t\t\tlineNum += 1;\n\t\t\t\t}\n\t\t\t\tcolumnNum = char - lineStart;\n\t\t\t\treturn [\n\t\t\t\t\tlineNum + 1,\n\t\t\t\t\tcolumnNum + 1,\n\t\t\t\t\tchar\n\t\t\t\t];\n\t\t\t},\n\t\t\terror: function( message ) {\n\t\t\t\tvar pos, lineNum, columnNum, line, annotation, error;\n\t\t\t\tpos = this.getLinePos( this.pos );\n\t\t\t\tlineNum = pos[ 0 ];\n\t\t\t\tcolumnNum = pos[ 1 ];\n\t\t\t\tline = this.lines[ pos[ 0 ] - 1 ];\n\t\t\t\tannotation = line + '\\n' + new Array( pos[ 1 ] ).join( ' ' ) + '^----';\n\t\t\t\terror = new ParseError( message + ' at line ' + lineNum + ' character ' + columnNum + ':\\n' + annotation );\n\t\t\t\terror.line = pos[ 0 ];\n\t\t\t\terror.character = pos[ 1 ];\n\t\t\t\terror.shortMessage = message;\n\t\t\t\tthrow error;\n\t\t\t},\n\t\t\tmatchString: function( string ) {\n\t\t\t\tif ( this.str.substr( this.pos, string.length ) === string ) {\n\t\t\t\t\tthis.pos += string.length;\n\t\t\t\t\treturn string;\n\t\t\t\t}\n\t\t\t},\n\t\t\tmatchPattern: function( pattern ) {\n\t\t\t\tvar match;\n\t\t\t\tif ( match = pattern.exec( this.remaining() ) ) {\n\t\t\t\t\tthis.pos += match[ 0 ].length;\n\t\t\t\t\treturn match[ 1 ] || match[ 0 ];\n\t\t\t\t}\n\t\t\t},\n\t\t\tallowWhitespace: function() {\n\t\t\t\tthis.matchPattern( leadingWhitespace );\n\t\t\t},\n\t\t\tremaining: function() {\n\t\t\t\treturn this.str.substring( this.pos );\n\t\t\t},\n\t\t\tnextChar: function() {\n\t\t\t\treturn this.str.charAt( this.pos );\n\t\t\t}\n\t\t};\n\t\tParser.extend = function( proto ) {\n\t\t\tvar Parent = this,\n\t\t\t\tChild, key;\n\t\t\tChild = function( str, options ) {\n\t\t\t\tParser.call( this, str, options );\n\t\t\t};\n\t\t\tChild.prototype = create( Parent.prototype );\n\t\t\tfor ( key in proto ) {\n\t\t\t\tif ( hasOwnProperty.call( proto, key ) ) {\n\t\t\t\t\tChild.prototype[ key ] = proto[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\t\tChild.extend = Parser.extend;\n\t\t\treturn Child;\n\t\t};\n\t\tcircular.Parser = Parser;\n\t\treturn Parser;\n\t}( circular, create, hasOwn, conditional, flattenExpression );\n\n\t/* parse/converters/mustache/delimiterChange.js */\n\tvar delimiterChange = function() {\n\n\t\tvar delimiterChangePattern = /^[^\\s=]+/,\n\t\t\twhitespacePattern = /^\\s+/;\n\t\treturn function( parser ) {\n\t\t\tvar start, opening, closing;\n\t\t\tif ( !parser.matchString( '=' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tstart = parser.pos;\n\t\t\t// allow whitespace before new opening delimiter\n\t\t\tparser.allowWhitespace();\n\t\t\topening = parser.matchPattern( delimiterChangePattern );\n\t\t\tif ( !opening ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// allow whitespace (in fact, it's necessary...)\n\t\t\tif ( !parser.matchPattern( whitespacePattern ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tclosing = parser.matchPattern( delimiterChangePattern );\n\t\t\tif ( !closing ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// allow whitespace before closing '='\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( '=' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn [\n\t\t\t\topening,\n\t\t\t\tclosing\n\t\t\t];\n\t\t};\n\t}();\n\n\t/* parse/converters/mustache/delimiterTypes.js */\n\tvar delimiterTypes = [ {\n\t\tdelimiters: 'delimiters',\n\t\tisTriple: false,\n\t\tisStatic: false\n\t}, {\n\t\tdelimiters: 'tripleDelimiters',\n\t\tisTriple: true,\n\t\tisStatic: false\n\t}, {\n\t\tdelimiters: 'staticDelimiters',\n\t\tisTriple: false,\n\t\tisStatic: true\n\t}, {\n\t\tdelimiters: 'staticTripleDelimiters',\n\t\tisTriple: true,\n\t\tisStatic: true\n\t} ];\n\n\t/* parse/converters/mustache/type.js */\n\tvar type = function( types ) {\n\n\t\tvar mustacheTypes = {\n\t\t\t'#': types.SECTION,\n\t\t\t'^': types.INVERTED,\n\t\t\t'/': types.CLOSING,\n\t\t\t'>': types.PARTIAL,\n\t\t\t'!': types.COMMENT,\n\t\t\t'&': types.TRIPLE\n\t\t};\n\t\treturn function( parser ) {\n\t\t\tvar type = mustacheTypes[ parser.str.charAt( parser.pos ) ];\n\t\t\tif ( !type ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.pos += 1;\n\t\t\treturn type;\n\t\t};\n\t}( types );\n\n\t/* parse/converters/mustache/handlebarsBlockCodes.js */\n\tvar handlebarsBlockCodes = function( types ) {\n\n\t\treturn {\n\t\t\t'each': types.SECTION_EACH,\n\t\t\t'if': types.SECTION_IF,\n\t\t\t'if-with': types.SECTION_IF_WITH,\n\t\t\t'with': types.SECTION_WITH,\n\t\t\t'unless': types.SECTION_UNLESS\n\t\t};\n\t}( types );\n\n\t/* empty/legacy.js */\n\tvar legacy = null;\n\n\t/* parse/converters/mustache/content.js */\n\tvar content = function( types, mustacheType, handlebarsBlockCodes ) {\n\n\t\tvar __export;\n\t\tvar indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n\t\t\tarrayMemberPattern = /^[0-9][1-9]*$/,\n\t\t\thandlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\\\b' ),\n\t\t\tlegalReference;\n\t\tlegalReference = /^[a-zA-Z$_0-9]+(?:(\\.[a-zA-Z$_0-9]+)|(\\[[a-zA-Z$_0-9]+\\]))*$/;\n\t\t__export = function( parser, delimiterType ) {\n\t\t\tvar start, pos, mustache, type, block, expression, i, remaining, index, delimiters;\n\t\t\tstart = parser.pos;\n\t\t\tmustache = {};\n\t\t\tdelimiters = parser[ delimiterType.delimiters ];\n\t\t\tif ( delimiterType.isStatic ) {\n\t\t\t\tmustache.s = true;\n\t\t\t}\n\t\t\t// Determine mustache type\n\t\t\tif ( delimiterType.isTriple ) {\n\t\t\t\tmustache.t = types.TRIPLE;\n\t\t\t} else {\n\t\t\t\t// We need to test for expressions before we test for mustache type, because\n\t\t\t\t// an expression that begins '!' looks a lot like a comment\n\t\t\t\tif ( parser.remaining()[ 0 ] === '!' ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\texpression = parser.readExpression();\n\t\t\t\t\t\t// Was it actually an expression, or a comment block in disguise?\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\tif ( parser.remaining().indexOf( delimiters[ 1 ] ) ) {\n\t\t\t\t\t\t\texpression = null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmustache.t = types.INTERPOLATOR;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch ( err ) {}\n\t\t\t\t\tif ( !expression ) {\n\t\t\t\t\t\tindex = parser.remaining().indexOf( delimiters[ 1 ] );\n\t\t\t\t\t\tif ( ~index ) {\n\t\t\t\t\t\t\tparser.pos += index;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparser.error( 'Expected closing delimiter (\\'' + delimiters[ 1 ] + '\\')' );\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tt: types.COMMENT\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !expression ) {\n\t\t\t\t\ttype = mustacheType( parser );\n\t\t\t\t\tmustache.t = type || types.INTERPOLATOR;\n\t\t\t\t\t// default\n\t\t\t\t\t// See if there's an explicit section type e.g. {{#with}}...{{/with}}\n\t\t\t\t\tif ( type === types.SECTION ) {\n\t\t\t\t\t\tif ( block = parser.matchPattern( handlebarsBlockPattern ) ) {\n\t\t\t\t\t\t\tmustache.n = block;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t} else if ( type === types.COMMENT || type === types.CLOSING ) {\n\t\t\t\t\t\tremaining = parser.remaining();\n\t\t\t\t\t\tindex = remaining.indexOf( delimiters[ 1 ] );\n\t\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\t\tmustache.r = remaining.substr( 0, index ).split( ' ' )[ 0 ];\n\t\t\t\t\t\t\tparser.pos += index;\n\t\t\t\t\t\t\treturn mustache;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !expression ) {\n\t\t\t\t// allow whitespace\n\t\t\t\tparser.allowWhitespace();\n\t\t\t\t// get expression\n\t\t\t\texpression = parser.readExpression();\n\t\t\t\t// If this is a partial, it may have a context (e.g. `{{>item foo}}`). These\n\t\t\t\t// cases involve a bit of a hack - we want to turn it into the equivalent of\n\t\t\t\t// `{{#with foo}}{{>item}}{{/with}}`, but to get there we temporarily append\n\t\t\t\t// a 'contextPartialExpression' to the mustache, and process the context instead of\n\t\t\t\t// the reference\n\t\t\t\tvar temp;\n\t\t\t\tif ( mustache.t === types.PARTIAL && expression && ( temp = parser.readExpression() ) ) {\n\t\t\t\t\tmustache = {\n\t\t\t\t\t\tcontextPartialExpression: expression\n\t\t\t\t\t};\n\t\t\t\t\texpression = temp;\n\t\t\t\t}\n\t\t\t\t// With certain valid references that aren't valid expressions,\n\t\t\t\t// e.g. {{1.foo}}, we have a problem: it looks like we've got an\n\t\t\t\t// expression, but the expression didn't consume the entire\n\t\t\t\t// reference. So we need to check that the mustache delimiters\n\t\t\t\t// appear next, unless there's an index reference (i.e. a colon)\n\t\t\t\tremaining = parser.remaining();\n\t\t\t\tif ( remaining.substr( 0, delimiters[ 1 ].length ) !== delimiters[ 1 ] && remaining.charAt( 0 ) !== ':' ) {\n\t\t\t\t\tpos = parser.pos;\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\tremaining = parser.remaining();\n\t\t\t\t\tindex = remaining.indexOf( delimiters[ 1 ] );\n\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\tmustache.r = remaining.substr( 0, index ).trim();\n\t\t\t\t\t\t// Check it's a legal reference\n\t\t\t\t\t\tif ( !legalReference.test( mustache.r ) ) {\n\t\t\t\t\t\t\tparser.error( 'Expected a legal Mustache reference' );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.pos += index;\n\t\t\t\t\t\treturn mustache;\n\t\t\t\t\t}\n\t\t\t\t\tparser.pos = pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\trefineExpression( parser, expression, mustache );\n\t\t\t// if there was context, process the expression now and save it for later\n\t\t\tif ( mustache.contextPartialExpression ) {\n\t\t\t\tmustache.contextPartialExpression = [ refineExpression( parser, mustache.contextPartialExpression, {\n\t\t\t\t\tt: types.PARTIAL\n\t\t\t\t} ) ];\n\t\t\t}\n\t\t\t// optional index reference\n\t\t\tif ( i = parser.matchPattern( indexRefPattern ) ) {\n\t\t\t\tmustache.i = i;\n\t\t\t}\n\t\t\treturn mustache;\n\t\t};\n\n\t\tfunction refineExpression( parser, expression, mustache ) {\n\t\t\tvar referenceExpression;\n\t\t\tif ( expression ) {\n\t\t\t\twhile ( expression.t === types.BRACKETED && expression.x ) {\n\t\t\t\t\texpression = expression.x;\n\t\t\t\t}\n\t\t\t\t// special case - integers should be treated as array members references,\n\t\t\t\t// rather than as expressions in their own right\n\t\t\t\tif ( expression.t === types.REFERENCE ) {\n\t\t\t\t\tmustache.r = expression.n;\n\t\t\t\t} else {\n\t\t\t\t\tif ( expression.t === types.NUMBER_LITERAL && arrayMemberPattern.test( expression.v ) ) {\n\t\t\t\t\t\tmustache.r = expression.v;\n\t\t\t\t\t} else if ( referenceExpression = getReferenceExpression( parser, expression ) ) {\n\t\t\t\t\t\tmustache.rx = referenceExpression;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmustache.x = parser.flattenExpression( expression );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn mustache;\n\t\t\t}\n\t\t}\n\t\t// TODO refactor this! it's bewildering\n\t\tfunction getReferenceExpression( parser, expression ) {\n\t\t\tvar members = [],\n\t\t\t\trefinement;\n\t\t\twhile ( expression.t === types.MEMBER && expression.r.t === types.REFINEMENT ) {\n\t\t\t\trefinement = expression.r;\n\t\t\t\tif ( refinement.x ) {\n\t\t\t\t\tif ( refinement.x.t === types.REFERENCE ) {\n\t\t\t\t\t\tmembers.unshift( refinement.x );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmembers.unshift( parser.flattenExpression( refinement.x ) );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmembers.unshift( refinement.n );\n\t\t\t\t}\n\t\t\t\texpression = expression.x;\n\t\t\t}\n\t\t\tif ( expression.t !== types.REFERENCE ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tr: expression.n,\n\t\t\t\tm: members\n\t\t\t};\n\t\t}\n\t\treturn __export;\n\t}( types, type, handlebarsBlockCodes, legacy );\n\n\t/* parse/converters/mustache.js */\n\tvar mustache = function( types, delimiterChange, delimiterTypes, mustacheContent, handlebarsBlockCodes ) {\n\n\t\tvar __export;\n\t\tvar delimiterChangeToken = {\n\t\t\t\tt: types.DELIMCHANGE,\n\t\t\t\texclude: true\n\t\t\t},\n\t\t\thandlebarsIndexRefPattern = /^@(?:index|key)$/;\n\t\t__export = getMustache;\n\n\t\tfunction getMustache( parser ) {\n\t\t\tvar types;\n\t\t\t// If we're inside a <script> or <style> tag, and we're not\n\t\t\t// interpolating, bug out\n\t\t\tif ( parser.interpolate[ parser.inside ] === false ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\ttypes = delimiterTypes.slice().sort( function compare( a, b ) {\n\t\t\t\t// Sort in order of descending opening delimiter length (longer first),\n\t\t\t\t// to protect against opening delimiters being substrings of each other\n\t\t\t\treturn parser[ b.delimiters ][ 0 ].length - parser[ a.delimiters ][ 0 ].length;\n\t\t\t} );\n\t\t\treturn function r( type ) {\n\t\t\t\tif ( !type ) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\treturn getMustacheOfType( parser, type ) || r( types.shift() );\n\t\t\t\t}\n\t\t\t}( types.shift() );\n\t\t}\n\n\t\tfunction getMustacheOfType( parser, delimiterType ) {\n\t\t\tvar start, mustache, delimiters, children, expectedClose, elseChildren, currentChildren, child, indexRef;\n\t\t\tstart = parser.pos;\n\t\t\tdelimiters = parser[ delimiterType.delimiters ];\n\t\t\tif ( !parser.matchString( delimiters[ 0 ] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// delimiter change?\n\t\t\tif ( mustache = delimiterChange( parser ) ) {\n\t\t\t\t// find closing delimiter or abort...\n\t\t\t\tif ( !parser.matchString( delimiters[ 1 ] ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// ...then make the switch\n\t\t\t\tparser[ delimiterType.delimiters ] = mustache;\n\t\t\t\treturn delimiterChangeToken;\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\tmustache = mustacheContent( parser, delimiterType );\n\t\t\tif ( mustache === null ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// allow whitespace before closing delimiter\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( delimiters[ 1 ] ) ) {\n\t\t\t\tparser.error( 'Expected closing delimiter \\'' + delimiters[ 1 ] + '\\' after reference' );\n\t\t\t}\n\t\t\tif ( mustache.t === types.COMMENT ) {\n\t\t\t\tmustache.exclude = true;\n\t\t\t}\n\t\t\tif ( mustache.t === types.CLOSING ) {\n\t\t\t\tparser.sectionDepth -= 1;\n\t\t\t\tif ( parser.sectionDepth < 0 ) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\tparser.error( 'Attempted to close a section that wasn\\'t open' );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// partials with context\n\t\t\tif ( mustache.contextPartialExpression ) {\n\t\t\t\tmustache.f = mustache.contextPartialExpression;\n\t\t\t\tmustache.t = types.SECTION;\n\t\t\t\tmustache.n = 'with';\n\t\t\t\tdelete mustache.contextPartialExpression;\n\t\t\t} else if ( isSection( mustache ) ) {\n\t\t\t\tparser.sectionDepth += 1;\n\t\t\t\tchildren = [];\n\t\t\t\tcurrentChildren = children;\n\t\t\t\texpectedClose = mustache.n;\n\t\t\t\twhile ( child = parser.read() ) {\n\t\t\t\t\tif ( child.t === types.CLOSING ) {\n\t\t\t\t\t\tif ( expectedClose && child.r !== expectedClose ) {\n\t\t\t\t\t\t\tparser.error( 'Expected {{/' + expectedClose + '}}' );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// {{else}} tags require special treatment\n\t\t\t\t\tif ( child.t === types.INTERPOLATOR && child.r === 'else' ) {\n\t\t\t\t\t\t// no {{else}} allowed in {{#unless}}\n\t\t\t\t\t\tif ( mustache.n === 'unless' ) {\n\t\t\t\t\t\t\tparser.error( '{{else}} not allowed in {{#unless}}' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrentChildren = elseChildren = [];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcurrentChildren.push( child );\n\t\t\t\t}\n\t\t\t\tif ( children.length ) {\n\t\t\t\t\tmustache.f = children;\n\t\t\t\t\t// If this is an 'each' section, and it contains an {{@index}} or {{@key}},\n\t\t\t\t\t// we need to set the index reference accordingly\n\t\t\t\t\tif ( !mustache.i && mustache.n === 'each' && ( indexRef = handlebarsIndexRef( mustache.f ) ) ) {\n\t\t\t\t\t\tmustache.i = indexRef;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( elseChildren && elseChildren.length ) {\n\t\t\t\t\tmustache.l = elseChildren;\n\t\t\t\t\tif ( mustache.n === 'with' ) {\n\t\t\t\t\t\tmustache.n = 'if-with';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( parser.includeLinePositions ) {\n\t\t\t\tmustache.p = parser.getLinePos( start );\n\t\t\t}\n\t\t\t// Replace block name with code\n\t\t\tif ( mustache.n ) {\n\t\t\t\tmustache.n = handlebarsBlockCodes[ mustache.n ];\n\t\t\t} else if ( mustache.t === types.INVERTED ) {\n\t\t\t\tmustache.t = types.SECTION;\n\t\t\t\tmustache.n = types.SECTION_UNLESS;\n\t\t\t}\n\t\t\treturn mustache;\n\t\t}\n\n\t\tfunction handlebarsIndexRef( fragment ) {\n\t\t\tvar i, child, indexRef, name;\n\t\t\tif ( !fragment ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ti = fragment.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tchild = fragment[ i ];\n\t\t\t\t// Recurse into elements (but not sections)\n\t\t\t\tif ( child.t === types.ELEMENT ) {\n\t\t\t\t\tif ( indexRef = // directive arguments\n\t\t\t\t\t\thandlebarsIndexRef( child.o && child.o.d ) || handlebarsIndexRef( child.t0 && child.t0.d ) || handlebarsIndexRef( child.t1 && child.t1.d ) || handlebarsIndexRef( child.t2 && child.t2.d ) || // children\n\t\t\t\t\t\thandlebarsIndexRef( child.f ) ) {\n\t\t\t\t\t\treturn indexRef;\n\t\t\t\t\t}\n\t\t\t\t\t// proxy events\n\t\t\t\t\tfor ( name in child.v ) {\n\t\t\t\t\t\tif ( child.v.hasOwnProperty( name ) && child.v[ name ].d && ( indexRef = handlebarsIndexRef( child.v[ name ].d ) ) ) {\n\t\t\t\t\t\t\treturn indexRef;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// attributes\n\t\t\t\t\tfor ( name in child.a ) {\n\t\t\t\t\t\tif ( child.a.hasOwnProperty( name ) && ( indexRef = handlebarsIndexRef( child.a[ name ] ) ) ) {\n\t\t\t\t\t\t\treturn indexRef;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Mustache?\n\t\t\t\tif ( child.t === types.INTERPOLATOR || child.t === types.TRIPLE || child.t === types.SECTION ) {\n\t\t\t\t\t// Normal reference?\n\t\t\t\t\tif ( child.r && handlebarsIndexRefPattern.test( child.r ) ) {\n\t\t\t\t\t\treturn child.r;\n\t\t\t\t\t}\n\t\t\t\t\t// Expression?\n\t\t\t\t\tif ( child.x && ( indexRef = indexRefContainedInExpression( child.x ) ) ) {\n\t\t\t\t\t\treturn indexRef;\n\t\t\t\t\t}\n\t\t\t\t\t// Reference expression?\n\t\t\t\t\tif ( child.rx && ( indexRef = indexRefContainedInReferenceExpression( child.rx ) ) ) {\n\t\t\t\t\t\treturn indexRef;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction indexRefContainedInExpression( expression ) {\n\t\t\tvar i;\n\t\t\ti = expression.r.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( handlebarsIndexRefPattern.test( expression.r[ i ] ) ) {\n\t\t\t\t\treturn expression.r[ i ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction indexRefContainedInReferenceExpression( referenceExpression ) {\n\t\t\tvar i, indexRef, member;\n\t\t\ti = referenceExpression.m.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tmember = referenceExpression.m[ i ];\n\t\t\t\tif ( member.r && ( indexRef = indexRefContainedInExpression( member ) ) ) {\n\t\t\t\t\treturn indexRef;\n\t\t\t\t}\n\t\t\t\tif ( member.t === types.REFERENCE && handlebarsIndexRefPattern.test( member.n ) ) {\n\t\t\t\t\treturn member.n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction isSection( mustache ) {\n\t\t\treturn mustache.t === types.SECTION || mustache.t === types.INVERTED;\n\t\t}\n\t\treturn __export;\n\t}( types, delimiterChange, delimiterTypes, content, handlebarsBlockCodes );\n\n\t/* parse/converters/comment.js */\n\tvar comment = function( types ) {\n\n\t\tvar OPEN_COMMENT = '<!--',\n\t\t\tCLOSE_COMMENT = '-->';\n\t\treturn function( parser ) {\n\t\t\tvar start, content, remaining, endIndex, comment;\n\t\t\tstart = parser.pos;\n\t\t\tif ( !parser.matchString( OPEN_COMMENT ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tremaining = parser.remaining();\n\t\t\tendIndex = remaining.indexOf( CLOSE_COMMENT );\n\t\t\tif ( endIndex === -1 ) {\n\t\t\t\tparser.error( 'Illegal HTML - expected closing comment sequence (\\'-->\\')' );\n\t\t\t}\n\t\t\tcontent = remaining.substr( 0, endIndex );\n\t\t\tparser.pos += endIndex + 3;\n\t\t\tcomment = {\n\t\t\t\tt: types.COMMENT,\n\t\t\t\tc: content\n\t\t\t};\n\t\t\tif ( parser.includeLinePositions ) {\n\t\t\t\tcomment.p = parser.getLinePos( start );\n\t\t\t}\n\t\t\treturn comment;\n\t\t};\n\t}( types );\n\n\t/* config/voidElementNames.js */\n\tvar voidElementNames = function() {\n\n\t\tvar voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n\t\treturn voidElementNames;\n\t}();\n\n\t/* parse/converters/utils/getLowestIndex.js */\n\tvar getLowestIndex = function( haystack, needles ) {\n\t\tvar i, index, lowest;\n\t\ti = needles.length;\n\t\twhile ( i-- ) {\n\t\t\tindex = haystack.indexOf( needles[ i ] );\n\t\t\t// short circuit\n\t\t\tif ( !index ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ( index === -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( !lowest || index < lowest ) {\n\t\t\t\tlowest = index;\n\t\t\t}\n\t\t}\n\t\treturn lowest || -1;\n\t};\n\n\t/* parse/converters/text.js */\n\tvar text = function( getLowestIndex ) {\n\n\t\treturn function( parser ) {\n\t\t\tvar index, remaining, disallowed, barrier;\n\t\t\tremaining = parser.remaining();\n\t\t\tbarrier = parser.inside ? '</' + parser.inside : '<';\n\t\t\tif ( parser.inside && !parser.interpolate[ parser.inside ] ) {\n\t\t\t\tindex = remaining.indexOf( barrier );\n\t\t\t} else {\n\t\t\t\tdisallowed = [\n\t\t\t\t\tbarrier,\n\t\t\t\t\tparser.delimiters[ 0 ],\n\t\t\t\t\tparser.tripleDelimiters[ 0 ],\n\t\t\t\t\tparser.staticDelimiters[ 0 ],\n\t\t\t\t\tparser.staticTripleDelimiters[ 0 ]\n\t\t\t\t];\n\t\t\t\t// http://developers.whatwg.org/syntax.html#syntax-attributes\n\t\t\t\tif ( parser.inAttribute === true ) {\n\t\t\t\t\t// we're inside an unquoted attribute value\n\t\t\t\t\tdisallowed.push( '\"', '\\'', '=', '>', '`' );\n\t\t\t\t} else if ( parser.inAttribute ) {\n\t\t\t\t\t// quoted attribute value\n\t\t\t\t\tdisallowed.push( parser.inAttribute );\n\t\t\t\t}\n\t\t\t\tindex = getLowestIndex( remaining, disallowed );\n\t\t\t}\n\t\t\tif ( !index ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( index === -1 ) {\n\t\t\t\tindex = remaining.length;\n\t\t\t}\n\t\t\tparser.pos += index;\n\t\t\treturn remaining.substr( 0, index );\n\t\t};\n\t}( getLowestIndex );\n\n\t/* parse/converters/element/closingTag.js */\n\tvar closingTag = function( types ) {\n\n\t\tvar closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n\t\treturn function( parser ) {\n\t\t\tvar tag;\n\t\t\t// are we looking at a closing tag?\n\t\t\tif ( !parser.matchString( '</' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( tag = parser.matchPattern( closingTagPattern ) ) {\n\t\t\t\treturn {\n\t\t\t\t\tt: types.CLOSING_TAG,\n\t\t\t\t\te: tag\n\t\t\t\t};\n\t\t\t}\n\t\t\t// We have an illegal closing tag, report it\n\t\t\tparser.pos -= 2;\n\t\t\tparser.error( 'Illegal closing tag' );\n\t\t};\n\t}( types );\n\n\t/* shared/decodeCharacterReferences.js */\n\tvar decodeCharacterReferences = function() {\n\n\t\tvar __export;\n\t\tvar htmlEntities, controlCharacters, entityPattern;\n\t\thtmlEntities = {\n\t\t\tquot: 34,\n\t\t\tamp: 38,\n\t\t\tapos: 39,\n\t\t\tlt: 60,\n\t\t\tgt: 62,\n\t\t\tnbsp: 160,\n\t\t\tiexcl: 161,\n\t\t\tcent: 162,\n\t\t\tpound: 163,\n\t\t\tcurren: 164,\n\t\t\tyen: 165,\n\t\t\tbrvbar: 166,\n\t\t\tsect: 167,\n\t\t\tuml: 168,\n\t\t\tcopy: 169,\n\t\t\tordf: 170,\n\t\t\tlaquo: 171,\n\t\t\tnot: 172,\n\t\t\tshy: 173,\n\t\t\treg: 174,\n\t\t\tmacr: 175,\n\t\t\tdeg: 176,\n\t\t\tplusmn: 177,\n\t\t\tsup2: 178,\n\t\t\tsup3: 179,\n\t\t\tacute: 180,\n\t\t\tmicro: 181,\n\t\t\tpara: 182,\n\t\t\tmiddot: 183,\n\t\t\tcedil: 184,\n\t\t\tsup1: 185,\n\t\t\tordm: 186,\n\t\t\traquo: 187,\n\t\t\tfrac14: 188,\n\t\t\tfrac12: 189,\n\t\t\tfrac34: 190,\n\t\t\tiquest: 191,\n\t\t\tAgrave: 192,\n\t\t\tAacute: 193,\n\t\t\tAcirc: 194,\n\t\t\tAtilde: 195,\n\t\t\tAuml: 196,\n\t\t\tAring: 197,\n\t\t\tAElig: 198,\n\t\t\tCcedil: 199,\n\t\t\tEgrave: 200,\n\t\t\tEacute: 201,\n\t\t\tEcirc: 202,\n\t\t\tEuml: 203,\n\t\t\tIgrave: 204,\n\t\t\tIacute: 205,\n\t\t\tIcirc: 206,\n\t\t\tIuml: 207,\n\t\t\tETH: 208,\n\t\t\tNtilde: 209,\n\t\t\tOgrave: 210,\n\t\t\tOacute: 211,\n\t\t\tOcirc: 212,\n\t\t\tOtilde: 213,\n\t\t\tOuml: 214,\n\t\t\ttimes: 215,\n\t\t\tOslash: 216,\n\t\t\tUgrave: 217,\n\t\t\tUacute: 218,\n\t\t\tUcirc: 219,\n\t\t\tUuml: 220,\n\t\t\tYacute: 221,\n\t\t\tTHORN: 222,\n\t\t\tszlig: 223,\n\t\t\tagrave: 224,\n\t\t\taacute: 225,\n\t\t\tacirc: 226,\n\t\t\tatilde: 227,\n\t\t\tauml: 228,\n\t\t\taring: 229,\n\t\t\taelig: 230,\n\t\t\tccedil: 231,\n\t\t\tegrave: 232,\n\t\t\teacute: 233,\n\t\t\tecirc: 234,\n\t\t\teuml: 235,\n\t\t\tigrave: 236,\n\t\t\tiacute: 237,\n\t\t\ticirc: 238,\n\t\t\tiuml: 239,\n\t\t\teth: 240,\n\t\t\tntilde: 241,\n\t\t\tograve: 242,\n\t\t\toacute: 243,\n\t\t\tocirc: 244,\n\t\t\totilde: 245,\n\t\t\touml: 246,\n\t\t\tdivide: 247,\n\t\t\toslash: 248,\n\t\t\tugrave: 249,\n\t\t\tuacute: 250,\n\t\t\tucirc: 251,\n\t\t\tuuml: 252,\n\t\t\tyacute: 253,\n\t\t\tthorn: 254,\n\t\t\tyuml: 255,\n\t\t\tOElig: 338,\n\t\t\toelig: 339,\n\t\t\tScaron: 352,\n\t\t\tscaron: 353,\n\t\t\tYuml: 376,\n\t\t\tfnof: 402,\n\t\t\tcirc: 710,\n\t\t\ttilde: 732,\n\t\t\tAlpha: 913,\n\t\t\tBeta: 914,\n\t\t\tGamma: 915,\n\t\t\tDelta: 916,\n\t\t\tEpsilon: 917,\n\t\t\tZeta: 918,\n\t\t\tEta: 919,\n\t\t\tTheta: 920,\n\t\t\tIota: 921,\n\t\t\tKappa: 922,\n\t\t\tLambda: 923,\n\t\t\tMu: 924,\n\t\t\tNu: 925,\n\t\t\tXi: 926,\n\t\t\tOmicron: 927,\n\t\t\tPi: 928,\n\t\t\tRho: 929,\n\t\t\tSigma: 931,\n\t\t\tTau: 932,\n\t\t\tUpsilon: 933,\n\t\t\tPhi: 934,\n\t\t\tChi: 935,\n\t\t\tPsi: 936,\n\t\t\tOmega: 937,\n\t\t\talpha: 945,\n\t\t\tbeta: 946,\n\t\t\tgamma: 947,\n\t\t\tdelta: 948,\n\t\t\tepsilon: 949,\n\t\t\tzeta: 950,\n\t\t\teta: 951,\n\t\t\ttheta: 952,\n\t\t\tiota: 953,\n\t\t\tkappa: 954,\n\t\t\tlambda: 955,\n\t\t\tmu: 956,\n\t\t\tnu: 957,\n\t\t\txi: 958,\n\t\t\tomicron: 959,\n\t\t\tpi: 960,\n\t\t\trho: 961,\n\t\t\tsigmaf: 962,\n\t\t\tsigma: 963,\n\t\t\ttau: 964,\n\t\t\tupsilon: 965,\n\t\t\tphi: 966,\n\t\t\tchi: 967,\n\t\t\tpsi: 968,\n\t\t\tomega: 969,\n\t\t\tthetasym: 977,\n\t\t\tupsih: 978,\n\t\t\tpiv: 982,\n\t\t\tensp: 8194,\n\t\t\temsp: 8195,\n\t\t\tthinsp: 8201,\n\t\t\tzwnj: 8204,\n\t\t\tzwj: 8205,\n\t\t\tlrm: 8206,\n\t\t\trlm: 8207,\n\t\t\tndash: 8211,\n\t\t\tmdash: 8212,\n\t\t\tlsquo: 8216,\n\t\t\trsquo: 8217,\n\t\t\tsbquo: 8218,\n\t\t\tldquo: 8220,\n\t\t\trdquo: 8221,\n\t\t\tbdquo: 8222,\n\t\t\tdagger: 8224,\n\t\t\tDagger: 8225,\n\t\t\tbull: 8226,\n\t\t\thellip: 8230,\n\t\t\tpermil: 8240,\n\t\t\tprime: 8242,\n\t\t\tPrime: 8243,\n\t\t\tlsaquo: 8249,\n\t\t\trsaquo: 8250,\n\t\t\toline: 8254,\n\t\t\tfrasl: 8260,\n\t\t\teuro: 8364,\n\t\t\timage: 8465,\n\t\t\tweierp: 8472,\n\t\t\treal: 8476,\n\t\t\ttrade: 8482,\n\t\t\talefsym: 8501,\n\t\t\tlarr: 8592,\n\t\t\tuarr: 8593,\n\t\t\trarr: 8594,\n\t\t\tdarr: 8595,\n\t\t\tharr: 8596,\n\t\t\tcrarr: 8629,\n\t\t\tlArr: 8656,\n\t\t\tuArr: 8657,\n\t\t\trArr: 8658,\n\t\t\tdArr: 8659,\n\t\t\thArr: 8660,\n\t\t\tforall: 8704,\n\t\t\tpart: 8706,\n\t\t\texist: 8707,\n\t\t\tempty: 8709,\n\t\t\tnabla: 8711,\n\t\t\tisin: 8712,\n\t\t\tnotin: 8713,\n\t\t\tni: 8715,\n\t\t\tprod: 8719,\n\t\t\tsum: 8721,\n\t\t\tminus: 8722,\n\t\t\tlowast: 8727,\n\t\t\tradic: 8730,\n\t\t\tprop: 8733,\n\t\t\tinfin: 8734,\n\t\t\tang: 8736,\n\t\t\tand: 8743,\n\t\t\tor: 8744,\n\t\t\tcap: 8745,\n\t\t\tcup: 8746,\n\t\t\t'int': 8747,\n\t\t\tthere4: 8756,\n\t\t\tsim: 8764,\n\t\t\tcong: 8773,\n\t\t\tasymp: 8776,\n\t\t\tne: 8800,\n\t\t\tequiv: 8801,\n\t\t\tle: 8804,\n\t\t\tge: 8805,\n\t\t\tsub: 8834,\n\t\t\tsup: 8835,\n\t\t\tnsub: 8836,\n\t\t\tsube: 8838,\n\t\t\tsupe: 8839,\n\t\t\toplus: 8853,\n\t\t\totimes: 8855,\n\t\t\tperp: 8869,\n\t\t\tsdot: 8901,\n\t\t\tlceil: 8968,\n\t\t\trceil: 8969,\n\t\t\tlfloor: 8970,\n\t\t\trfloor: 8971,\n\t\t\tlang: 9001,\n\t\t\trang: 9002,\n\t\t\tloz: 9674,\n\t\t\tspades: 9824,\n\t\t\tclubs: 9827,\n\t\t\thearts: 9829,\n\t\t\tdiams: 9830\n\t\t};\n\t\tcontrolCharacters = [\n\t\t\t8364,\n\t\t\t129,\n\t\t\t8218,\n\t\t\t402,\n\t\t\t8222,\n\t\t\t8230,\n\t\t\t8224,\n\t\t\t8225,\n\t\t\t710,\n\t\t\t8240,\n\t\t\t352,\n\t\t\t8249,\n\t\t\t338,\n\t\t\t141,\n\t\t\t381,\n\t\t\t143,\n\t\t\t144,\n\t\t\t8216,\n\t\t\t8217,\n\t\t\t8220,\n\t\t\t8221,\n\t\t\t8226,\n\t\t\t8211,\n\t\t\t8212,\n\t\t\t732,\n\t\t\t8482,\n\t\t\t353,\n\t\t\t8250,\n\t\t\t339,\n\t\t\t157,\n\t\t\t382,\n\t\t\t376\n\t\t];\n\t\tentityPattern = new RegExp( '&(#?(?:x[\\\\w\\\\d]+|\\\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );\n\t\t__export = function decodeCharacterReferences( html ) {\n\t\t\treturn html.replace( entityPattern, function( match, entity ) {\n\t\t\t\tvar code;\n\t\t\t\t// Handle named entities\n\t\t\t\tif ( entity[ 0 ] !== '#' ) {\n\t\t\t\t\tcode = htmlEntities[ entity ];\n\t\t\t\t} else if ( entity[ 1 ] === 'x' ) {\n\t\t\t\t\tcode = parseInt( entity.substring( 2 ), 16 );\n\t\t\t\t} else {\n\t\t\t\t\tcode = parseInt( entity.substring( 1 ), 10 );\n\t\t\t\t}\n\t\t\t\tif ( !code ) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\treturn String.fromCharCode( validateCode( code ) );\n\t\t\t} );\n\t\t};\n\t\t// some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n\t\t// code points with alternatives in some cases - since we're bypassing that mechanism, we need\n\t\t// to replace them ourselves\n\t\t//\n\t\t// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n\t\tfunction validateCode( code ) {\n\t\t\tif ( !code ) {\n\t\t\t\treturn 65533;\n\t\t\t}\n\t\t\t// line feed becomes generic whitespace\n\t\t\tif ( code === 10 ) {\n\t\t\t\treturn 32;\n\t\t\t}\n\t\t\t// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n\t\t\tif ( code < 128 ) {\n\t\t\t\treturn code;\n\t\t\t}\n\t\t\t// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n\t\t\t// to correct the mistake or we'll end up with missing  signs and so on\n\t\t\tif ( code <= 159 ) {\n\t\t\t\treturn controlCharacters[ code - 128 ];\n\t\t\t}\n\t\t\t// basic multilingual plane\n\t\t\tif ( code < 55296 ) {\n\t\t\t\treturn code;\n\t\t\t}\n\t\t\t// UTF-16 surrogate halves\n\t\t\tif ( code <= 57343 ) {\n\t\t\t\treturn 65533;\n\t\t\t}\n\t\t\t// rest of the basic multilingual plane\n\t\t\tif ( code <= 65535 ) {\n\t\t\t\treturn code;\n\t\t\t}\n\t\t\treturn 65533;\n\t\t}\n\t\treturn __export;\n\t}( legacy );\n\n\t/* parse/converters/element/attribute.js */\n\tvar attribute = function( getLowestIndex, getMustache, decodeCharacterReferences ) {\n\n\t\tvar __export;\n\t\tvar attributeNamePattern = /^[^\\s\"'>\\/=]+/,\n\t\t\tunquotedAttributeValueTextPattern = /^[^\\s\"'=<>`]+/;\n\t\t__export = getAttribute;\n\n\t\tfunction getAttribute( parser ) {\n\t\t\tvar attr, name, value;\n\t\t\tparser.allowWhitespace();\n\t\t\tname = parser.matchPattern( attributeNamePattern );\n\t\t\tif ( !name ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tattr = {\n\t\t\t\tname: name\n\t\t\t};\n\t\t\tvalue = getAttributeValue( parser );\n\t\t\tif ( value ) {\n\t\t\t\tattr.value = value;\n\t\t\t}\n\t\t\treturn attr;\n\t\t}\n\n\t\tfunction getAttributeValue( parser ) {\n\t\t\tvar start, valueStart, startDepth, value;\n\t\t\tstart = parser.pos;\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( '=' ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\tvalueStart = parser.pos;\n\t\t\tstartDepth = parser.sectionDepth;\n\t\t\tvalue = getQuotedAttributeValue( parser, '\\'' ) || getQuotedAttributeValue( parser, '\"' ) || getUnquotedAttributeValue( parser );\n\t\t\tif ( parser.sectionDepth !== startDepth ) {\n\t\t\t\tparser.pos = valueStart;\n\t\t\t\tparser.error( 'An attribute value must contain as many opening section tags as closing section tags' );\n\t\t\t}\n\t\t\tif ( value === null ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( !value.length ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( value.length === 1 && typeof value[ 0 ] === 'string' ) {\n\t\t\t\treturn decodeCharacterReferences( value[ 0 ] );\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tfunction getUnquotedAttributeValueToken( parser ) {\n\t\t\tvar start, text, haystack, needles, index;\n\t\t\tstart = parser.pos;\n\t\t\ttext = parser.matchPattern( unquotedAttributeValueTextPattern );\n\t\t\tif ( !text ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\thaystack = text;\n\t\t\tneedles = [\n\t\t\t\tparser.delimiters[ 0 ],\n\t\t\t\tparser.tripleDelimiters[ 0 ],\n\t\t\t\tparser.staticDelimiters[ 0 ],\n\t\t\t\tparser.staticTripleDelimiters[ 0 ]\n\t\t\t];\n\t\t\tif ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {\n\t\t\t\ttext = text.substr( 0, index );\n\t\t\t\tparser.pos = start + text.length;\n\t\t\t}\n\t\t\treturn text;\n\t\t}\n\n\t\tfunction getUnquotedAttributeValue( parser ) {\n\t\t\tvar tokens, token;\n\t\t\tparser.inAttribute = true;\n\t\t\ttokens = [];\n\t\t\ttoken = getMustache( parser ) || getUnquotedAttributeValueToken( parser );\n\t\t\twhile ( token !== null ) {\n\t\t\t\ttokens.push( token );\n\t\t\t\ttoken = getMustache( parser ) || getUnquotedAttributeValueToken( parser );\n\t\t\t}\n\t\t\tif ( !tokens.length ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.inAttribute = false;\n\t\t\treturn tokens;\n\t\t}\n\n\t\tfunction getQuotedAttributeValue( parser, quoteMark ) {\n\t\t\tvar start, tokens, token;\n\t\t\tstart = parser.pos;\n\t\t\tif ( !parser.matchString( quoteMark ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.inAttribute = quoteMark;\n\t\t\ttokens = [];\n\t\t\ttoken = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );\n\t\t\twhile ( token !== null ) {\n\t\t\t\ttokens.push( token );\n\t\t\t\ttoken = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );\n\t\t\t}\n\t\t\tif ( !parser.matchString( quoteMark ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.inAttribute = false;\n\t\t\treturn tokens;\n\t\t}\n\n\t\tfunction getQuotedStringToken( parser, quoteMark ) {\n\t\t\tvar start, index, haystack, needles;\n\t\t\tstart = parser.pos;\n\t\t\thaystack = parser.remaining();\n\t\t\tneedles = [\n\t\t\t\tquoteMark,\n\t\t\t\tparser.delimiters[ 0 ],\n\t\t\t\tparser.tripleDelimiters[ 0 ],\n\t\t\t\tparser.staticDelimiters[ 0 ],\n\t\t\t\tparser.staticTripleDelimiters[ 0 ]\n\t\t\t];\n\t\t\tindex = getLowestIndex( haystack, needles );\n\t\t\tif ( index === -1 ) {\n\t\t\t\tparser.error( 'Quoted attribute value must have a closing quote' );\n\t\t\t}\n\t\t\tif ( !index ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.pos += index;\n\t\t\treturn haystack.substr( 0, index );\n\t\t}\n\t\treturn __export;\n\t}( getLowestIndex, mustache, decodeCharacterReferences );\n\n\t/* utils/parseJSON.js */\n\tvar parseJSON = function( Parser, getStringLiteral, getKey ) {\n\n\t\tvar JsonParser, specials, specialsPattern, numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;\n\t\tspecials = {\n\t\t\t'true': true,\n\t\t\t'false': false,\n\t\t\t'undefined': undefined,\n\t\t\t'null': null\n\t\t};\n\t\tspecialsPattern = new RegExp( '^(?:' + Object.keys( specials ).join( '|' ) + ')' );\n\t\tnumberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\t\tplaceholderPattern = /\\$\\{([^\\}]+)\\}/g;\n\t\tplaceholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\n\t\tonlyWhitespace = /^\\s*$/;\n\t\tJsonParser = Parser.extend( {\n\t\t\tinit: function( str, options ) {\n\t\t\t\tthis.values = options.values;\n\t\t\t\tthis.allowWhitespace();\n\t\t\t},\n\t\t\tpostProcess: function( result ) {\n\t\t\t\tif ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tvalue: result[ 0 ].v\n\t\t\t\t};\n\t\t\t},\n\t\t\tconverters: [\n\n\t\t\t\tfunction getPlaceholder( parser ) {\n\t\t\t\t\tvar placeholder;\n\t\t\t\t\tif ( !parser.values ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tplaceholder = parser.matchPattern( placeholderAtStartPattern );\n\t\t\t\t\tif ( placeholder && parser.values.hasOwnProperty( placeholder ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tv: parser.values[ placeholder ]\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction getSpecial( parser ) {\n\t\t\t\t\tvar special;\n\t\t\t\t\tif ( special = parser.matchPattern( specialsPattern ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tv: specials[ special ]\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction getNumber( parser ) {\n\t\t\t\t\tvar number;\n\t\t\t\t\tif ( number = parser.matchPattern( numberPattern ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tv: +number\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction getString( parser ) {\n\t\t\t\t\tvar stringLiteral = getStringLiteral( parser ),\n\t\t\t\t\t\tvalues;\n\t\t\t\t\tif ( stringLiteral && ( values = parser.values ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tv: stringLiteral.v.replace( placeholderPattern, function( match, $1 ) {\n\t\t\t\t\t\t\t\treturn $1 in values ? values[ $1 ] : $1;\n\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn stringLiteral;\n\t\t\t\t},\n\t\t\t\tfunction getObject( parser ) {\n\t\t\t\t\tvar result, pair;\n\t\t\t\t\tif ( !parser.matchString( '{' ) ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tresult = {};\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\tif ( parser.matchString( '}' ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tv: result\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\twhile ( pair = getKeyValuePair( parser ) ) {\n\t\t\t\t\t\tresult[ pair.key ] = pair.value;\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\tif ( parser.matchString( '}' ) ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tv: result\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t\tfunction getArray( parser ) {\n\t\t\t\t\tvar result, valueToken;\n\t\t\t\t\tif ( !parser.matchString( '[' ) ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tresult = [];\n\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\tif ( parser.matchString( ']' ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tv: result\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\twhile ( valueToken = parser.read() ) {\n\t\t\t\t\t\tresult.push( valueToken.v );\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t\tif ( parser.matchString( ']' ) ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tv: result\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.allowWhitespace();\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t]\n\t\t} );\n\n\t\tfunction getKeyValuePair( parser ) {\n\t\t\tvar key, valueToken, pair;\n\t\t\tparser.allowWhitespace();\n\t\t\tkey = getKey( parser );\n\t\t\tif ( !key ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tpair = {\n\t\t\t\tkey: key\n\t\t\t};\n\t\t\tparser.allowWhitespace();\n\t\t\tif ( !parser.matchString( ':' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tparser.allowWhitespace();\n\t\t\tvalueToken = parser.read();\n\t\t\tif ( !valueToken ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tpair.value = valueToken.v;\n\t\t\treturn pair;\n\t\t}\n\t\treturn function( str, values ) {\n\t\t\tvar parser = new JsonParser( str, {\n\t\t\t\tvalues: values\n\t\t\t} );\n\t\t\treturn parser.result;\n\t\t};\n\t}( Parser, stringLiteral, key );\n\n\t/* parse/converters/element/processDirective.js */\n\tvar processDirective = function( Parser, conditional, flattenExpression, parseJSON ) {\n\n\t\tvar methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\\(/,\n\t\t\tExpressionParser;\n\t\tExpressionParser = Parser.extend( {\n\t\t\tconverters: [ conditional ]\n\t\t} );\n\t\t// TODO clean this up, it's shocking\n\t\treturn function( tokens ) {\n\t\t\tvar result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;\n\t\t\tif ( typeof tokens === 'string' ) {\n\t\t\t\tif ( match = methodCallPattern.exec( tokens ) ) {\n\t\t\t\t\tresult = {\n\t\t\t\t\t\tm: match[ 1 ]\n\t\t\t\t\t};\n\t\t\t\t\targs = '[' + tokens.slice( result.m.length + 1, -1 ) + ']';\n\t\t\t\t\tparser = new ExpressionParser( args );\n\t\t\t\t\tresult.a = flattenExpression( parser.result[ 0 ] );\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tif ( tokens.indexOf( ':' ) === -1 ) {\n\t\t\t\t\treturn tokens.trim();\n\t\t\t\t}\n\t\t\t\ttokens = [ tokens ];\n\t\t\t}\n\t\t\tresult = {};\n\t\t\tdirectiveName = [];\n\t\t\tdirectiveArgs = [];\n\t\t\twhile ( tokens.length ) {\n\t\t\t\ttoken = tokens.shift();\n\t\t\t\tif ( typeof token === 'string' ) {\n\t\t\t\t\tcolonIndex = token.indexOf( ':' );\n\t\t\t\t\tif ( colonIndex === -1 ) {\n\t\t\t\t\t\tdirectiveName.push( token );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// is the colon the first character?\n\t\t\t\t\t\tif ( colonIndex ) {\n\t\t\t\t\t\t\t// no\n\t\t\t\t\t\t\tdirectiveName.push( token.substr( 0, colonIndex ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if there is anything after the colon in this token, treat\n\t\t\t\t\t\t// it as the first token of the directiveArgs fragment\n\t\t\t\t\t\tif ( token.length > colonIndex + 1 ) {\n\t\t\t\t\t\t\tdirectiveArgs[ 0 ] = token.substring( colonIndex + 1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdirectiveName.push( token );\n\t\t\t\t}\n\t\t\t}\n\t\t\tdirectiveArgs = directiveArgs.concat( tokens );\n\t\t\tif ( directiveArgs.length || typeof directiveName !== 'string' ) {\n\t\t\t\tresult = {\n\t\t\t\t\t// TODO is this really necessary? just use the array\n\t\t\t\t\tn: directiveName.length === 1 && typeof directiveName[ 0 ] === 'string' ? directiveName[ 0 ] : directiveName\n\t\t\t\t};\n\t\t\t\tif ( directiveArgs.length === 1 && typeof directiveArgs[ 0 ] === 'string' ) {\n\t\t\t\t\tparsed = parseJSON( '[' + directiveArgs[ 0 ] + ']' );\n\t\t\t\t\tresult.a = parsed ? parsed.value : directiveArgs[ 0 ].trim();\n\t\t\t\t} else {\n\t\t\t\t\tresult.d = directiveArgs;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = directiveName;\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t}( Parser, conditional, flattenExpression, parseJSON );\n\n\t/* parse/converters/element.js */\n\tvar element = function( types, voidElementNames, getMustache, getComment, getText, getClosingTag, getAttribute, processDirective ) {\n\n\t\tvar __export;\n\t\tvar tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/,\n\t\t\tvalidTagNameFollower = /^[\\s\\n\\/>]/,\n\t\t\tonPattern = /^on/,\n\t\t\tproxyEventPattern = /^on-([a-zA-Z\\\\*\\\\.$_][a-zA-Z\\\\*\\\\.$_0-9\\-]+)$/,\n\t\t\treservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,\n\t\t\tdirectives = {\n\t\t\t\t'intro-outro': 't0',\n\t\t\t\tintro: 't1',\n\t\t\t\toutro: 't2',\n\t\t\t\tdecorator: 'o'\n\t\t\t},\n\t\t\texclude = {\n\t\t\t\texclude: true\n\t\t\t},\n\t\t\tconverters, disallowedContents;\n\t\t// Different set of converters, because this time we're looking for closing tags\n\t\tconverters = [\n\t\t\tgetMustache,\n\t\t\tgetComment,\n\t\t\tgetElement,\n\t\t\tgetText,\n\t\t\tgetClosingTag\n\t\t];\n\t\t// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\n\t\tdisallowedContents = {\n\t\t\tli: [ 'li' ],\n\t\t\tdt: [\n\t\t\t\t'dt',\n\t\t\t\t'dd'\n\t\t\t],\n\t\t\tdd: [\n\t\t\t\t'dt',\n\t\t\t\t'dd'\n\t\t\t],\n\t\t\tp: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),\n\t\t\trt: [\n\t\t\t\t'rt',\n\t\t\t\t'rp'\n\t\t\t],\n\t\t\trp: [\n\t\t\t\t'rt',\n\t\t\t\t'rp'\n\t\t\t],\n\t\t\toptgroup: [ 'optgroup' ],\n\t\t\toption: [\n\t\t\t\t'option',\n\t\t\t\t'optgroup'\n\t\t\t],\n\t\t\tthead: [\n\t\t\t\t'tbody',\n\t\t\t\t'tfoot'\n\t\t\t],\n\t\t\ttbody: [\n\t\t\t\t'tbody',\n\t\t\t\t'tfoot'\n\t\t\t],\n\t\t\ttfoot: [ 'tbody' ],\n\t\t\ttr: [\n\t\t\t\t'tr',\n\t\t\t\t'tbody'\n\t\t\t],\n\t\t\ttd: [\n\t\t\t\t'td',\n\t\t\t\t'th',\n\t\t\t\t'tr'\n\t\t\t],\n\t\t\tth: [\n\t\t\t\t'td',\n\t\t\t\t'th',\n\t\t\t\t'tr'\n\t\t\t]\n\t\t};\n\t\t__export = getElement;\n\n\t\tfunction getElement( parser ) {\n\t\t\tvar start, element, lowerCaseName, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, child;\n\t\t\tstart = parser.pos;\n\t\t\tif ( parser.inside ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( !parser.matchString( '<' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// if this is a closing tag, abort straight away\n\t\t\tif ( parser.nextChar() === '/' ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telement = {\n\t\t\t\tt: types.ELEMENT\n\t\t\t};\n\t\t\tif ( parser.includeLinePositions ) {\n\t\t\t\telement.p = parser.getLinePos( start );\n\t\t\t}\n\t\t\tif ( parser.matchString( '!' ) ) {\n\t\t\t\telement.y = 1;\n\t\t\t}\n\t\t\t// element name\n\t\t\telement.e = parser.matchPattern( tagNamePattern );\n\t\t\tif ( !element.e ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// next character must be whitespace, closing solidus or '>'\n\t\t\tif ( !validTagNameFollower.test( parser.nextChar() ) ) {\n\t\t\t\tparser.error( 'Illegal tag name' );\n\t\t\t}\n\t\t\taddProxyEvent = function( name, directive ) {\n\t\t\t\tvar directiveName = directive.n || directive;\n\t\t\t\tif ( reservedEventNames.test( directiveName ) ) {\n\t\t\t\t\tparser.pos -= directiveName.length;\n\t\t\t\t\tparser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );\n\t\t\t\t}\n\t\t\t\telement.v[ name ] = directive;\n\t\t\t};\n\t\t\tparser.allowWhitespace();\n\t\t\t// directives and attributes\n\t\t\twhile ( attribute = getMustache( parser ) || getAttribute( parser ) ) {\n\t\t\t\t// regular attributes\n\t\t\t\tif ( attribute.name ) {\n\t\t\t\t\t// intro, outro, decorator\n\t\t\t\t\tif ( directiveName = directives[ attribute.name ] ) {\n\t\t\t\t\t\telement[ directiveName ] = processDirective( attribute.value );\n\t\t\t\t\t} else if ( match = proxyEventPattern.exec( attribute.name ) ) {\n\t\t\t\t\t\tif ( !element.v )\n\t\t\t\t\t\t\telement.v = {};\n\t\t\t\t\t\tdirective = processDirective( attribute.value );\n\t\t\t\t\t\taddProxyEvent( match[ 1 ], directive );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( !parser.sanitizeEventAttributes || !onPattern.test( attribute.name ) ) {\n\t\t\t\t\t\t\tif ( !element.a )\n\t\t\t\t\t\t\t\telement.a = {};\n\t\t\t\t\t\t\telement.a[ attribute.name ] = attribute.value || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( !element.m )\n\t\t\t\t\t\telement.m = [];\n\t\t\t\t\telement.m.push( attribute );\n\t\t\t\t}\n\t\t\t\tparser.allowWhitespace();\n\t\t\t}\n\t\t\t// allow whitespace before closing solidus\n\t\t\tparser.allowWhitespace();\n\t\t\t// self-closing solidus?\n\t\t\tif ( parser.matchString( '/' ) ) {\n\t\t\t\tselfClosing = true;\n\t\t\t}\n\t\t\t// closing angle bracket\n\t\t\tif ( !parser.matchString( '>' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tlowerCaseName = element.e.toLowerCase();\n\t\t\tif ( !selfClosing && !voidElementNames.test( element.e ) ) {\n\t\t\t\t// Special case - if we open a script element, further tags should\n\t\t\t\t// be ignored unless they're a closing script element\n\t\t\t\tif ( lowerCaseName === 'script' || lowerCaseName === 'style' ) {\n\t\t\t\t\tparser.inside = lowerCaseName;\n\t\t\t\t}\n\t\t\t\tchildren = [];\n\t\t\t\twhile ( canContain( lowerCaseName, parser.remaining() ) && ( child = parser.read( converters ) ) ) {\n\t\t\t\t\t// Special case - closing section tag\n\t\t\t\t\tif ( child.t === types.CLOSING ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ( child.t === types.CLOSING_TAG ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchildren.push( child );\n\t\t\t\t}\n\t\t\t\tif ( children.length ) {\n\t\t\t\t\telement.f = children;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparser.inside = null;\n\t\t\tif ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {\n\t\t\t\treturn exclude;\n\t\t\t}\n\t\t\treturn element;\n\t\t}\n\n\t\tfunction canContain( name, remaining ) {\n\t\t\tvar match, disallowed;\n\t\t\tmatch = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );\n\t\t\tdisallowed = disallowedContents[ name ];\n\t\t\tif ( !match || !disallowed ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn !~disallowed.indexOf( match[ 1 ].toLowerCase() );\n\t\t}\n\t\treturn __export;\n\t}( types, voidElementNames, mustache, comment, text, closingTag, attribute, processDirective );\n\n\t/* parse/utils/trimWhitespace.js */\n\tvar trimWhitespace = function() {\n\n\t\tvar leadingWhitespace = /^[ \\t\\f\\r\\n]+/,\n\t\t\ttrailingWhitespace = /[ \\t\\f\\r\\n]+$/;\n\t\treturn function( items, leading, trailing ) {\n\t\t\tvar item;\n\t\t\tif ( leading ) {\n\t\t\t\titem = items[ 0 ];\n\t\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\t\titem = item.replace( leadingWhitespace, '' );\n\t\t\t\t\tif ( !item ) {\n\t\t\t\t\t\titems.shift();\n\t\t\t\t\t} else {\n\t\t\t\t\t\titems[ 0 ] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( trailing ) {\n\t\t\t\titem = items[ items.length - 1 ];\n\t\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\t\titem = item.replace( trailingWhitespace, '' );\n\t\t\t\t\tif ( !item ) {\n\t\t\t\t\t\titems.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\titems[ items.length - 1 ] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}();\n\n\t/* parse/utils/stripStandalones.js */\n\tvar stripStandalones = function( types ) {\n\n\t\tvar __export;\n\t\tvar leadingLinebreak = /^\\s*\\r?\\n/,\n\t\t\ttrailingLinebreak = /\\r?\\n\\s*$/;\n\t\t__export = function( items ) {\n\t\t\tvar i, current, backOne, backTwo, lastSectionItem;\n\t\t\tfor ( i = 1; i < items.length; i += 1 ) {\n\t\t\t\tcurrent = items[ i ];\n\t\t\t\tbackOne = items[ i - 1 ];\n\t\t\t\tbackTwo = items[ i - 2 ];\n\t\t\t\t// if we're at the end of a [text][comment][text] sequence...\n\t\t\t\tif ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {\n\t\t\t\t\t// ... and the comment is a standalone (i.e. line breaks either side)...\n\t\t\t\t\tif ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {\n\t\t\t\t\t\t// ... then we want to remove the whitespace after the first line break\n\t\t\t\t\t\titems[ i - 2 ] = backTwo.replace( trailingLinebreak, '\\n' );\n\t\t\t\t\t\t// and the leading line break of the second text token\n\t\t\t\t\t\titems[ i ] = current.replace( leadingLinebreak, '' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if the current item is a section, and it is preceded by a linebreak, and\n\t\t\t\t// its first item is a linebreak...\n\t\t\t\tif ( isSection( current ) && isString( backOne ) ) {\n\t\t\t\t\tif ( trailingLinebreak.test( backOne ) && isString( current.f[ 0 ] ) && leadingLinebreak.test( current.f[ 0 ] ) ) {\n\t\t\t\t\t\titems[ i - 1 ] = backOne.replace( trailingLinebreak, '\\n' );\n\t\t\t\t\t\tcurrent.f[ 0 ] = current.f[ 0 ].replace( leadingLinebreak, '' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if the last item was a section, and it is followed by a linebreak, and\n\t\t\t\t// its last item is a linebreak...\n\t\t\t\tif ( isString( current ) && isSection( backOne ) ) {\n\t\t\t\t\tlastSectionItem = backOne.f[ backOne.f.length - 1 ];\n\t\t\t\t\tif ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {\n\t\t\t\t\t\tbackOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\\n' );\n\t\t\t\t\t\titems[ i ] = current.replace( leadingLinebreak, '' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn items;\n\t\t};\n\n\t\tfunction isString( item ) {\n\t\t\treturn typeof item === 'string';\n\t\t}\n\n\t\tfunction isComment( item ) {\n\t\t\treturn item.t === types.COMMENT || item.t === types.DELIMCHANGE;\n\t\t}\n\n\t\tfunction isSection( item ) {\n\t\t\treturn ( item.t === types.SECTION || item.t === types.INVERTED ) && item.f;\n\t\t}\n\t\treturn __export;\n\t}( types );\n\n\t/* utils/escapeRegExp.js */\n\tvar escapeRegExp = function() {\n\n\t\tvar pattern = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\t\treturn function escapeRegExp( str ) {\n\t\t\treturn str.replace( pattern, '\\\\$&' );\n\t\t};\n\t}();\n\n\t/* parse/_parse.js */\n\tvar parse = function( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp ) {\n\n\t\tvar __export;\n\t\tvar StandardParser, parse, contiguousWhitespace = /[ \\t\\f\\r\\n]+/g,\n\t\t\tpreserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i,\n\t\t\tleadingWhitespace = /^\\s+/,\n\t\t\ttrailingWhitespace = /\\s+$/;\n\t\tStandardParser = Parser.extend( {\n\t\t\tinit: function( str, options ) {\n\t\t\t\t// config\n\t\t\t\tsetDelimiters( options, this );\n\t\t\t\tthis.sectionDepth = 0;\n\t\t\t\tthis.interpolate = {\n\t\t\t\t\tscript: !options.interpolate || options.interpolate.script !== false,\n\t\t\t\t\tstyle: !options.interpolate || options.interpolate.style !== false\n\t\t\t\t};\n\t\t\t\tif ( options.sanitize === true ) {\n\t\t\t\t\toptions.sanitize = {\n\t\t\t\t\t\t// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n\t\t\t\t\t\telements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),\n\t\t\t\t\t\teventAttributes: true\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthis.sanitizeElements = options.sanitize && options.sanitize.elements;\n\t\t\t\tthis.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n\t\t\t\tthis.includeLinePositions = options.includeLinePositions;\n\t\t\t},\n\t\t\tpostProcess: function( items, options ) {\n\t\t\t\tif ( this.sectionDepth > 0 ) {\n\t\t\t\t\tthis.error( 'A section was left open' );\n\t\t\t\t}\n\t\t\t\tcleanup( items, options.stripComments !== false, options.preserveWhitespace, !options.preserveWhitespace, !options.preserveWhitespace, options.rewriteElse !== false );\n\t\t\t\treturn items;\n\t\t\t},\n\t\t\tconverters: [\n\t\t\t\tmustache,\n\t\t\t\tcomment,\n\t\t\t\telement,\n\t\t\t\ttext\n\t\t\t]\n\t\t} );\n\t\tparse = function( template ) {\n\t\t\tvar options = arguments[ 1 ];\n\t\t\tif ( options === void 0 )\n\t\t\t\toptions = {};\n\t\t\tvar result, remaining, partials, name, startMatch, endMatch, inlinePartialStart, inlinePartialEnd;\n\t\t\tsetDelimiters( options );\n\t\t\tinlinePartialStart = new RegExp( '<!--\\\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\\\s*>\\\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\\\s*-->' );\n\t\t\tinlinePartialEnd = new RegExp( '<!--\\\\s*' + escapeRegExp( options.delimiters[ 0 ] ) + '\\\\s*\\\\/\\\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\\\s*' + escapeRegExp( options.delimiters[ 1 ] ) + '\\\\s*-->' );\n\t\t\tresult = {\n\t\t\t\tv: 1\n\t\t\t};\n\t\t\tif ( inlinePartialStart.test( template ) ) {\n\t\t\t\tremaining = template;\n\t\t\t\ttemplate = '';\n\t\t\t\twhile ( startMatch = inlinePartialStart.exec( remaining ) ) {\n\t\t\t\t\tname = startMatch[ 1 ];\n\t\t\t\t\ttemplate += remaining.substr( 0, startMatch.index );\n\t\t\t\t\tremaining = remaining.substring( startMatch.index + startMatch[ 0 ].length );\n\t\t\t\t\tendMatch = inlinePartialEnd.exec( remaining );\n\t\t\t\t\tif ( !endMatch || endMatch[ 1 ] !== name ) {\n\t\t\t\t\t\tthrow new Error( 'Inline partials must have a closing delimiter, and cannot be nested. Expected closing for \"' + name + '\", but ' + ( endMatch ? 'instead found \"' + endMatch[ 1 ] + '\"' : ' no closing found' ) );\n\t\t\t\t\t}\n\t\t\t\t\t( partials || ( partials = {} ) )[ name ] = new StandardParser( remaining.substr( 0, endMatch.index ), options ).result;\n\t\t\t\t\tremaining = remaining.substring( endMatch.index + endMatch[ 0 ].length );\n\t\t\t\t}\n\t\t\t\ttemplate += remaining;\n\t\t\t\tresult.p = partials;\n\t\t\t}\n\t\t\tresult.t = new StandardParser( template, options ).result;\n\t\t\treturn result;\n\t\t};\n\t\t__export = parse;\n\n\t\tfunction cleanup( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace, rewriteElse ) {\n\t\t\tvar i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, unlessBlock, key;\n\t\t\t// First pass - remove standalones and comments etc\n\t\t\tstripStandalones( items );\n\t\t\ti = items.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\titem = items[ i ];\n\t\t\t\t// Remove delimiter changes, unsafe elements etc\n\t\t\t\tif ( item.exclude ) {\n\t\t\t\t\titems.splice( i, 1 );\n\t\t\t\t} else if ( stripComments && item.t === types.COMMENT ) {\n\t\t\t\t\titems.splice( i, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If necessary, remove leading and trailing whitespace\n\t\t\ttrimWhitespace( items, removeLeadingWhitespace, removeTrailingWhitespace );\n\t\t\ti = items.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\titem = items[ i ];\n\t\t\t\t// Recurse\n\t\t\t\tif ( item.f ) {\n\t\t\t\t\tpreserveWhitespaceInsideFragment = preserveWhitespace || item.t === types.ELEMENT && preserveWhitespaceElements.test( item.e );\n\t\t\t\t\tif ( !preserveWhitespaceInsideFragment ) {\n\t\t\t\t\t\tpreviousItem = items[ i - 1 ];\n\t\t\t\t\t\tnextItem = items[ i + 1 ];\n\t\t\t\t\t\t// if the previous item was a text item with trailing whitespace,\n\t\t\t\t\t\t// remove leading whitespace inside the fragment\n\t\t\t\t\t\tif ( !previousItem || typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) {\n\t\t\t\t\t\t\tremoveLeadingWhitespaceInsideFragment = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// and vice versa\n\t\t\t\t\t\tif ( !nextItem || typeof nextItem === 'string' && leadingWhitespace.test( nextItem ) ) {\n\t\t\t\t\t\t\tremoveTrailingWhitespaceInsideFragment = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );\n\t\t\t\t}\n\t\t\t\t// Split if-else blocks into two (an if, and an unless)\n\t\t\t\tif ( item.l ) {\n\t\t\t\t\tcleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );\n\t\t\t\t\tif ( rewriteElse ) {\n\t\t\t\t\t\tunlessBlock = {\n\t\t\t\t\t\t\tt: 4,\n\t\t\t\t\t\t\tn: types.SECTION_UNLESS,\n\t\t\t\t\t\t\tf: item.l\n\t\t\t\t\t\t};\n\t\t\t\t\t\t// copy the conditional based on its type\n\t\t\t\t\t\tif ( item.r ) {\n\t\t\t\t\t\t\tunlessBlock.r = item.r;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( item.x ) {\n\t\t\t\t\t\t\tunlessBlock.x = item.x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( item.rx ) {\n\t\t\t\t\t\t\tunlessBlock.rx = item.rx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\titems.splice( i + 1, 0, unlessBlock );\n\t\t\t\t\t\tdelete item.l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Clean up element attributes\n\t\t\t\tif ( item.a ) {\n\t\t\t\t\tfor ( key in item.a ) {\n\t\t\t\t\t\tif ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {\n\t\t\t\t\t\t\tcleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// final pass - fuse text nodes together\n\t\t\ti = items.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( typeof items[ i ] === 'string' ) {\n\t\t\t\t\tif ( typeof items[ i + 1 ] === 'string' ) {\n\t\t\t\t\t\titems[ i ] = items[ i ] + items[ i + 1 ];\n\t\t\t\t\t\titems.splice( i + 1, 1 );\n\t\t\t\t\t}\n\t\t\t\t\tif ( !preserveWhitespace ) {\n\t\t\t\t\t\titems[ i ] = items[ i ].replace( contiguousWhitespace, ' ' );\n\t\t\t\t\t}\n\t\t\t\t\tif ( items[ i ] === '' ) {\n\t\t\t\t\t\titems.splice( i, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction setDelimiters( source ) {\n\t\t\tvar target = arguments[ 1 ];\n\t\t\tif ( target === void 0 )\n\t\t\t\ttarget = source;\n\t\t\ttarget.delimiters = source.delimiters || [\n\t\t\t\t'{{',\n\t\t\t\t'}}'\n\t\t\t];\n\t\t\ttarget.tripleDelimiters = source.tripleDelimiters || [\n\t\t\t\t'{{{',\n\t\t\t\t'}}}'\n\t\t\t];\n\t\t\ttarget.staticDelimiters = source.staticDelimiters || [\n\t\t\t\t'[[',\n\t\t\t\t']]'\n\t\t\t];\n\t\t\ttarget.staticTripleDelimiters = source.staticTripleDelimiters || [\n\t\t\t\t'[[[',\n\t\t\t\t']]]'\n\t\t\t];\n\t\t}\n\t\treturn __export;\n\t}( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones, escapeRegExp );\n\n\t/* config/options/groups/optionGroup.js */\n\tvar optionGroup = function() {\n\n\t\treturn function createOptionGroup( keys, config ) {\n\t\t\tvar group = keys.map( config );\n\t\t\tkeys.forEach( function( key, i ) {\n\t\t\t\tgroup[ key ] = group[ i ];\n\t\t\t} );\n\t\t\treturn group;\n\t\t};\n\t}( legacy );\n\n\t/* config/options/groups/parseOptions.js */\n\tvar parseOptions = function( optionGroup ) {\n\n\t\tvar keys, parseOptions;\n\t\tkeys = [\n\t\t\t'preserveWhitespace',\n\t\t\t'sanitize',\n\t\t\t'stripComments',\n\t\t\t'delimiters',\n\t\t\t'tripleDelimiters',\n\t\t\t'interpolate'\n\t\t];\n\t\tparseOptions = optionGroup( keys, function( key ) {\n\t\t\treturn key;\n\t\t} );\n\t\treturn parseOptions;\n\t}( optionGroup );\n\n\t/* config/options/template/parser.js */\n\tvar parser = function( errors, isClient, parse, create, parseOptions ) {\n\n\t\tvar parser = {\n\t\t\tparse: doParse,\n\t\t\tfromId: fromId,\n\t\t\tisHashedId: isHashedId,\n\t\t\tisParsed: isParsed,\n\t\t\tgetParseOptions: getParseOptions,\n\t\t\tcreateHelper: createHelper\n\t\t};\n\n\t\tfunction createHelper( parseOptions ) {\n\t\t\tvar helper = create( parser );\n\t\t\thelper.parse = function( template, options ) {\n\t\t\t\treturn doParse( template, options || parseOptions );\n\t\t\t};\n\t\t\treturn helper;\n\t\t}\n\n\t\tfunction doParse( template, parseOptions ) {\n\t\t\tif ( !parse ) {\n\t\t\t\tthrow new Error( errors.missingParser );\n\t\t\t}\n\t\t\treturn parse( template, parseOptions || this.options );\n\t\t}\n\n\t\tfunction fromId( id, options ) {\n\t\t\tvar template;\n\t\t\tif ( !isClient ) {\n\t\t\t\tif ( options && options.noThrow ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new Error( 'Cannot retrieve template #' + id + ' as Ractive is not running in a browser.' );\n\t\t\t}\n\t\t\tif ( isHashedId( id ) ) {\n\t\t\t\tid = id.substring( 1 );\n\t\t\t}\n\t\t\tif ( !( template = document.getElementById( id ) ) ) {\n\t\t\t\tif ( options && options.noThrow ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new Error( 'Could not find template element with id #' + id );\n\t\t\t}\n\t\t\tif ( template.tagName.toUpperCase() !== 'SCRIPT' ) {\n\t\t\t\tif ( options && options.noThrow ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new Error( 'Template element with id #' + id + ', must be a <script> element' );\n\t\t\t}\n\t\t\treturn template.innerHTML;\n\t\t}\n\n\t\tfunction isHashedId( id ) {\n\t\t\treturn id.charAt( 0 ) === '#';\n\t\t}\n\n\t\tfunction isParsed( template ) {\n\t\t\treturn !( typeof template === 'string' );\n\t\t}\n\n\t\tfunction getParseOptions( ractive ) {\n\t\t\t// Could be Ractive or a Component\n\t\t\tif ( ractive.defaults ) {\n\t\t\t\tractive = ractive.defaults;\n\t\t\t}\n\t\t\treturn parseOptions.reduce( function( val, key ) {\n\t\t\t\tval[ key ] = ractive[ key ];\n\t\t\t\treturn val;\n\t\t\t}, {} );\n\t\t}\n\t\treturn parser;\n\t}( errors, isClient, parse, create, parseOptions );\n\n\t/* config/options/template/template.js */\n\tvar template = function( parser, parse ) {\n\n\t\tvar templateConfig = {\n\t\t\tname: 'template',\n\t\t\textend: function extend( Parent, proto, options ) {\n\t\t\t\tvar template;\n\t\t\t\t// only assign if exists\n\t\t\t\tif ( 'template' in options ) {\n\t\t\t\t\ttemplate = options.template;\n\t\t\t\t\tif ( typeof template === 'function' ) {\n\t\t\t\t\t\tproto.template = template;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tproto.template = parseIfString( template, proto );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tinit: function init( Parent, ractive, options ) {\n\t\t\t\tvar template, fn;\n\t\t\t\t// TODO because of prototypal inheritance, we might just be able to use\n\t\t\t\t// ractive.template, and not bother passing through the Parent object.\n\t\t\t\t// At present that breaks the test mocks' expectations\n\t\t\t\ttemplate = 'template' in options ? options.template : Parent.prototype.template;\n\t\t\t\tif ( typeof template === 'function' ) {\n\t\t\t\t\tfn = template;\n\t\t\t\t\ttemplate = getDynamicTemplate( ractive, fn );\n\t\t\t\t\tractive._config.template = {\n\t\t\t\t\t\tfn: fn,\n\t\t\t\t\t\tresult: template\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\ttemplate = parseIfString( template, ractive );\n\t\t\t\t// TODO the naming of this is confusing - ractive.template refers to [...],\n\t\t\t\t// but Component.prototype.template refers to {v:1,t:[],p:[]}...\n\t\t\t\t// it's unnecessary, because the developer never needs to access\n\t\t\t\t// ractive.template\n\t\t\t\tractive.template = template.t;\n\t\t\t\tif ( template.p ) {\n\t\t\t\t\textendPartials( ractive.partials, template.p );\n\t\t\t\t}\n\t\t\t},\n\t\t\treset: function( ractive ) {\n\t\t\t\tvar result = resetValue( ractive ),\n\t\t\t\t\tparsed;\n\t\t\t\tif ( result ) {\n\t\t\t\t\tparsed = parseIfString( result, ractive );\n\t\t\t\t\tractive.template = parsed.t;\n\t\t\t\t\textendPartials( ractive.partials, parsed.p, true );\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfunction resetValue( ractive ) {\n\t\t\tvar initial = ractive._config.template,\n\t\t\t\tresult;\n\t\t\t// If this isn't a dynamic template, there's nothing to do\n\t\t\tif ( !initial || !initial.fn ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = getDynamicTemplate( ractive, initial.fn );\n\t\t\t// TODO deep equality check to prevent unnecessary re-rendering\n\t\t\t// in the case of already-parsed templates\n\t\t\tif ( result !== initial.result ) {\n\t\t\t\tinitial.result = result;\n\t\t\t\tresult = parseIfString( result, ractive );\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tfunction getDynamicTemplate( ractive, fn ) {\n\t\t\tvar helper = parser.createHelper( parser.getParseOptions( ractive ) );\n\t\t\treturn fn.call( ractive, ractive.data, helper );\n\t\t}\n\n\t\tfunction parseIfString( template, ractive ) {\n\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\t// ID of an element containing the template?\n\t\t\t\tif ( template[ 0 ] === '#' ) {\n\t\t\t\t\ttemplate = parser.fromId( template );\n\t\t\t\t}\n\t\t\t\ttemplate = parse( template, parser.getParseOptions( ractive ) );\n\t\t\t} else if ( template.v !== 1 ) {\n\t\t\t\tthrow new Error( 'Mismatched template version! Please ensure you are using the latest version of Ractive.js in your build process as well as in your app' );\n\t\t\t}\n\t\t\treturn template;\n\t\t}\n\n\t\tfunction extendPartials( existingPartials, newPartials, overwrite ) {\n\t\t\tif ( !newPartials )\n\t\t\t\treturn;\n\t\t\t// TODO there's an ambiguity here - we need to overwrite in the `reset()`\n\t\t\t// case, but not initially...\n\t\t\tfor ( var key in newPartials ) {\n\t\t\t\tif ( overwrite || !existingPartials.hasOwnProperty( key ) ) {\n\t\t\t\t\texistingPartials[ key ] = newPartials[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn templateConfig;\n\t}( parser, parse );\n\n\t/* config/options/Registry.js */\n\tvar Registry = function( create ) {\n\n\t\tfunction Registry( name, useDefaults ) {\n\t\t\tthis.name = name;\n\t\t\tthis.useDefaults = useDefaults;\n\t\t}\n\t\tRegistry.prototype = {\n\t\t\tconstructor: Registry,\n\t\t\textend: function( Parent, proto, options ) {\n\t\t\t\tthis.configure( this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options );\n\t\t\t},\n\t\t\tinit: function( Parent, ractive, options ) {\n\t\t\t\tthis.configure( this.useDefaults ? Parent.defaults : Parent, ractive, options );\n\t\t\t},\n\t\t\tconfigure: function( Parent, target, options ) {\n\t\t\t\tvar name = this.name,\n\t\t\t\t\toption = options[ name ],\n\t\t\t\t\tregistry;\n\t\t\t\tregistry = create( Parent[ name ] );\n\t\t\t\tfor ( var key in option ) {\n\t\t\t\t\tregistry[ key ] = option[ key ];\n\t\t\t\t}\n\t\t\t\ttarget[ name ] = registry;\n\t\t\t},\n\t\t\treset: function( ractive ) {\n\t\t\t\tvar registry = ractive[ this.name ];\n\t\t\t\tvar changed = false;\n\t\t\t\tObject.keys( registry ).forEach( function( key ) {\n\t\t\t\t\tvar item = registry[ key ];\n\t\t\t\t\tif ( item._fn ) {\n\t\t\t\t\t\tif ( item._fn.isOwner ) {\n\t\t\t\t\t\t\tregistry[ key ] = item._fn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdelete registry[ key ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn changed;\n\t\t\t},\n\t\t\tfindOwner: function( ractive, key ) {\n\t\t\t\treturn ractive[ this.name ].hasOwnProperty( key ) ? ractive : this.findConstructor( ractive.constructor, key );\n\t\t\t},\n\t\t\tfindConstructor: function( constructor, key ) {\n\t\t\t\tif ( !constructor ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn constructor[ this.name ].hasOwnProperty( key ) ? constructor : this.findConstructor( constructor._parent, key );\n\t\t\t},\n\t\t\tfind: function( ractive, key ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\treturn recurseFind( ractive, function( r ) {\n\t\t\t\t\treturn r[ this$0.name ][ key ];\n\t\t\t\t} );\n\t\t\t},\n\t\t\tfindInstance: function( ractive, key ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\treturn recurseFind( ractive, function( r ) {\n\t\t\t\t\treturn r[ this$0.name ][ key ] ? r : void 0;\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\n\t\tfunction recurseFind( ractive, fn ) {\n\t\t\tvar find, parent;\n\t\t\tif ( find = fn( ractive ) ) {\n\t\t\t\treturn find;\n\t\t\t}\n\t\t\tif ( !ractive.isolated && ( parent = ractive._parent ) ) {\n\t\t\t\treturn recurseFind( parent, fn );\n\t\t\t}\n\t\t}\n\t\treturn Registry;\n\t}( create, legacy );\n\n\t/* config/options/groups/registries.js */\n\tvar registries = function( optionGroup, Registry ) {\n\n\t\tvar keys = [\n\t\t\t\t'adaptors',\n\t\t\t\t'components',\n\t\t\t\t'computed',\n\t\t\t\t'decorators',\n\t\t\t\t'easing',\n\t\t\t\t'events',\n\t\t\t\t'interpolators',\n\t\t\t\t'partials',\n\t\t\t\t'transitions'\n\t\t\t],\n\t\t\tregistries = optionGroup( keys, function( key ) {\n\t\t\t\treturn new Registry( key, key === 'computed' );\n\t\t\t} );\n\t\treturn registries;\n\t}( optionGroup, Registry );\n\n\t/* utils/noop.js */\n\tvar noop = function() {};\n\n\t/* utils/wrapPrototypeMethod.js */\n\tvar wrapPrototypeMethod = function( noop ) {\n\n\t\tvar __export;\n\t\t__export = function wrap( parent, name, method ) {\n\t\t\tif ( !/_super/.test( method ) ) {\n\t\t\t\treturn method;\n\t\t\t}\n\t\t\tvar wrapper = function wrapSuper() {\n\t\t\t\tvar superMethod = getSuperMethod( wrapper._parent, name ),\n\t\t\t\t\thasSuper = '_super' in this,\n\t\t\t\t\toldSuper = this._super,\n\t\t\t\t\tresult;\n\t\t\t\tthis._super = superMethod;\n\t\t\t\tresult = method.apply( this, arguments );\n\t\t\t\tif ( hasSuper ) {\n\t\t\t\t\tthis._super = oldSuper;\n\t\t\t\t} else {\n\t\t\t\t\tdelete this._super;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t};\n\t\t\twrapper._parent = parent;\n\t\t\twrapper._method = method;\n\t\t\treturn wrapper;\n\t\t};\n\n\t\tfunction getSuperMethod( parent, name ) {\n\t\t\tvar method;\n\t\t\tif ( name in parent ) {\n\t\t\t\tvar value = parent[ name ];\n\t\t\t\tif ( typeof value === 'function' ) {\n\t\t\t\t\tmethod = value;\n\t\t\t\t} else {\n\t\t\t\t\tmethod = function returnValue() {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmethod = noop;\n\t\t\t}\n\t\t\treturn method;\n\t\t}\n\t\treturn __export;\n\t}( noop );\n\n\t/* config/deprecate.js */\n\tvar deprecate = function( warn, isArray ) {\n\n\t\tfunction deprecate( options, deprecated, correct ) {\n\t\t\tif ( deprecated in options ) {\n\t\t\t\tif ( !( correct in options ) ) {\n\t\t\t\t\twarn( getMessage( deprecated, correct ) );\n\t\t\t\t\toptions[ correct ] = options[ deprecated ];\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error( getMessage( deprecated, correct, true ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction getMessage( deprecated, correct, isError ) {\n\t\t\treturn 'options.' + deprecated + ' has been deprecated in favour of options.' + correct + '.' + ( isError ? ' You cannot specify both options, please use options.' + correct + '.' : '' );\n\t\t}\n\n\t\tfunction deprecateEventDefinitions( options ) {\n\t\t\tdeprecate( options, 'eventDefinitions', 'events' );\n\t\t}\n\n\t\tfunction deprecateAdaptors( options ) {\n\t\t\t// Using extend with Component instead of options,\n\t\t\t// like Human.extend( Spider ) means adaptors as a registry\n\t\t\t// gets copied to options. So we have to check if actually an array\n\t\t\tif ( isArray( options.adaptors ) ) {\n\t\t\t\tdeprecate( options, 'adaptors', 'adapt' );\n\t\t\t}\n\t\t}\n\t\treturn function deprecateOptions( options ) {\n\t\t\tdeprecateEventDefinitions( options );\n\t\t\tdeprecateAdaptors( options );\n\t\t};\n\t}( warn, isArray );\n\n\t/* config/config.js */\n\tvar config = function( css, data, defaults, template, parseOptions, registries, wrapPrototype, deprecate ) {\n\n\t\tvar custom, options, config, blacklisted;\n\t\t// would be nice to not have these here,\n\t\t// they get added during initialise, so for now we have\n\t\t// to make sure not to try and extend them.\n\t\t// Possibly, we could re-order and not add till later\n\t\t// in process.\n\t\tblacklisted = {\n\t\t\t'_parent': true,\n\t\t\t'_component': true\n\t\t};\n\t\tcustom = {\n\t\t\tdata: data,\n\t\t\ttemplate: template,\n\t\t\tcss: css\n\t\t};\n\t\toptions = Object.keys( defaults ).filter( function( key ) {\n\t\t\treturn !registries[ key ] && !custom[ key ] && !parseOptions[ key ];\n\t\t} );\n\t\t// this defines the order:\n\t\tconfig = [].concat( custom.data, parseOptions, options, registries, custom.template, custom.css );\n\t\tfor ( var key in custom ) {\n\t\t\tconfig[ key ] = custom[ key ];\n\t\t}\n\t\t// for iteration\n\t\tconfig.keys = Object.keys( defaults ).concat( registries.map( function( r ) {\n\t\t\treturn r.name;\n\t\t} ) ).concat( [ 'css' ] );\n\t\t// add these to blacklisted key's that we don't double extend\n\t\tconfig.keys.forEach( function( key ) {\n\t\t\treturn blacklisted[ key ] = true;\n\t\t} );\n\t\tconfig.parseOptions = parseOptions;\n\t\tconfig.registries = registries;\n\n\t\tfunction customConfig( method, key, Parent, instance, options ) {\n\t\t\tcustom[ key ][ method ]( Parent, instance, options );\n\t\t}\n\t\tconfig.extend = function( Parent, proto, options ) {\n\t\t\tconfigure( 'extend', Parent, proto, options );\n\t\t};\n\t\tconfig.init = function( Parent, ractive, options ) {\n\t\t\tconfigure( 'init', Parent, ractive, options );\n\t\t};\n\n\t\tfunction isStandardDefaultKey( key ) {\n\t\t\treturn key in defaults && !( key in config.parseOptions ) && !( key in custom );\n\t\t}\n\n\t\tfunction configure( method, Parent, instance, options ) {\n\t\t\tdeprecate( options );\n\t\t\tcustomConfig( method, 'data', Parent, instance, options );\n\t\t\tconfig.parseOptions.forEach( function( key ) {\n\t\t\t\tif ( key in options ) {\n\t\t\t\t\tinstance[ key ] = options[ key ];\n\t\t\t\t}\n\t\t\t} );\n\t\t\tfor ( var key in options ) {\n\t\t\t\tif ( isStandardDefaultKey( key ) ) {\n\t\t\t\t\tvar value = options[ key ];\n\t\t\t\t\tinstance[ key ] = typeof value === 'function' ? wrapPrototype( Parent.prototype, key, value ) : value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconfig.registries.forEach( function( registry ) {\n\t\t\t\tregistry[ method ]( Parent, instance, options );\n\t\t\t} );\n\t\t\tcustomConfig( method, 'template', Parent, instance, options );\n\t\t\tcustomConfig( method, 'css', Parent, instance, options );\n\t\t\textendOtherMethods( Parent.prototype, instance, options );\n\t\t}\n\n\t\tfunction extendOtherMethods( parent, instance, options ) {\n\t\t\tfor ( var key in options ) {\n\t\t\t\tif ( !( key in blacklisted ) && options.hasOwnProperty( key ) ) {\n\t\t\t\t\tvar member = options[ key ];\n\t\t\t\t\t// if this is a method that overwrites a method, wrap it:\n\t\t\t\t\tif ( typeof member === 'function' ) {\n\t\t\t\t\t\tmember = wrapPrototype( parent, key, member );\n\t\t\t\t\t}\n\t\t\t\t\tinstance[ key ] = member;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconfig.reset = function( ractive ) {\n\t\t\treturn config.filter( function( c ) {\n\t\t\t\treturn c.reset && c.reset( ractive );\n\t\t\t} ).map( function( c ) {\n\t\t\t\treturn c.name;\n\t\t\t} );\n\t\t};\n\t\tconfig.getConstructTarget = function( ractive, options ) {\n\t\t\tif ( options.onconstruct ) {\n\t\t\t\t// pretend this object literal is the ractive instance\n\t\t\t\treturn {\n\t\t\t\t\tonconstruct: wrapPrototype( ractive, 'onconstruct', options.onconstruct ).bind( ractive ),\n\t\t\t\t\tfire: ractive.fire.bind( ractive )\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn ractive;\n\t\t\t}\n\t\t};\n\t\treturn config;\n\t}( css, data, options, template, parseOptions, registries, wrapPrototypeMethod, deprecate );\n\n\t/* shared/interpolate.js */\n\tvar interpolate = function( circular, warn, interpolators, config ) {\n\n\t\tvar __export;\n\t\tvar interpolate = function( from, to, ractive, type ) {\n\t\t\tif ( from === to ) {\n\t\t\t\treturn snap( to );\n\t\t\t}\n\t\t\tif ( type ) {\n\t\t\t\tvar interpol = config.registries.interpolators.find( ractive, type );\n\t\t\t\tif ( interpol ) {\n\t\t\t\t\treturn interpol( from, to ) || snap( to );\n\t\t\t\t}\n\t\t\t\twarn( 'Missing \"' + type + '\" interpolator. You may need to download a plugin from [TODO]' );\n\t\t\t}\n\t\t\treturn interpolators.number( from, to ) || interpolators.array( from, to ) || interpolators.object( from, to ) || snap( to );\n\t\t};\n\t\tcircular.interpolate = interpolate;\n\t\t__export = interpolate;\n\n\t\tfunction snap( to ) {\n\t\t\treturn function() {\n\t\t\t\treturn to;\n\t\t\t};\n\t\t}\n\t\treturn __export;\n\t}( circular, warn, interpolators, config );\n\n\t/* Ractive/prototype/animate/Animation.js */\n\tvar Ractive$animate_Animation = function( warn, runloop, interpolate ) {\n\n\t\tvar Animation = function( options ) {\n\t\t\tvar key;\n\t\t\tthis.startTime = Date.now();\n\t\t\t// from and to\n\t\t\tfor ( key in options ) {\n\t\t\t\tif ( options.hasOwnProperty( key ) ) {\n\t\t\t\t\tthis[ key ] = options[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.interpolator = interpolate( this.from, this.to, this.root, this.interpolator );\n\t\t\tthis.running = true;\n\t\t\tthis.tick();\n\t\t};\n\t\tAnimation.prototype = {\n\t\t\ttick: function() {\n\t\t\t\tvar elapsed, t, value, timeNow, index, keypath;\n\t\t\t\tkeypath = this.keypath;\n\t\t\t\tif ( this.running ) {\n\t\t\t\t\ttimeNow = Date.now();\n\t\t\t\t\telapsed = timeNow - this.startTime;\n\t\t\t\t\tif ( elapsed >= this.duration ) {\n\t\t\t\t\t\tif ( keypath !== null ) {\n\t\t\t\t\t\t\trunloop.start( this.root );\n\t\t\t\t\t\t\tthis.root.viewmodel.set( keypath, this.to );\n\t\t\t\t\t\t\trunloop.end();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( this.step ) {\n\t\t\t\t\t\t\tthis.step( 1, this.to );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.complete( this.to );\n\t\t\t\t\t\tindex = this.root._animations.indexOf( this );\n\t\t\t\t\t\t// TODO investigate why this happens\n\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\twarn( 'Animation was not found' );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.root._animations.splice( index, 1 );\n\t\t\t\t\t\tthis.running = false;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tt = this.easing ? this.easing( elapsed / this.duration ) : elapsed / this.duration;\n\t\t\t\t\tif ( keypath !== null ) {\n\t\t\t\t\t\tvalue = this.interpolator( t );\n\t\t\t\t\t\trunloop.start( this.root );\n\t\t\t\t\t\tthis.root.viewmodel.set( keypath, value );\n\t\t\t\t\t\trunloop.end();\n\t\t\t\t\t}\n\t\t\t\t\tif ( this.step ) {\n\t\t\t\t\t\tthis.step( t, value );\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tstop: function() {\n\t\t\t\tvar index;\n\t\t\t\tthis.running = false;\n\t\t\t\tindex = this.root._animations.indexOf( this );\n\t\t\t\t// TODO investigate why this happens\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\twarn( 'Animation was not found' );\n\t\t\t\t}\n\t\t\t\tthis.root._animations.splice( index, 1 );\n\t\t\t}\n\t\t};\n\t\treturn Animation;\n\t}( warn, runloop, interpolate );\n\n\t/* Ractive/prototype/animate.js */\n\tvar Ractive$animate = function( isEqual, Promise, normaliseKeypath, animations, Animation ) {\n\n\t\tvar __export;\n\t\tvar noop = function() {},\n\t\t\tnoAnimation = {\n\t\t\t\tstop: noop\n\t\t\t};\n\t\t__export = function Ractive$animate( keypath, to, options ) {\n\t\t\tvar promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;\n\t\t\tpromise = new Promise( function( fulfil ) {\n\t\t\t\tfulfilPromise = fulfil;\n\t\t\t} );\n\t\t\t// animate multiple keypaths\n\t\t\tif ( typeof keypath === 'object' ) {\n\t\t\t\toptions = to || {};\n\t\t\t\teasing = options.easing;\n\t\t\t\tduration = options.duration;\n\t\t\t\tanimations = [];\n\t\t\t\t// we don't want to pass the `step` and `complete` handlers, as they will\n\t\t\t\t// run for each animation! So instead we'll store the handlers and create\n\t\t\t\t// our own...\n\t\t\t\tstep = options.step;\n\t\t\t\tcomplete = options.complete;\n\t\t\t\tif ( step || complete ) {\n\t\t\t\t\tcurrentValues = {};\n\t\t\t\t\toptions.step = null;\n\t\t\t\t\toptions.complete = null;\n\t\t\t\t\tmakeValueCollector = function( keypath ) {\n\t\t\t\t\t\treturn function( t, value ) {\n\t\t\t\t\t\t\tcurrentValues[ keypath ] = value;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tfor ( k in keypath ) {\n\t\t\t\t\tif ( keypath.hasOwnProperty( k ) ) {\n\t\t\t\t\t\tif ( step || complete ) {\n\t\t\t\t\t\t\tcollectValue = makeValueCollector( k );\n\t\t\t\t\t\t\toptions = {\n\t\t\t\t\t\t\t\teasing: easing,\n\t\t\t\t\t\t\t\tduration: duration\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif ( step ) {\n\t\t\t\t\t\t\t\toptions.step = collectValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptions.complete = complete ? collectValue : noop;\n\t\t\t\t\t\tanimations.push( animate( this, k, keypath[ k ], options ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Create a dummy animation, to facilitate step/complete\n\t\t\t\t// callbacks, and Promise fulfilment\n\t\t\t\tdummyOptions = {\n\t\t\t\t\teasing: easing,\n\t\t\t\t\tduration: duration\n\t\t\t\t};\n\t\t\t\tif ( step ) {\n\t\t\t\t\tdummyOptions.step = function( t ) {\n\t\t\t\t\t\tstep( t, currentValues );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif ( complete ) {\n\t\t\t\t\tpromise.then( function( t ) {\n\t\t\t\t\t\tcomplete( t, currentValues );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tdummyOptions.complete = fulfilPromise;\n\t\t\t\tdummy = animate( this, null, null, dummyOptions );\n\t\t\t\tanimations.push( dummy );\n\t\t\t\tpromise.stop = function() {\n\t\t\t\t\tvar animation;\n\t\t\t\t\twhile ( animation = animations.pop() ) {\n\t\t\t\t\t\tanimation.stop();\n\t\t\t\t\t}\n\t\t\t\t\tif ( dummy ) {\n\t\t\t\t\t\tdummy.stop();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\treturn promise;\n\t\t\t}\n\t\t\t// animate a single keypath\n\t\t\toptions = options || {};\n\t\t\tif ( options.complete ) {\n\t\t\t\tpromise.then( options.complete );\n\t\t\t}\n\t\t\toptions.complete = fulfilPromise;\n\t\t\tanimation = animate( this, keypath, to, options );\n\t\t\tpromise.stop = function() {\n\t\t\t\tanimation.stop();\n\t\t\t};\n\t\t\treturn promise;\n\t\t};\n\n\t\tfunction animate( root, keypath, to, options ) {\n\t\t\tvar easing, duration, animation, from;\n\t\t\tif ( keypath ) {\n\t\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\t}\n\t\t\tif ( keypath !== null ) {\n\t\t\t\tfrom = root.viewmodel.get( keypath );\n\t\t\t}\n\t\t\t// cancel any existing animation\n\t\t\t// TODO what about upstream/downstream keypaths?\n\t\t\tanimations.abort( keypath, root );\n\t\t\t// don't bother animating values that stay the same\n\t\t\tif ( isEqual( from, to ) ) {\n\t\t\t\tif ( options.complete ) {\n\t\t\t\t\toptions.complete( options.to );\n\t\t\t\t}\n\t\t\t\treturn noAnimation;\n\t\t\t}\n\t\t\t// easing function\n\t\t\tif ( options.easing ) {\n\t\t\t\tif ( typeof options.easing === 'function' ) {\n\t\t\t\t\teasing = options.easing;\n\t\t\t\t} else {\n\t\t\t\t\teasing = root.easing[ options.easing ];\n\t\t\t\t}\n\t\t\t\tif ( typeof easing !== 'function' ) {\n\t\t\t\t\teasing = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// duration\n\t\t\tduration = options.duration === undefined ? 400 : options.duration;\n\t\t\t// TODO store keys, use an internal set method\n\t\t\tanimation = new Animation( {\n\t\t\t\tkeypath: keypath,\n\t\t\t\tfrom: from,\n\t\t\t\tto: to,\n\t\t\t\troot: root,\n\t\t\t\tduration: duration,\n\t\t\t\teasing: easing,\n\t\t\t\tinterpolator: options.interpolator,\n\t\t\t\t// TODO wrap callbacks if necessary, to use instance as context\n\t\t\t\tstep: options.step,\n\t\t\t\tcomplete: options.complete\n\t\t\t} );\n\t\t\tanimations.add( animation );\n\t\t\troot._animations.push( animation );\n\t\t\treturn animation;\n\t\t}\n\t\treturn __export;\n\t}( isEqual, Promise, normaliseKeypath, animations, Ractive$animate_Animation );\n\n\t/* Ractive/prototype/detach.js */\n\tvar Ractive$detach = function( Hook, removeFromArray ) {\n\n\t\tvar detachHook = new Hook( 'detach' );\n\t\treturn function Ractive$detach() {\n\t\t\tif ( this.detached ) {\n\t\t\t\treturn this.detached;\n\t\t\t}\n\t\t\tif ( this.el ) {\n\t\t\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t\t\t}\n\t\t\tthis.detached = this.fragment.detach();\n\t\t\tdetachHook.fire( this );\n\t\t\treturn this.detached;\n\t\t};\n\t}( Ractive$shared_hooks_Hook, removeFromArray );\n\n\t/* Ractive/prototype/find.js */\n\tvar Ractive$find = function Ractive$find( selector ) {\n\t\tif ( !this.el ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.fragment.find( selector );\n\t};\n\n\t/* utils/matches.js */\n\tvar matches = function( isClient, vendors, createElement ) {\n\n\t\tvar matches, div, methodNames, unprefixed, prefixed, i, j, makeFunction;\n\t\tif ( !isClient ) {\n\t\t\tmatches = null;\n\t\t} else {\n\t\t\tdiv = createElement( 'div' );\n\t\t\tmethodNames = [\n\t\t\t\t'matches',\n\t\t\t\t'matchesSelector'\n\t\t\t];\n\t\t\tmakeFunction = function( methodName ) {\n\t\t\t\treturn function( node, selector ) {\n\t\t\t\t\treturn node[ methodName ]( selector );\n\t\t\t\t};\n\t\t\t};\n\t\t\ti = methodNames.length;\n\t\t\twhile ( i-- && !matches ) {\n\t\t\t\tunprefixed = methodNames[ i ];\n\t\t\t\tif ( div[ unprefixed ] ) {\n\t\t\t\t\tmatches = makeFunction( unprefixed );\n\t\t\t\t} else {\n\t\t\t\t\tj = vendors.length;\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\tprefixed = vendors[ i ] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );\n\t\t\t\t\t\tif ( div[ prefixed ] ) {\n\t\t\t\t\t\t\tmatches = makeFunction( prefixed );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// IE8...\n\t\t\tif ( !matches ) {\n\t\t\t\tmatches = function( node, selector ) {\n\t\t\t\t\tvar nodes, parentNode, i;\n\t\t\t\t\tparentNode = node.parentNode;\n\t\t\t\t\tif ( !parentNode ) {\n\t\t\t\t\t\t// empty dummy <div>\n\t\t\t\t\t\tdiv.innerHTML = '';\n\t\t\t\t\t\tparentNode = div;\n\t\t\t\t\t\tnode = node.cloneNode();\n\t\t\t\t\t\tdiv.appendChild( node );\n\t\t\t\t\t}\n\t\t\t\t\tnodes = parentNode.querySelectorAll( selector );\n\t\t\t\t\ti = nodes.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( nodes[ i ] === node ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn matches;\n\t}( isClient, vendors, createElement );\n\n\t/* Ractive/prototype/shared/makeQuery/test.js */\n\tvar Ractive$shared_makeQuery_test = function( matches ) {\n\n\t\treturn function( item, noDirty ) {\n\t\t\tvar itemMatches = this._isComponentQuery ? !this.selector || item.name === this.selector : matches( item.node, this.selector );\n\t\t\tif ( itemMatches ) {\n\t\t\t\tthis.push( item.node || item.instance );\n\t\t\t\tif ( !noDirty ) {\n\t\t\t\t\tthis._makeDirty();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}( matches );\n\n\t/* Ractive/prototype/shared/makeQuery/cancel.js */\n\tvar Ractive$shared_makeQuery_cancel = function() {\n\t\tvar liveQueries, selector, index;\n\t\tliveQueries = this._root[ this._isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];\n\t\tselector = this.selector;\n\t\tindex = liveQueries.indexOf( selector );\n\t\tif ( index !== -1 ) {\n\t\t\tliveQueries.splice( index, 1 );\n\t\t\tliveQueries[ selector ] = null;\n\t\t}\n\t};\n\n\t/* Ractive/prototype/shared/makeQuery/sortByItemPosition.js */\n\tvar Ractive$shared_makeQuery_sortByItemPosition = function() {\n\n\t\tvar __export;\n\t\t__export = function( a, b ) {\n\t\t\tvar ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;\n\t\t\tancestryA = getAncestry( a.component || a._ractive.proxy );\n\t\t\tancestryB = getAncestry( b.component || b._ractive.proxy );\n\t\t\toldestA = ancestryA[ ancestryA.length - 1 ];\n\t\t\toldestB = ancestryB[ ancestryB.length - 1 ];\n\t\t\t// remove items from the end of both ancestries as long as they are identical\n\t\t\t// - the final one removed is the closest mutual ancestor\n\t\t\twhile ( oldestA && oldestA === oldestB ) {\n\t\t\t\tancestryA.pop();\n\t\t\t\tancestryB.pop();\n\t\t\t\tmutualAncestor = oldestA;\n\t\t\t\toldestA = ancestryA[ ancestryA.length - 1 ];\n\t\t\t\toldestB = ancestryB[ ancestryB.length - 1 ];\n\t\t\t}\n\t\t\t// now that we have the mutual ancestor, we can find which is earliest\n\t\t\toldestA = oldestA.component || oldestA;\n\t\t\toldestB = oldestB.component || oldestB;\n\t\t\tfragmentA = oldestA.parentFragment;\n\t\t\tfragmentB = oldestB.parentFragment;\n\t\t\t// if both items share a parent fragment, our job is easy\n\t\t\tif ( fragmentA === fragmentB ) {\n\t\t\t\tindexA = fragmentA.items.indexOf( oldestA );\n\t\t\t\tindexB = fragmentB.items.indexOf( oldestB );\n\t\t\t\t// if it's the same index, it means one contains the other,\n\t\t\t\t// so we see which has the longest ancestry\n\t\t\t\treturn indexA - indexB || ancestryA.length - ancestryB.length;\n\t\t\t}\n\t\t\t// if mutual ancestor is a section, we first test to see which section\n\t\t\t// fragment comes first\n\t\t\tif ( fragments = mutualAncestor.fragments ) {\n\t\t\t\tindexA = fragments.indexOf( fragmentA );\n\t\t\t\tindexB = fragments.indexOf( fragmentB );\n\t\t\t\treturn indexA - indexB || ancestryA.length - ancestryB.length;\n\t\t\t}\n\t\t\tthrow new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!' );\n\t\t};\n\n\t\tfunction getParent( item ) {\n\t\t\tvar parentFragment;\n\t\t\tif ( parentFragment = item.parentFragment ) {\n\t\t\t\treturn parentFragment.owner;\n\t\t\t}\n\t\t\tif ( item.component && ( parentFragment = item.component.parentFragment ) ) {\n\t\t\t\treturn parentFragment.owner;\n\t\t\t}\n\t\t}\n\n\t\tfunction getAncestry( item ) {\n\t\t\tvar ancestry, ancestor;\n\t\t\tancestry = [ item ];\n\t\t\tancestor = getParent( item );\n\t\t\twhile ( ancestor ) {\n\t\t\t\tancestry.push( ancestor );\n\t\t\t\tancestor = getParent( ancestor );\n\t\t\t}\n\t\t\treturn ancestry;\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js */\n\tvar Ractive$shared_makeQuery_sortByDocumentPosition = function( sortByItemPosition ) {\n\n\t\treturn function( node, otherNode ) {\n\t\t\tvar bitmask;\n\t\t\tif ( node.compareDocumentPosition ) {\n\t\t\t\tbitmask = node.compareDocumentPosition( otherNode );\n\t\t\t\treturn bitmask & 2 ? 1 : -1;\n\t\t\t}\n\t\t\t// In old IE, we can piggy back on the mechanism for\n\t\t\t// comparing component positions\n\t\t\treturn sortByItemPosition( node, otherNode );\n\t\t};\n\t}( Ractive$shared_makeQuery_sortByItemPosition );\n\n\t/* Ractive/prototype/shared/makeQuery/sort.js */\n\tvar Ractive$shared_makeQuery_sort = function( sortByDocumentPosition, sortByItemPosition ) {\n\n\t\treturn function() {\n\t\t\tthis.sort( this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition );\n\t\t\tthis._dirty = false;\n\t\t};\n\t}( Ractive$shared_makeQuery_sortByDocumentPosition, Ractive$shared_makeQuery_sortByItemPosition );\n\n\t/* Ractive/prototype/shared/makeQuery/dirty.js */\n\tvar Ractive$shared_makeQuery_dirty = function( runloop ) {\n\n\t\treturn function() {\n\t\t\tvar this$0 = this;\n\t\t\tif ( !this._dirty ) {\n\t\t\t\tthis._dirty = true;\n\t\t\t\t// Once the DOM has been updated, ensure the query\n\t\t\t\t// is correctly ordered\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\tthis$0._sort();\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\t}( runloop );\n\n\t/* Ractive/prototype/shared/makeQuery/remove.js */\n\tvar Ractive$shared_makeQuery_remove = function( nodeOrComponent ) {\n\t\tvar index = this.indexOf( this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );\n\t\tif ( index !== -1 ) {\n\t\t\tthis.splice( index, 1 );\n\t\t}\n\t};\n\n\t/* Ractive/prototype/shared/makeQuery/_makeQuery.js */\n\tvar Ractive$shared_makeQuery__makeQuery = function( defineProperties, test, cancel, sort, dirty, remove ) {\n\n\t\treturn function makeQuery( ractive, selector, live, isComponentQuery ) {\n\t\t\tvar query = [];\n\t\t\tdefineProperties( query, {\n\t\t\t\tselector: {\n\t\t\t\t\tvalue: selector\n\t\t\t\t},\n\t\t\t\tlive: {\n\t\t\t\t\tvalue: live\n\t\t\t\t},\n\t\t\t\t_isComponentQuery: {\n\t\t\t\t\tvalue: isComponentQuery\n\t\t\t\t},\n\t\t\t\t_test: {\n\t\t\t\t\tvalue: test\n\t\t\t\t}\n\t\t\t} );\n\t\t\tif ( !live ) {\n\t\t\t\treturn query;\n\t\t\t}\n\t\t\tdefineProperties( query, {\n\t\t\t\tcancel: {\n\t\t\t\t\tvalue: cancel\n\t\t\t\t},\n\t\t\t\t_root: {\n\t\t\t\t\tvalue: ractive\n\t\t\t\t},\n\t\t\t\t_sort: {\n\t\t\t\t\tvalue: sort\n\t\t\t\t},\n\t\t\t\t_makeDirty: {\n\t\t\t\t\tvalue: dirty\n\t\t\t\t},\n\t\t\t\t_remove: {\n\t\t\t\t\tvalue: remove\n\t\t\t\t},\n\t\t\t\t_dirty: {\n\t\t\t\t\tvalue: false,\n\t\t\t\t\twritable: true\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn query;\n\t\t};\n\t}( defineProperties, Ractive$shared_makeQuery_test, Ractive$shared_makeQuery_cancel, Ractive$shared_makeQuery_sort, Ractive$shared_makeQuery_dirty, Ractive$shared_makeQuery_remove );\n\n\t/* Ractive/prototype/findAll.js */\n\tvar Ractive$findAll = function( makeQuery ) {\n\n\t\treturn function Ractive$findAll( selector, options ) {\n\t\t\tvar liveQueries, query;\n\t\t\tif ( !this.el ) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\toptions = options || {};\n\t\t\tliveQueries = this._liveQueries;\n\t\t\t// Shortcut: if we're maintaining a live query with this\n\t\t\t// selector, we don't need to traverse the parallel DOM\n\t\t\tif ( query = liveQueries[ selector ] ) {\n\t\t\t\t// Either return the exact same query, or (if not live) a snapshot\n\t\t\t\treturn options && options.live ? query : query.slice();\n\t\t\t}\n\t\t\tquery = makeQuery( this, selector, !!options.live, false );\n\t\t\t// Add this to the list of live queries Ractive needs to maintain,\n\t\t\t// if applicable\n\t\t\tif ( query.live ) {\n\t\t\t\tliveQueries.push( selector );\n\t\t\t\tliveQueries[ '_' + selector ] = query;\n\t\t\t}\n\t\t\tthis.fragment.findAll( selector, query );\n\t\t\treturn query;\n\t\t};\n\t}( Ractive$shared_makeQuery__makeQuery );\n\n\t/* Ractive/prototype/findAllComponents.js */\n\tvar Ractive$findAllComponents = function( makeQuery ) {\n\n\t\treturn function Ractive$findAllComponents( selector, options ) {\n\t\t\tvar liveQueries, query;\n\t\t\toptions = options || {};\n\t\t\tliveQueries = this._liveComponentQueries;\n\t\t\t// Shortcut: if we're maintaining a live query with this\n\t\t\t// selector, we don't need to traverse the parallel DOM\n\t\t\tif ( query = liveQueries[ selector ] ) {\n\t\t\t\t// Either return the exact same query, or (if not live) a snapshot\n\t\t\t\treturn options && options.live ? query : query.slice();\n\t\t\t}\n\t\t\tquery = makeQuery( this, selector, !!options.live, true );\n\t\t\t// Add this to the list of live queries Ractive needs to maintain,\n\t\t\t// if applicable\n\t\t\tif ( query.live ) {\n\t\t\t\tliveQueries.push( selector );\n\t\t\t\tliveQueries[ '_' + selector ] = query;\n\t\t\t}\n\t\t\tthis.fragment.findAllComponents( selector, query );\n\t\t\treturn query;\n\t\t};\n\t}( Ractive$shared_makeQuery__makeQuery );\n\n\t/* Ractive/prototype/findComponent.js */\n\tvar Ractive$findComponent = function Ractive$findComponent( selector ) {\n\t\treturn this.fragment.findComponent( selector );\n\t};\n\n\t/* utils/getPotentialWildcardMatches.js */\n\tvar getPotentialWildcardMatches = function() {\n\n\t\tvar __export;\n\t\tvar starMaps = {};\n\t\t// This function takes a keypath such as 'foo.bar.baz', and returns\n\t\t// all the variants of that keypath that include a wildcard in place\n\t\t// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.\n\t\t// These are then checked against the dependants map (ractive.viewmodel.depsMap)\n\t\t// to see if any pattern observers are downstream of one or more of\n\t\t// these wildcard keypaths (e.g. 'foo.bar.*.status')\n\t\t__export = function getPotentialWildcardMatches( keypath ) {\n\t\t\tvar keys, starMap, mapper, i, result, wildcardKeypath;\n\t\t\tkeys = keypath.split( '.' );\n\t\t\tif ( !( starMap = starMaps[ keys.length ] ) ) {\n\t\t\t\tstarMap = getStarMap( keys.length );\n\t\t\t}\n\t\t\tresult = [];\n\t\t\tmapper = function( star, i ) {\n\t\t\t\treturn star ? '*' : keys[ i ];\n\t\t\t};\n\t\t\ti = starMap.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\twildcardKeypath = starMap[ i ].map( mapper ).join( '.' );\n\t\t\t\tif ( !result.hasOwnProperty( wildcardKeypath ) ) {\n\t\t\t\t\tresult.push( wildcardKeypath );\n\t\t\t\t\tresult[ wildcardKeypath ] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\t// This function returns all the possible true/false combinations for\n\t\t// a given number - e.g. for two, the possible combinations are\n\t\t// [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n\t\t// It does so by getting all the binary values between 0 and e.g. 11\n\t\tfunction getStarMap( num ) {\n\t\t\tvar ones = '',\n\t\t\t\tmax, binary, starMap, mapper, i;\n\t\t\tif ( !starMaps[ num ] ) {\n\t\t\t\tstarMap = [];\n\t\t\t\twhile ( ones.length < num ) {\n\t\t\t\t\tones += 1;\n\t\t\t\t}\n\t\t\t\tmax = parseInt( ones, 2 );\n\t\t\t\tmapper = function( digit ) {\n\t\t\t\t\treturn digit === '1';\n\t\t\t\t};\n\t\t\t\tfor ( i = 0; i <= max; i += 1 ) {\n\t\t\t\t\tbinary = i.toString( 2 );\n\t\t\t\t\twhile ( binary.length < num ) {\n\t\t\t\t\t\tbinary = '0' + binary;\n\t\t\t\t\t}\n\t\t\t\t\tstarMap[ i ] = Array.prototype.map.call( binary, mapper );\n\t\t\t\t}\n\t\t\t\tstarMaps[ num ] = starMap;\n\t\t\t}\n\t\t\treturn starMaps[ num ];\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* Ractive/prototype/shared/fireEvent.js */\n\tvar Ractive$shared_fireEvent = function( getPotentialWildcardMatches ) {\n\n\t\tvar __export;\n\t\t__export = function fireEvent( ractive, eventName ) {\n\t\t\tvar options = arguments[ 2 ];\n\t\t\tif ( options === void 0 )\n\t\t\t\toptions = {};\n\t\t\tif ( !eventName ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( !options.event ) {\n\t\t\t\toptions.event = {\n\t\t\t\t\tname: eventName,\n\t\t\t\t\tcontext: ractive.data,\n\t\t\t\t\tkeypath: '',\n\t\t\t\t\t// until event not included as argument default\n\t\t\t\t\t_noArg: true\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\toptions.event.name = eventName;\n\t\t\t}\n\t\t\tvar eventNames = getPotentialWildcardMatches( eventName );\n\t\t\tfireEventAs( ractive, eventNames, options.event, options.args, true );\n\t\t};\n\n\t\tfunction fireEventAs( ractive, eventNames, event, args ) {\n\t\t\tvar initialFire = arguments[ 4 ];\n\t\t\tif ( initialFire === void 0 )\n\t\t\t\tinitialFire = false;\n\t\t\tvar subscribers, i, bubble = true;\n\t\t\tif ( event ) {\n\t\t\t\tractive.event = event;\n\t\t\t}\n\t\t\tfor ( i = eventNames.length; i >= 0; i-- ) {\n\t\t\t\tsubscribers = ractive._subs[ eventNames[ i ] ];\n\t\t\t\tif ( subscribers ) {\n\t\t\t\t\tbubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( event ) {\n\t\t\t\tdelete ractive.event;\n\t\t\t}\n\t\t\tif ( ractive._parent && bubble ) {\n\t\t\t\tif ( initialFire && ractive.component ) {\n\t\t\t\t\tvar fullName = ractive.component.name + '.' + eventNames[ eventNames.length - 1 ];\n\t\t\t\t\teventNames = getPotentialWildcardMatches( fullName );\n\t\t\t\t\tif ( event ) {\n\t\t\t\t\t\tevent.component = ractive;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfireEventAs( ractive._parent, eventNames, event, args );\n\t\t\t}\n\t\t}\n\n\t\tfunction notifySubscribers( ractive, subscribers, event, args ) {\n\t\t\tvar originalEvent = null,\n\t\t\t\tstopEvent = false;\n\t\t\tif ( event && !event._noArg ) {\n\t\t\t\targs = [ event ].concat( args );\n\t\t\t}\n\t\t\tfor ( var i = 0, len = subscribers.length; i < len; i += 1 ) {\n\t\t\t\tif ( subscribers[ i ].apply( ractive, args ) === false ) {\n\t\t\t\t\tstopEvent = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {\n\t\t\t\toriginalEvent.preventDefault && originalEvent.preventDefault();\n\t\t\t\toriginalEvent.stopPropagation && originalEvent.stopPropagation();\n\t\t\t}\n\t\t\treturn !stopEvent;\n\t\t}\n\t\treturn __export;\n\t}( getPotentialWildcardMatches );\n\n\t/* Ractive/prototype/fire.js */\n\tvar Ractive$fire = function( fireEvent ) {\n\n\t\treturn function Ractive$fire( eventName ) {\n\t\t\tvar options = {\n\t\t\t\targs: Array.prototype.slice.call( arguments, 1 )\n\t\t\t};\n\t\t\tfireEvent( this, eventName, options );\n\t\t};\n\t}( Ractive$shared_fireEvent );\n\n\t/* Ractive/prototype/get.js */\n\tvar Ractive$get = function( normaliseKeypath, resolveRef ) {\n\n\t\tvar options = {\n\t\t\tcapture: true\n\t\t};\n\t\t// top-level calls should be intercepted\n\t\treturn function Ractive$get( keypath ) {\n\t\t\tvar value;\n\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\tvalue = this.viewmodel.get( keypath, options );\n\t\t\t// Create inter-component binding, if necessary\n\t\t\tif ( value === undefined && this._parent && !this.isolated ) {\n\t\t\t\tif ( resolveRef( this, keypath, this.fragment ) ) {\n\t\t\t\t\t// creates binding as side-effect, if appropriate\n\t\t\t\t\tvalue = this.viewmodel.get( keypath );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\t}( normaliseKeypath, resolveRef );\n\n\t/* utils/getElement.js */\n\tvar getElement = function getElement( input ) {\n\t\tvar output;\n\t\tif ( !input || typeof input === 'boolean' ) {\n\t\t\treturn;\n\t\t}\n\t\tif ( typeof window === 'undefined' || !document || !input ) {\n\t\t\treturn null;\n\t\t}\n\t\t// We already have a DOM node - no work to do. (Duck typing alert!)\n\t\tif ( input.nodeType ) {\n\t\t\treturn input;\n\t\t}\n\t\t// Get node from string\n\t\tif ( typeof input === 'string' ) {\n\t\t\t// try ID first\n\t\t\toutput = document.getElementById( input );\n\t\t\t// then as selector, if possible\n\t\t\tif ( !output && document.querySelector ) {\n\t\t\t\toutput = document.querySelector( input );\n\t\t\t}\n\t\t\t// did it work?\n\t\t\tif ( output && output.nodeType ) {\n\t\t\t\treturn output;\n\t\t\t}\n\t\t}\n\t\t// If we've been given a collection (jQuery, Zepto etc), extract the first item\n\t\tif ( input[ 0 ] && input[ 0 ].nodeType ) {\n\t\t\treturn input[ 0 ];\n\t\t}\n\t\treturn null;\n\t};\n\n\t/* Ractive/prototype/insert.js */\n\tvar Ractive$insert = function( Hook, getElement ) {\n\n\t\tvar __export;\n\t\tvar insertHook = new Hook( 'insert' );\n\t\t__export = function Ractive$insert( target, anchor ) {\n\t\t\tif ( !this.fragment.rendered ) {\n\t\t\t\t// TODO create, and link to, documentation explaining this\n\t\t\t\tthrow new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );\n\t\t\t}\n\t\t\ttarget = getElement( target );\n\t\t\tanchor = getElement( anchor ) || null;\n\t\t\tif ( !target ) {\n\t\t\t\tthrow new Error( 'You must specify a valid target to insert into' );\n\t\t\t}\n\t\t\ttarget.insertBefore( this.detach(), anchor );\n\t\t\tthis.el = target;\n\t\t\t( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );\n\t\t\tthis.detached = null;\n\t\t\tfireInsertHook( this );\n\t\t};\n\n\t\tfunction fireInsertHook( ractive ) {\n\t\t\tinsertHook.fire( ractive );\n\t\t\tractive.findAllComponents( '*' ).forEach( function( child ) {\n\t\t\t\tfireInsertHook( child.instance );\n\t\t\t} );\n\t\t}\n\t\treturn __export;\n\t}( Ractive$shared_hooks_Hook, getElement );\n\n\t/* Ractive/prototype/merge.js */\n\tvar Ractive$merge = function( runloop, isArray, normaliseKeypath ) {\n\n\t\treturn function Ractive$merge( keypath, array, options ) {\n\t\t\tvar currentArray, promise;\n\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\tcurrentArray = this.viewmodel.get( keypath );\n\t\t\t// If either the existing value or the new value isn't an\n\t\t\t// array, just do a regular set\n\t\t\tif ( !isArray( currentArray ) || !isArray( array ) ) {\n\t\t\t\treturn this.set( keypath, array, options && options.complete );\n\t\t\t}\n\t\t\t// Manage transitions\n\t\t\tpromise = runloop.start( this, true );\n\t\t\tthis.viewmodel.merge( keypath, currentArray, array, options );\n\t\t\trunloop.end();\n\t\t\t// attach callback as fulfilment handler, if specified\n\t\t\tif ( options && options.complete ) {\n\t\t\t\tpromise.then( options.complete );\n\t\t\t}\n\t\t\treturn promise;\n\t\t};\n\t}( runloop, isArray, normaliseKeypath );\n\n\t/* Ractive/prototype/observe/Observer.js */\n\tvar Ractive$observe_Observer = function( runloop, isEqual ) {\n\n\t\tvar Observer = function( ractive, keypath, callback, options ) {\n\t\t\tthis.root = ractive;\n\t\t\tthis.keypath = keypath;\n\t\t\tthis.callback = callback;\n\t\t\tthis.defer = options.defer;\n\t\t\t// default to root as context, but allow it to be overridden\n\t\t\tthis.context = options && options.context ? options.context : ractive;\n\t\t};\n\t\tObserver.prototype = {\n\t\t\tinit: function( immediate ) {\n\t\t\t\tthis.value = this.root.get( this.keypath );\n\t\t\t\tif ( immediate !== false ) {\n\t\t\t\t\tthis.update();\n\t\t\t\t} else {\n\t\t\t\t\tthis.oldValue = this.value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetValue: function( value ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\tif ( this.defer && this.ready ) {\n\t\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\t\treturn this$0.update();\n\t\t\t\t\t\t} );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.update();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tupdate: function() {\n\t\t\t\t// Prevent infinite loops\n\t\t\t\tif ( this.updating ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.updating = true;\n\t\t\t\tthis.callback.call( this.context, this.value, this.oldValue, this.keypath );\n\t\t\t\tthis.oldValue = this.value;\n\t\t\t\tthis.updating = false;\n\t\t\t}\n\t\t};\n\t\treturn Observer;\n\t}( runloop, isEqual );\n\n\t/* shared/getMatchingKeypaths.js */\n\tvar getMatchingKeypaths = function( isArray ) {\n\n\t\treturn function getMatchingKeypaths( ractive, pattern ) {\n\t\t\tvar keys, key, matchingKeypaths;\n\t\t\tkeys = pattern.split( '.' );\n\t\t\tmatchingKeypaths = [ '' ];\n\t\t\twhile ( key = keys.shift() ) {\n\t\t\t\tif ( key === '*' ) {\n\t\t\t\t\t// expand to find all valid child keypaths\n\t\t\t\t\tmatchingKeypaths = matchingKeypaths.reduce( expand, [] );\n\t\t\t\t} else {\n\t\t\t\t\tif ( matchingKeypaths[ 0 ] === '' ) {\n\t\t\t\t\t\t// first key\n\t\t\t\t\t\tmatchingKeypaths[ 0 ] = key;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatchingKeypaths = matchingKeypaths.map( concatenate( key ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matchingKeypaths;\n\n\t\t\tfunction expand( matchingKeypaths, keypath ) {\n\t\t\t\tvar value, key, childKeypath;\n\t\t\t\tvalue = ractive.viewmodel.wrapped[ keypath ] ? ractive.viewmodel.wrapped[ keypath ].get() : ractive.get( keypath );\n\t\t\t\tfor ( key in value ) {\n\t\t\t\t\tif ( value.hasOwnProperty( key ) && ( key !== '_ractive' || !isArray( value ) ) ) {\n\t\t\t\t\t\t// for benefit of IE8\n\t\t\t\t\t\tchildKeypath = keypath ? keypath + '.' + key : key;\n\t\t\t\t\t\tmatchingKeypaths.push( childKeypath );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn matchingKeypaths;\n\t\t\t}\n\n\t\t\tfunction concatenate( key ) {\n\t\t\t\treturn function( keypath ) {\n\t\t\t\t\treturn keypath ? keypath + '.' + key : key;\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}( isArray );\n\n\t/* Ractive/prototype/observe/getPattern.js */\n\tvar Ractive$observe_getPattern = function( getMatchingKeypaths ) {\n\n\t\treturn function getPattern( ractive, pattern ) {\n\t\t\tvar matchingKeypaths, values;\n\t\t\tmatchingKeypaths = getMatchingKeypaths( ractive, pattern );\n\t\t\tvalues = {};\n\t\t\tmatchingKeypaths.forEach( function( keypath ) {\n\t\t\t\tvalues[ keypath ] = ractive.get( keypath );\n\t\t\t} );\n\t\t\treturn values;\n\t\t};\n\t}( getMatchingKeypaths );\n\n\t/* Ractive/prototype/observe/PatternObserver.js */\n\tvar Ractive$observe_PatternObserver = function( runloop, isEqual, getPattern ) {\n\n\t\tvar PatternObserver, wildcard = /\\*/,\n\t\t\tslice = Array.prototype.slice;\n\t\tPatternObserver = function( ractive, keypath, callback, options ) {\n\t\t\tthis.root = ractive;\n\t\t\tthis.callback = callback;\n\t\t\tthis.defer = options.defer;\n\t\t\tthis.keypath = keypath;\n\t\t\tthis.regex = new RegExp( '^' + keypath.replace( /\\./g, '\\\\.' ).replace( /\\*/g, '([^\\\\.]+)' ) + '$' );\n\t\t\tthis.values = {};\n\t\t\tif ( this.defer ) {\n\t\t\t\tthis.proxies = [];\n\t\t\t}\n\t\t\t// default to root as context, but allow it to be overridden\n\t\t\tthis.context = options && options.context ? options.context : ractive;\n\t\t};\n\t\tPatternObserver.prototype = {\n\t\t\tinit: function( immediate ) {\n\t\t\t\tvar values, keypath;\n\t\t\t\tvalues = getPattern( this.root, this.keypath );\n\t\t\t\tif ( immediate !== false ) {\n\t\t\t\t\tfor ( keypath in values ) {\n\t\t\t\t\t\tif ( values.hasOwnProperty( keypath ) ) {\n\t\t\t\t\t\t\tthis.update( keypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.values = values;\n\t\t\t\t}\n\t\t\t},\n\t\t\tupdate: function( keypath ) {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar values;\n\t\t\t\tif ( wildcard.test( keypath ) ) {\n\t\t\t\t\tvalues = getPattern( this.root, keypath );\n\t\t\t\t\tfor ( keypath in values ) {\n\t\t\t\t\t\tif ( values.hasOwnProperty( keypath ) ) {\n\t\t\t\t\t\t\tthis.update( keypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// special case - array mutation should not trigger `array.*`\n\t\t\t\t// pattern observer with `array.length`\n\t\t\t\tif ( this.root.viewmodel.implicitChanges[ keypath ] ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( this.defer && this.ready ) {\n\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\treturn this$0.getProxy( keypath ).update();\n\t\t\t\t\t} );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.reallyUpdate( keypath );\n\t\t\t},\n\t\t\treallyUpdate: function( keypath ) {\n\t\t\t\tvar value, keys, args;\n\t\t\t\tvalue = this.root.viewmodel.get( keypath );\n\t\t\t\t// Prevent infinite loops\n\t\t\t\tif ( this.updating ) {\n\t\t\t\t\tthis.values[ keypath ] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.updating = true;\n\t\t\t\tif ( !isEqual( value, this.values[ keypath ] ) || !this.ready ) {\n\t\t\t\t\tkeys = slice.call( this.regex.exec( keypath ), 1 );\n\t\t\t\t\targs = [\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tthis.values[ keypath ],\n\t\t\t\t\t\tkeypath\n\t\t\t\t\t].concat( keys );\n\t\t\t\t\tthis.callback.apply( this.context, args );\n\t\t\t\t\tthis.values[ keypath ] = value;\n\t\t\t\t}\n\t\t\t\tthis.updating = false;\n\t\t\t},\n\t\t\tgetProxy: function( keypath ) {\n\t\t\t\tvar self = this;\n\t\t\t\tif ( !this.proxies[ keypath ] ) {\n\t\t\t\t\tthis.proxies[ keypath ] = {\n\t\t\t\t\t\tupdate: function() {\n\t\t\t\t\t\t\tself.reallyUpdate( keypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn this.proxies[ keypath ];\n\t\t\t}\n\t\t};\n\t\treturn PatternObserver;\n\t}( runloop, isEqual, Ractive$observe_getPattern );\n\n\t/* Ractive/prototype/observe/getObserverFacade.js */\n\tvar Ractive$observe_getObserverFacade = function( normaliseKeypath, Observer, PatternObserver ) {\n\n\t\tvar wildcard = /\\*/,\n\t\t\temptyObject = {};\n\t\treturn function getObserverFacade( ractive, keypath, callback, options ) {\n\t\t\tvar observer, isPatternObserver, cancelled;\n\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\toptions = options || emptyObject;\n\t\t\t// pattern observers are treated differently\n\t\t\tif ( wildcard.test( keypath ) ) {\n\t\t\t\tobserver = new PatternObserver( ractive, keypath, callback, options );\n\t\t\t\tractive.viewmodel.patternObservers.push( observer );\n\t\t\t\tisPatternObserver = true;\n\t\t\t} else {\n\t\t\t\tobserver = new Observer( ractive, keypath, callback, options );\n\t\t\t}\n\t\t\tractive.viewmodel.register( keypath, observer, isPatternObserver ? 'patternObservers' : 'observers' );\n\t\t\tobserver.init( options.init );\n\t\t\t// This flag allows observers to initialise even with undefined values\n\t\t\tobserver.ready = true;\n\t\t\treturn {\n\t\t\t\tcancel: function() {\n\t\t\t\t\tvar index;\n\t\t\t\t\tif ( cancelled ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( isPatternObserver ) {\n\t\t\t\t\t\tindex = ractive.viewmodel.patternObservers.indexOf( observer );\n\t\t\t\t\t\tractive.viewmodel.patternObservers.splice( index, 1 );\n\t\t\t\t\t\tractive.viewmodel.unregister( keypath, observer, 'patternObservers' );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tractive.viewmodel.unregister( keypath, observer, 'observers' );\n\t\t\t\t\t}\n\t\t\t\t\tcancelled = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}( normaliseKeypath, Ractive$observe_Observer, Ractive$observe_PatternObserver );\n\n\t/* Ractive/prototype/observe.js */\n\tvar Ractive$observe = function( isObject, getObserverFacade ) {\n\n\t\treturn function Ractive$observe( keypath, callback, options ) {\n\t\t\tvar observers, map, keypaths, i;\n\t\t\t// Allow a map of keypaths to handlers\n\t\t\tif ( isObject( keypath ) ) {\n\t\t\t\toptions = callback;\n\t\t\t\tmap = keypath;\n\t\t\t\tobservers = [];\n\t\t\t\tfor ( keypath in map ) {\n\t\t\t\t\tif ( map.hasOwnProperty( keypath ) ) {\n\t\t\t\t\t\tcallback = map[ keypath ];\n\t\t\t\t\t\tobservers.push( this.observe( keypath, callback, options ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tcancel: function() {\n\t\t\t\t\t\twhile ( observers.length ) {\n\t\t\t\t\t\t\tobservers.pop().cancel();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\t// Allow `ractive.observe( callback )` - i.e. observe entire model\n\t\t\tif ( typeof keypath === 'function' ) {\n\t\t\t\toptions = callback;\n\t\t\t\tcallback = keypath;\n\t\t\t\tkeypath = '';\n\t\t\t\treturn getObserverFacade( this, keypath, callback, options );\n\t\t\t}\n\t\t\tkeypaths = keypath.split( ' ' );\n\t\t\t// Single keypath\n\t\t\tif ( keypaths.length === 1 ) {\n\t\t\t\treturn getObserverFacade( this, keypath, callback, options );\n\t\t\t}\n\t\t\t// Multiple space-separated keypaths\n\t\t\tobservers = [];\n\t\t\ti = keypaths.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tkeypath = keypaths[ i ];\n\t\t\t\tif ( keypath ) {\n\t\t\t\t\tobservers.push( getObserverFacade( this, keypath, callback, options ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tcancel: function() {\n\t\t\t\t\twhile ( observers.length ) {\n\t\t\t\t\t\tobservers.pop().cancel();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}( isObject, Ractive$observe_getObserverFacade );\n\n\t/* Ractive/prototype/shared/trim.js */\n\tvar Ractive$shared_trim = function( str ) {\n\t\treturn str.trim();\n\t};\n\n\t/* Ractive/prototype/shared/notEmptyString.js */\n\tvar Ractive$shared_notEmptyString = function( str ) {\n\t\treturn str !== '';\n\t};\n\n\t/* Ractive/prototype/off.js */\n\tvar Ractive$off = function( trim, notEmptyString ) {\n\n\t\treturn function Ractive$off( eventName, callback ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar eventNames;\n\t\t\t// if no arguments specified, remove all callbacks\n\t\t\tif ( !eventName ) {\n\t\t\t\t// TODO use this code instead, once the following issue has been resolved\n\t\t\t\t// in PhantomJS (tests are unpassable otherwise!)\n\t\t\t\t// https://github.com/ariya/phantomjs/issues/11856\n\t\t\t\t// defineProperty( this, '_subs', { value: create( null ), configurable: true });\n\t\t\t\tfor ( eventName in this._subs ) {\n\t\t\t\t\tdelete this._subs[ eventName ];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Handle multiple space-separated event names\n\t\t\t\teventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\t\t\t\teventNames.forEach( function( eventName ) {\n\t\t\t\t\tvar subscribers, index;\n\t\t\t\t\t// If we have subscribers for this event...\n\t\t\t\t\tif ( subscribers = this$0._subs[ eventName ] ) {\n\t\t\t\t\t\t// ...if a callback was specified, only remove that\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tindex = subscribers.indexOf( callback );\n\t\t\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\t\t\tsubscribers.splice( index, 1 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis$0._subs[ eventName ] = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\t}( Ractive$shared_trim, Ractive$shared_notEmptyString );\n\n\t/* Ractive/prototype/on.js */\n\tvar Ractive$on = function( trim, notEmptyString ) {\n\n\t\treturn function Ractive$on( eventName, callback ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar self = this,\n\t\t\t\tlisteners, n, eventNames;\n\t\t\t// allow mutliple listeners to be bound in one go\n\t\t\tif ( typeof eventName === 'object' ) {\n\t\t\t\tlisteners = [];\n\t\t\t\tfor ( n in eventName ) {\n\t\t\t\t\tif ( eventName.hasOwnProperty( n ) ) {\n\t\t\t\t\t\tlisteners.push( this.on( n, eventName[ n ] ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tcancel: function() {\n\t\t\t\t\t\tvar listener;\n\t\t\t\t\t\twhile ( listener = listeners.pop() ) {\n\t\t\t\t\t\t\tlistener.cancel();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\t// Handle multiple space-separated event names\n\t\t\teventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\t\t\teventNames.forEach( function( eventName ) {\n\t\t\t\t( this$0._subs[ eventName ] || ( this$0._subs[ eventName ] = [] ) ).push( callback );\n\t\t\t} );\n\t\t\treturn {\n\t\t\t\tcancel: function() {\n\t\t\t\t\tself.off( eventName, callback );\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}( Ractive$shared_trim, Ractive$shared_notEmptyString );\n\n\t/* shared/getNewIndices.js */\n\tvar getNewIndices = function() {\n\n\t\tvar __export;\n\t\t// This function takes an array, the name of a mutator method, and the\n\t\t// arguments to call that mutator method with, and returns an array that\n\t\t// maps the old indices to their new indices.\n\t\t// So if you had something like this...\n\t\t//\n\t\t//     array = [ 'a', 'b', 'c', 'd' ];\n\t\t//     array.push( 'e' );\n\t\t//\n\t\t// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n\t\t// have changed. If you then did this...\n\t\t//\n\t\t//     array.unshift( 'z' );\n\t\t//\n\t\t// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n\t\t// one higher to make room for the 'z'. If you removed an item, the new index\n\t\t// would be -1...\n\t\t//\n\t\t//     array.splice( 2, 2 );\n\t\t//\n\t\t// ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n\t\t//\n\t\t// This information is used to enable fast, non-destructive shuffling of list\n\t\t// sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\t\t__export = function getNewIndices( array, methodName, args ) {\n\t\t\tvar spliceArguments, len, newIndices = [],\n\t\t\t\tremoveStart, removeEnd, balance, i;\n\t\t\tspliceArguments = getSpliceEquivalent( array, methodName, args );\n\t\t\tif ( !spliceArguments ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tlen = array.length;\n\t\t\tbalance = spliceArguments.length - 2 - spliceArguments[ 1 ];\n\t\t\tremoveStart = Math.min( len, spliceArguments[ 0 ] );\n\t\t\tremoveEnd = removeStart + spliceArguments[ 1 ];\n\t\t\tfor ( i = 0; i < removeStart; i += 1 ) {\n\t\t\t\tnewIndices.push( i );\n\t\t\t}\n\t\t\tfor ( ; i < removeEnd; i += 1 ) {\n\t\t\t\tnewIndices.push( -1 );\n\t\t\t}\n\t\t\tfor ( ; i < len; i += 1 ) {\n\t\t\t\tnewIndices.push( i + balance );\n\t\t\t}\n\t\t\treturn newIndices;\n\t\t};\n\t\t// The pop, push, shift an unshift methods can all be represented\n\t\t// as an equivalent splice\n\t\tfunction getSpliceEquivalent( array, methodName, args ) {\n\t\t\tswitch ( methodName ) {\n\t\t\t\tcase 'splice':\n\t\t\t\t\tif ( args[ 0 ] !== undefined && args[ 0 ] < 0 ) {\n\t\t\t\t\t\targs[ 0 ] = array.length + Math.max( args[ 0 ], -array.length );\n\t\t\t\t\t}\n\t\t\t\t\twhile ( args.length < 2 ) {\n\t\t\t\t\t\targs.push( 0 );\n\t\t\t\t\t}\n\t\t\t\t\t// ensure we only remove elements that exist\n\t\t\t\t\targs[ 1 ] = Math.min( args[ 1 ], array.length - args[ 0 ] );\n\t\t\t\t\treturn args;\n\t\t\t\tcase 'sort':\n\t\t\t\tcase 'reverse':\n\t\t\t\t\treturn null;\n\t\t\t\tcase 'pop':\n\t\t\t\t\tif ( array.length ) {\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tarray.length - 1,\n\t\t\t\t\t\t\t1\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\tcase 'push':\n\t\t\t\t\treturn [\n\t\t\t\t\t\tarray.length,\n\t\t\t\t\t\t0\n\t\t\t\t\t].concat( args );\n\t\t\t\tcase 'shift':\n\t\t\t\t\treturn [\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t1\n\t\t\t\t\t];\n\t\t\t\tcase 'unshift':\n\t\t\t\t\treturn [\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0\n\t\t\t\t\t].concat( args );\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* Ractive/prototype/shared/makeArrayMethod.js */\n\tvar Ractive$shared_makeArrayMethod = function( isArray, runloop, getNewIndices ) {\n\n\t\tvar arrayProto = Array.prototype;\n\t\treturn function( methodName ) {\n\t\t\treturn function( keypath ) {\n\t\t\t\tvar SLICE$0 = Array.prototype.slice;\n\t\t\t\tvar args = SLICE$0.call( arguments, 1 );\n\t\t\t\tvar array, newIndices = [],\n\t\t\t\t\tlen, promise, result;\n\t\t\t\tarray = this.get( keypath );\n\t\t\t\tlen = array.length;\n\t\t\t\tif ( !isArray( array ) ) {\n\t\t\t\t\tthrow new Error( 'Called ractive.' + methodName + '(\\'' + keypath + '\\'), but \\'' + keypath + '\\' does not refer to an array' );\n\t\t\t\t}\n\t\t\t\tnewIndices = getNewIndices( array, methodName, args );\n\t\t\t\tresult = arrayProto[ methodName ].apply( array, args );\n\t\t\t\tpromise = runloop.start( this, true ).then( function() {\n\t\t\t\t\treturn result;\n\t\t\t\t} );\n\t\t\t\tif ( !!newIndices ) {\n\t\t\t\t\tthis.viewmodel.smartUpdate( keypath, array, newIndices );\n\t\t\t\t} else {\n\t\t\t\t\tthis.viewmodel.mark( keypath );\n\t\t\t\t}\n\t\t\t\trunloop.end();\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t};\n\t}( isArray, runloop, getNewIndices );\n\n\t/* Ractive/prototype/pop.js */\n\tvar Ractive$pop = function( makeArrayMethod ) {\n\n\t\treturn makeArrayMethod( 'pop' );\n\t}( Ractive$shared_makeArrayMethod );\n\n\t/* Ractive/prototype/push.js */\n\tvar Ractive$push = function( makeArrayMethod ) {\n\n\t\treturn makeArrayMethod( 'push' );\n\t}( Ractive$shared_makeArrayMethod );\n\n\t/* global/css.js */\n\tvar global_css = function( circular, isClient, removeFromArray ) {\n\n\t\tvar css, update, runloop, styleElement, head, styleSheet, inDom, prefix = '/* Ractive.js component styles */\\n',\n\t\t\tcomponentsInPage = {},\n\t\t\tstyles = [];\n\t\tif ( !isClient ) {\n\t\t\tcss = null;\n\t\t} else {\n\t\t\tcircular.push( function() {\n\t\t\t\trunloop = circular.runloop;\n\t\t\t} );\n\t\t\tstyleElement = document.createElement( 'style' );\n\t\t\tstyleElement.type = 'text/css';\n\t\t\thead = document.getElementsByTagName( 'head' )[ 0 ];\n\t\t\tinDom = false;\n\t\t\t// Internet Exploder won't let you use styleSheet.innerHTML - we have to\n\t\t\t// use styleSheet.cssText instead\n\t\t\tstyleSheet = styleElement.styleSheet;\n\t\t\tupdate = function() {\n\t\t\t\tvar css;\n\t\t\t\tif ( styles.length ) {\n\t\t\t\t\tcss = prefix + styles.join( ' ' );\n\t\t\t\t\tif ( styleSheet ) {\n\t\t\t\t\t\tstyleSheet.cssText = css;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstyleElement.innerHTML = css;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !inDom ) {\n\t\t\t\t\t\thead.appendChild( styleElement );\n\t\t\t\t\t\tinDom = true;\n\t\t\t\t\t}\n\t\t\t\t} else if ( inDom ) {\n\t\t\t\t\thead.removeChild( styleElement );\n\t\t\t\t\tinDom = false;\n\t\t\t\t}\n\t\t\t};\n\t\t\tcss = {\n\t\t\t\tadd: function( Component ) {\n\t\t\t\t\tif ( !Component.css ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !componentsInPage[ Component._guid ] ) {\n\t\t\t\t\t\t// we create this counter so that we can in/decrement it as\n\t\t\t\t\t\t// instances are added and removed. When all components are\n\t\t\t\t\t\t// removed, the style is too\n\t\t\t\t\t\tcomponentsInPage[ Component._guid ] = 0;\n\t\t\t\t\t\tstyles.push( Component.css );\n\t\t\t\t\t\tupdate();\n\t\t\t\t\t}\n\t\t\t\t\tcomponentsInPage[ Component._guid ] += 1;\n\t\t\t\t},\n\t\t\t\tremove: function( Component ) {\n\t\t\t\t\tif ( !Component.css ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcomponentsInPage[ Component._guid ] -= 1;\n\t\t\t\t\tif ( !componentsInPage[ Component._guid ] ) {\n\t\t\t\t\t\tremoveFromArray( styles, Component.css );\n\t\t\t\t\t\trunloop.scheduleTask( update );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn css;\n\t}( circular, isClient, removeFromArray );\n\n\t/* Ractive/prototype/shared/hooks/HookQueue.js */\n\tvar Ractive$shared_hooks_HookQueue = function( Hook ) {\n\n\t\tfunction HookQueue( event ) {\n\t\t\tthis.hook = new Hook( event );\n\t\t\tthis.inProcess = {};\n\t\t\tthis.queue = {};\n\t\t}\n\t\tHookQueue.prototype = {\n\t\t\tconstructor: HookQueue,\n\t\t\tbegin: function( ractive ) {\n\t\t\t\tthis.inProcess[ ractive._guid ] = true;\n\t\t\t},\n\t\t\tend: function( ractive ) {\n\t\t\t\tvar parent = ractive._parent;\n\t\t\t\t// If this is *isn't* a child of a component that's in process,\n\t\t\t\t// it should call methods or fire at this point\n\t\t\t\tif ( !parent || !this.inProcess[ parent._guid ] ) {\n\t\t\t\t\tfire( this, ractive );\n\t\t\t\t} else {\n\t\t\t\t\tgetChildQueue( this.queue, parent ).push( ractive );\n\t\t\t\t}\n\t\t\t\tdelete this.inProcess[ ractive._guid ];\n\t\t\t}\n\t\t};\n\n\t\tfunction getChildQueue( queue, ractive ) {\n\t\t\treturn queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );\n\t\t}\n\n\t\tfunction fire( hookQueue, ractive ) {\n\t\t\tvar childQueue = getChildQueue( hookQueue.queue, ractive );\n\t\t\thookQueue.hook.fire( ractive );\n\t\t\t// queue is \"live\" because components can end up being\n\t\t\t// added while hooks fire on parents that modify data values.\n\t\t\twhile ( childQueue.length ) {\n\t\t\t\tfire( hookQueue, childQueue.shift() );\n\t\t\t}\n\t\t\tdelete hookQueue.queue[ ractive._guid ];\n\t\t}\n\t\treturn HookQueue;\n\t}( Ractive$shared_hooks_Hook );\n\n\t/* Ractive/prototype/render.js */\n\tvar Ractive$render = function( css, Hook, HookQueue, getElement, runloop ) {\n\n\t\tvar renderHook = new HookQueue( 'render' ),\n\t\t\tcompleteHook = new Hook( 'complete' );\n\t\treturn function Ractive$render( target, anchor ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar promise, instances, transitionsEnabled;\n\t\t\trenderHook.begin( this );\n\t\t\t// if `noIntro` is `true`, temporarily disable transitions\n\t\t\ttransitionsEnabled = this.transitionsEnabled;\n\t\t\tif ( this.noIntro ) {\n\t\t\t\tthis.transitionsEnabled = false;\n\t\t\t}\n\t\t\tpromise = runloop.start( this, true );\n\t\t\tif ( this.fragment.rendered ) {\n\t\t\t\tthrow new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );\n\t\t\t}\n\t\t\ttarget = getElement( target ) || this.el;\n\t\t\tanchor = getElement( anchor ) || this.anchor;\n\t\t\tthis.el = target;\n\t\t\tthis.anchor = anchor;\n\t\t\t// Add CSS, if applicable\n\t\t\tif ( this.constructor.css ) {\n\t\t\t\tcss.add( this.constructor );\n\t\t\t}\n\t\t\tif ( target ) {\n\t\t\t\tif ( !( instances = target.__ractive_instances__ ) ) {\n\t\t\t\t\ttarget.__ractive_instances__ = [ this ];\n\t\t\t\t} else {\n\t\t\t\t\tinstances.push( this );\n\t\t\t\t}\n\t\t\t\tif ( anchor ) {\n\t\t\t\t\ttarget.insertBefore( this.fragment.render(), anchor );\n\t\t\t\t} else {\n\t\t\t\t\ttarget.appendChild( this.fragment.render() );\n\t\t\t\t}\n\t\t\t}\n\t\t\trenderHook.end( this );\n\t\t\trunloop.end();\n\t\t\tthis.transitionsEnabled = transitionsEnabled;\n\t\t\t// It is now more problematic to know if the complete hook\n\t\t\t// would fire. Method checking is straight-forward, but would\n\t\t\t// also require preflighting event subscriptions. Which seems\n\t\t\t// like more work then just letting the promise happen.\n\t\t\t// But perhaps I'm wrong about that...\n\t\t\tpromise.then( function() {\n\t\t\t\treturn completeHook.fire( this$0 );\n\t\t\t} );\n\t\t\treturn promise;\n\t\t};\n\t}( global_css, Ractive$shared_hooks_Hook, Ractive$shared_hooks_HookQueue, getElement, runloop );\n\n\t/* virtualdom/Fragment/prototype/bubble.js */\n\tvar virtualdom_Fragment$bubble = function Fragment$bubble() {\n\t\tthis.dirtyValue = this.dirtyArgs = true;\n\t\tif ( this.bound && typeof this.owner.bubble === 'function' ) {\n\t\t\tthis.owner.bubble();\n\t\t}\n\t};\n\n\t/* virtualdom/Fragment/prototype/detach.js */\n\tvar virtualdom_Fragment$detach = function Fragment$detach() {\n\t\tvar docFrag;\n\t\tif ( this.items.length === 1 ) {\n\t\t\treturn this.items[ 0 ].detach();\n\t\t}\n\t\tdocFrag = document.createDocumentFragment();\n\t\tthis.items.forEach( function( item ) {\n\t\t\tvar node = item.detach();\n\t\t\t// TODO The if {...} wasn't previously required - it is now, because we're\n\t\t\t// forcibly detaching everything to reorder sections after an update. That's\n\t\t\t// a non-ideal brute force approach, implemented to get all the tests to pass\n\t\t\t// - as soon as it's replaced with something more elegant, this should\n\t\t\t// revert to `docFrag.appendChild( item.detach() )`\n\t\t\tif ( node ) {\n\t\t\t\tdocFrag.appendChild( node );\n\t\t\t}\n\t\t} );\n\t\treturn docFrag;\n\t};\n\n\t/* virtualdom/Fragment/prototype/find.js */\n\tvar virtualdom_Fragment$find = function Fragment$find( selector ) {\n\t\tvar i, len, item, queryResult;\n\t\tif ( this.items ) {\n\t\t\tlen = this.items.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\titem = this.items[ i ];\n\t\t\t\tif ( item.find && ( queryResult = item.find( selector ) ) ) {\n\t\t\t\t\treturn queryResult;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n\n\t/* virtualdom/Fragment/prototype/findAll.js */\n\tvar virtualdom_Fragment$findAll = function Fragment$findAll( selector, query ) {\n\t\tvar i, len, item;\n\t\tif ( this.items ) {\n\t\t\tlen = this.items.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\titem = this.items[ i ];\n\t\t\t\tif ( item.findAll ) {\n\t\t\t\t\titem.findAll( selector, query );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn query;\n\t};\n\n\t/* virtualdom/Fragment/prototype/findAllComponents.js */\n\tvar virtualdom_Fragment$findAllComponents = function Fragment$findAllComponents( selector, query ) {\n\t\tvar i, len, item;\n\t\tif ( this.items ) {\n\t\t\tlen = this.items.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\titem = this.items[ i ];\n\t\t\t\tif ( item.findAllComponents ) {\n\t\t\t\t\titem.findAllComponents( selector, query );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn query;\n\t};\n\n\t/* virtualdom/Fragment/prototype/findComponent.js */\n\tvar virtualdom_Fragment$findComponent = function Fragment$findComponent( selector ) {\n\t\tvar len, i, item, queryResult;\n\t\tif ( this.items ) {\n\t\t\tlen = this.items.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\titem = this.items[ i ];\n\t\t\t\tif ( item.findComponent && ( queryResult = item.findComponent( selector ) ) ) {\n\t\t\t\t\treturn queryResult;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n\n\t/* virtualdom/Fragment/prototype/findNextNode.js */\n\tvar virtualdom_Fragment$findNextNode = function Fragment$findNextNode( item ) {\n\t\tvar index = item.index,\n\t\t\tnode;\n\t\tif ( this.items[ index + 1 ] ) {\n\t\t\tnode = this.items[ index + 1 ].firstNode();\n\t\t} else if ( this.owner === this.root ) {\n\t\t\tif ( !this.owner.component ) {\n\t\t\t\t// TODO but something else could have been appended to\n\t\t\t\t// this.root.el, no?\n\t\t\t\tnode = null;\n\t\t\t} else {\n\t\t\t\tnode = this.owner.component.findNextNode();\n\t\t\t}\n\t\t} else {\n\t\t\tnode = this.owner.findNextNode( this );\n\t\t}\n\t\treturn node;\n\t};\n\n\t/* virtualdom/Fragment/prototype/firstNode.js */\n\tvar virtualdom_Fragment$firstNode = function Fragment$firstNode() {\n\t\tif ( this.items && this.items[ 0 ] ) {\n\t\t\treturn this.items[ 0 ].firstNode();\n\t\t}\n\t\treturn null;\n\t};\n\n\t/* virtualdom/Fragment/prototype/getNode.js */\n\tvar virtualdom_Fragment$getNode = function Fragment$getNode() {\n\t\tvar fragment = this;\n\t\tdo {\n\t\t\tif ( fragment.pElement ) {\n\t\t\t\treturn fragment.pElement.node;\n\t\t\t}\n\t\t} while ( fragment = fragment.parent );\n\t\treturn this.root.detached || this.root.el;\n\t};\n\n\t/* virtualdom/Fragment/prototype/getValue.js */\n\tvar virtualdom_Fragment$getValue = function( parseJSON ) {\n\n\t\tvar __export;\n\t\tvar empty = {};\n\t\t__export = function Fragment$getValue() {\n\t\t\tvar options = arguments[ 0 ];\n\t\t\tif ( options === void 0 )\n\t\t\t\toptions = empty;\n\t\t\tvar asArgs, values, source, parsed, cachedResult, dirtyFlag, result;\n\t\t\tasArgs = options.args;\n\t\t\tcachedResult = asArgs ? 'argsList' : 'value';\n\t\t\tdirtyFlag = asArgs ? 'dirtyArgs' : 'dirtyValue';\n\t\t\tif ( this[ dirtyFlag ] ) {\n\t\t\t\tsource = processItems( this.items, values = {}, this.root._guid );\n\t\t\t\tparsed = parseJSON( asArgs ? '[' + source + ']' : source, values );\n\t\t\t\tif ( !parsed ) {\n\t\t\t\t\tresult = asArgs ? [ this.toString() ] : this.toString();\n\t\t\t\t} else {\n\t\t\t\t\tresult = parsed.value;\n\t\t\t\t}\n\t\t\t\tthis[ cachedResult ] = result;\n\t\t\t\tthis[ dirtyFlag ] = false;\n\t\t\t}\n\t\t\treturn this[ cachedResult ];\n\t\t};\n\n\t\tfunction processItems( items, values, guid, counter ) {\n\t\t\tcounter = counter || 0;\n\t\t\treturn items.map( function( item ) {\n\t\t\t\tvar placeholderId, wrapped, value;\n\t\t\t\tif ( item.text ) {\n\t\t\t\t\treturn item.text;\n\t\t\t\t}\n\t\t\t\tif ( item.fragments ) {\n\t\t\t\t\treturn item.fragments.map( function( fragment ) {\n\t\t\t\t\t\treturn processItems( fragment.items, values, guid, counter );\n\t\t\t\t\t} ).join( '' );\n\t\t\t\t}\n\t\t\t\tplaceholderId = guid + '-' + counter++;\n\t\t\t\tif ( wrapped = item.root.viewmodel.wrapped[ item.keypath ] ) {\n\t\t\t\t\tvalue = wrapped.value;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = item.getValue();\n\t\t\t\t}\n\t\t\t\tvalues[ placeholderId ] = value;\n\t\t\t\treturn '${' + placeholderId + '}';\n\t\t\t} ).join( '' );\n\t\t}\n\t\treturn __export;\n\t}( parseJSON );\n\n\t/* utils/escapeHtml.js */\n\tvar escapeHtml = function() {\n\n\t\tvar lessThan = /</g,\n\t\t\tgreaterThan = />/g;\n\t\treturn function escapeHtml( str ) {\n\t\t\treturn str.replace( lessThan, '&lt;' ).replace( greaterThan, '&gt;' );\n\t\t};\n\t}();\n\n\t/* utils/detachNode.js */\n\tvar detachNode = function detachNode( node ) {\n\t\tif ( node && node.parentNode ) {\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t\treturn node;\n\t};\n\n\t/* virtualdom/items/shared/detach.js */\n\tvar detach = function( detachNode ) {\n\n\t\treturn function() {\n\t\t\treturn detachNode( this.node );\n\t\t};\n\t}( detachNode );\n\n\t/* virtualdom/items/Text.js */\n\tvar Text = function( types, escapeHtml, detach, decodeCharacterReferences ) {\n\n\t\tvar Text = function( options ) {\n\t\t\tthis.type = types.TEXT;\n\t\t\tthis.text = options.template;\n\t\t};\n\t\tText.prototype = {\n\t\t\tdetach: detach,\n\t\t\tfirstNode: function() {\n\t\t\t\treturn this.node;\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tif ( !this.node ) {\n\t\t\t\t\tthis.node = document.createTextNode( decodeCharacterReferences( this.text ) );\n\t\t\t\t}\n\t\t\t\treturn this.node;\n\t\t\t},\n\t\t\ttoString: function( escape ) {\n\t\t\t\treturn escape ? escapeHtml( this.text ) : this.text;\n\t\t\t},\n\t\t\tunrender: function( shouldDestroy ) {\n\t\t\t\tif ( shouldDestroy ) {\n\t\t\t\t\treturn this.detach();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn Text;\n\t}( types, escapeHtml, detach, decodeCharacterReferences );\n\n\t/* virtualdom/items/shared/unbind.js */\n\tvar unbind = function( runloop ) {\n\n\t\treturn function unbind() {\n\t\t\tif ( !this.keypath ) {\n\t\t\t\t// this was on the 'unresolved' list, we need to remove it\n\t\t\t\trunloop.removeUnresolved( this );\n\t\t\t} else {\n\t\t\t\t// this was registered as a dependant\n\t\t\t\tthis.root.viewmodel.unregister( this.keypath, this );\n\t\t\t}\n\t\t\tif ( this.resolver ) {\n\t\t\t\tthis.resolver.unbind();\n\t\t\t}\n\t\t};\n\t}( runloop );\n\n\t/* virtualdom/items/shared/Mustache/getValue.js */\n\tvar getValue = function Mustache$getValue() {\n\t\treturn this.value;\n\t};\n\n\t/* shared/Unresolved.js */\n\tvar Unresolved = function( runloop ) {\n\n\t\tvar Unresolved = function( ractive, ref, parentFragment, callback ) {\n\t\t\tthis.root = ractive;\n\t\t\tthis.ref = ref;\n\t\t\tthis.parentFragment = parentFragment;\n\t\t\tthis.resolve = callback;\n\t\t\trunloop.addUnresolved( this );\n\t\t};\n\t\tUnresolved.prototype = {\n\t\t\tunbind: function() {\n\t\t\t\trunloop.removeUnresolved( this );\n\t\t\t}\n\t\t};\n\t\treturn Unresolved;\n\t}( runloop );\n\n\t/* virtualdom/items/shared/utils/startsWithKeypath.js */\n\tvar startsWithKeypath = function startsWithKeypath( target, keypath ) {\n\t\treturn target && keypath && target.substr( 0, keypath.length + 1 ) === keypath + '.';\n\t};\n\n\t/* virtualdom/items/shared/utils/getNewKeypath.js */\n\tvar getNewKeypath = function( startsWithKeypath ) {\n\n\t\treturn function getNewKeypath( targetKeypath, oldKeypath, newKeypath ) {\n\t\t\t// exact match\n\t\t\tif ( targetKeypath === oldKeypath ) {\n\t\t\t\treturn newKeypath !== undefined ? newKeypath : null;\n\t\t\t}\n\t\t\t// partial match based on leading keypath segments\n\t\t\tif ( startsWithKeypath( targetKeypath, oldKeypath ) ) {\n\t\t\t\treturn newKeypath === null ? newKeypath : targetKeypath.replace( oldKeypath + '.', newKeypath + '.' );\n\t\t\t}\n\t\t};\n\t}( startsWithKeypath );\n\n\t/* shared/getFunctionFromString.js */\n\tvar getFunctionFromString = function() {\n\n\t\tvar cache = {};\n\t\treturn function getFunctionFromString( str, i ) {\n\t\t\tvar fn, args;\n\t\t\tif ( cache[ str ] ) {\n\t\t\t\treturn cache[ str ];\n\t\t\t}\n\t\t\targs = [];\n\t\t\twhile ( i-- ) {\n\t\t\t\targs[ i ] = '_' + i;\n\t\t\t}\n\t\t\tfn = new Function( args.join( ',' ), 'return(' + str + ')' );\n\t\t\tcache[ str ] = fn;\n\t\t\treturn fn;\n\t\t};\n\t}();\n\n\t/* virtualdom/items/shared/Resolvers/ExpressionResolver.js */\n\tvar ExpressionResolver = function( removeFromArray, defineProperty, resolveRef, Unresolved, getFunctionFromString, getNewKeypath ) {\n\n\t\tvar __export;\n\t\tvar ExpressionResolver, bind = Function.prototype.bind;\n\t\tExpressionResolver = function( owner, parentFragment, expression, callback ) {\n\t\t\tvar expressionResolver = this,\n\t\t\t\tractive, indexRefs, args;\n\t\t\tractive = owner.root;\n\t\t\tthis.root = ractive;\n\t\t\tthis.callback = callback;\n\t\t\tthis.owner = owner;\n\t\t\tthis.str = expression.s;\n\t\t\tthis.args = args = [];\n\t\t\tthis.unresolved = [];\n\t\t\tthis.pending = 0;\n\t\t\tindexRefs = parentFragment.indexRefs;\n\t\t\t// some expressions don't have references. edge case, but, yeah.\n\t\t\tif ( !expression.r || !expression.r.length ) {\n\t\t\t\tthis.resolved = this.ready = true;\n\t\t\t\tthis.bubble();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Create resolvers for each reference\n\t\t\texpression.r.forEach( function( reference, i ) {\n\t\t\t\tvar index, keypath, unresolved;\n\t\t\t\t// Is this an index reference?\n\t\t\t\tif ( indexRefs && ( index = indexRefs[ reference ] ) !== undefined ) {\n\t\t\t\t\targs[ i ] = {\n\t\t\t\t\t\tindexRef: reference,\n\t\t\t\t\t\tvalue: index\n\t\t\t\t\t};\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Can we resolve it immediately?\n\t\t\t\tif ( keypath = resolveRef( ractive, reference, parentFragment ) ) {\n\t\t\t\t\targs[ i ] = {\n\t\t\t\t\t\tkeypath: keypath\n\t\t\t\t\t};\n\t\t\t\t\treturn;\n\t\t\t\t} else if ( reference === '.' ) {\n\t\t\t\t\t// special case of context reference to root\n\t\t\t\t\targs[ i ] = {\n\t\t\t\t\t\t'': ''\n\t\t\t\t\t};\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Couldn't resolve yet\n\t\t\t\targs[ i ] = null;\n\t\t\t\texpressionResolver.pending += 1;\n\t\t\t\tunresolved = new Unresolved( ractive, reference, parentFragment, function( keypath ) {\n\t\t\t\t\texpressionResolver.resolve( i, keypath );\n\t\t\t\t\tremoveFromArray( expressionResolver.unresolved, unresolved );\n\t\t\t\t} );\n\t\t\t\texpressionResolver.unresolved.push( unresolved );\n\t\t\t} );\n\t\t\tthis.ready = true;\n\t\t\tthis.bubble();\n\t\t};\n\t\tExpressionResolver.prototype = {\n\t\t\tbubble: function() {\n\t\t\t\tif ( !this.ready ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.uniqueString = getUniqueString( this.str, this.args );\n\t\t\t\tthis.keypath = getKeypath( this.uniqueString );\n\t\t\t\tthis.createEvaluator();\n\t\t\t\tthis.callback( this.keypath );\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tvar unresolved;\n\t\t\t\twhile ( unresolved = this.unresolved.pop() ) {\n\t\t\t\t\tunresolved.unbind();\n\t\t\t\t}\n\t\t\t},\n\t\t\tresolve: function( index, keypath ) {\n\t\t\t\tthis.args[ index ] = {\n\t\t\t\t\tkeypath: keypath\n\t\t\t\t};\n\t\t\t\tthis.bubble();\n\t\t\t\t// when all references have been resolved, we can flag the entire expression\n\t\t\t\t// as having been resolved\n\t\t\t\tthis.resolved = !--this.pending;\n\t\t\t},\n\t\t\tcreateEvaluator: function() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar self = this,\n\t\t\t\t\tcomputation, valueGetters, signature, keypaths = [],\n\t\t\t\t\ti, arg, fn;\n\t\t\t\tcomputation = this.root.viewmodel.computations[ this.keypath ];\n\t\t\t\t// only if it doesn't exist yet!\n\t\t\t\tif ( !computation ) {\n\t\t\t\t\ti = this.args.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\targ = this.args[ i ];\n\t\t\t\t\t\tif ( arg && arg.keypath ) {\n\t\t\t\t\t\t\tkeypaths.push( arg.keypath );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfn = getFunctionFromString( this.str, this.args.length );\n\t\t\t\t\tvalueGetters = this.args.map( function( arg ) {\n\t\t\t\t\t\tvar keypath, value;\n\t\t\t\t\t\tif ( !arg ) {\n\t\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( arg.indexRef ) {\n\t\t\t\t\t\t\tvalue = arg.value;\n\t\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkeypath = arg.keypath;\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar value = this$0.root.viewmodel.get( keypath );\n\t\t\t\t\t\t\tif ( typeof value === 'function' ) {\n\t\t\t\t\t\t\t\tvalue = wrapFunction( value, self.root );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t};\n\t\t\t\t\t} );\n\t\t\t\t\tsignature = {\n\t\t\t\t\t\tdeps: keypaths,\n\t\t\t\t\t\tget: function() {\n\t\t\t\t\t\t\tvar args = valueGetters.map( call );\n\t\t\t\t\t\t\treturn fn.apply( null, args );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tcomputation = this.root.viewmodel.compute( this.keypath, signature );\n\t\t\t\t} else {\n\t\t\t\t\tthis.root.viewmodel.mark( this.keypath );\n\t\t\t\t}\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tvar changed;\n\t\t\t\tthis.args.forEach( function( arg ) {\n\t\t\t\t\tvar changedKeypath;\n\t\t\t\t\tif ( !arg )\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif ( arg.keypath && ( changedKeypath = getNewKeypath( arg.keypath, oldKeypath, newKeypath ) ) ) {\n\t\t\t\t\t\targ.keypath = changedKeypath;\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t} else if ( arg.indexRef && arg.indexRef === indexRef ) {\n\t\t\t\t\t\targ.value = newIndex;\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tif ( changed ) {\n\t\t\t\t\tthis.bubble();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t__export = ExpressionResolver;\n\n\t\tfunction call( value ) {\n\t\t\treturn value.call();\n\t\t}\n\n\t\tfunction getUniqueString( str, args ) {\n\t\t\t// get string that is unique to this expression\n\t\t\treturn str.replace( /_([0-9]+)/g, function( match, $1 ) {\n\t\t\t\tvar arg = args[ $1 ];\n\t\t\t\tif ( !arg )\n\t\t\t\t\treturn 'undefined';\n\t\t\t\tif ( arg.indexRef )\n\t\t\t\t\treturn arg.value;\n\t\t\t\treturn arg.keypath;\n\t\t\t} );\n\t\t}\n\n\t\tfunction getKeypath( uniqueString ) {\n\t\t\t// Sanitize by removing any periods or square brackets. Otherwise\n\t\t\t// we can't split the keypath into keys!\n\t\t\treturn '${' + uniqueString.replace( /[\\.\\[\\]]/g, '-' ) + '}';\n\t\t}\n\n\t\tfunction wrapFunction( fn, ractive ) {\n\t\t\tvar wrapped, prop, key;\n\t\t\tif ( fn._noWrap ) {\n\t\t\t\treturn fn;\n\t\t\t}\n\t\t\tprop = '__ractive_' + ractive._guid;\n\t\t\twrapped = fn[ prop ];\n\t\t\tif ( wrapped ) {\n\t\t\t\treturn wrapped;\n\t\t\t} else if ( /this/.test( fn.toString() ) ) {\n\t\t\t\tdefineProperty( fn, prop, {\n\t\t\t\t\tvalue: bind.call( fn, ractive )\n\t\t\t\t} );\n\t\t\t\t// Add properties/methods to wrapped function\n\t\t\t\tfor ( key in fn ) {\n\t\t\t\t\tif ( fn.hasOwnProperty( key ) ) {\n\t\t\t\t\t\tfn[ prop ][ key ] = fn[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn fn[ prop ];\n\t\t\t}\n\t\t\tdefineProperty( fn, '__ractive_nowrap', {\n\t\t\t\tvalue: fn\n\t\t\t} );\n\t\t\treturn fn.__ractive_nowrap;\n\t\t}\n\t\treturn __export;\n\t}( removeFromArray, defineProperty, resolveRef, Unresolved, getFunctionFromString, getNewKeypath, legacy );\n\n\t/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js */\n\tvar MemberResolver = function( types, resolveRef, Unresolved, getNewKeypath, ExpressionResolver ) {\n\n\t\tvar MemberResolver = function( template, resolver, parentFragment ) {\n\t\t\tvar member = this,\n\t\t\t\tref, indexRefs, index, ractive, keypath;\n\t\t\tmember.resolver = resolver;\n\t\t\tmember.root = resolver.root;\n\t\t\tmember.viewmodel = resolver.root.viewmodel;\n\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\tmember.value = template;\n\t\t\t} else if ( template.t === types.REFERENCE ) {\n\t\t\t\tref = member.ref = template.n;\n\t\t\t\t// If it's an index reference, our job is simple\n\t\t\t\tif ( ( indexRefs = parentFragment.indexRefs ) && ( index = indexRefs[ ref ] ) !== undefined ) {\n\t\t\t\t\tmember.indexRef = ref;\n\t\t\t\t\tmember.value = index;\n\t\t\t\t} else {\n\t\t\t\t\tractive = resolver.root;\n\t\t\t\t\t// Can we resolve the reference immediately?\n\t\t\t\t\tif ( keypath = resolveRef( ractive, ref, parentFragment ) ) {\n\t\t\t\t\t\tmember.resolve( keypath );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Couldn't resolve yet\n\t\t\t\t\t\tmember.unresolved = new Unresolved( ractive, ref, parentFragment, function( keypath ) {\n\t\t\t\t\t\t\tmember.unresolved = null;\n\t\t\t\t\t\t\tmember.resolve( keypath );\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnew ExpressionResolver( resolver, parentFragment, template, function( keypath ) {\n\t\t\t\t\tmember.resolve( keypath );\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\t\tMemberResolver.prototype = {\n\t\t\tresolve: function( keypath ) {\n\t\t\t\tthis.keypath = keypath;\n\t\t\t\tthis.value = this.viewmodel.get( keypath );\n\t\t\t\tthis.bind();\n\t\t\t\tthis.resolver.bubble();\n\t\t\t},\n\t\t\tbind: function() {\n\t\t\t\tthis.viewmodel.register( this.keypath, this );\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tvar keypath;\n\t\t\t\tif ( indexRef && this.indexRef === indexRef ) {\n\t\t\t\t\tif ( newIndex !== this.value ) {\n\t\t\t\t\t\tthis.value = newIndex;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if ( this.keypath && ( keypath = getNewKeypath( this.keypath, oldKeypath, newKeypath ) ) ) {\n\t\t\t\t\tthis.unbind();\n\t\t\t\t\tthis.keypath = keypath;\n\t\t\t\t\tthis.value = this.root.viewmodel.get( keypath );\n\t\t\t\t\tthis.bind();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetValue: function( value ) {\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.resolver.bubble();\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tif ( this.keypath ) {\n\t\t\t\t\tthis.root.viewmodel.unregister( this.keypath, this );\n\t\t\t\t}\n\t\t\t\tif ( this.unresolved ) {\n\t\t\t\t\tthis.unresolved.unbind();\n\t\t\t\t}\n\t\t\t},\n\t\t\tforceResolution: function() {\n\t\t\t\tif ( this.unresolved ) {\n\t\t\t\t\tthis.unresolved.unbind();\n\t\t\t\t\tthis.unresolved = null;\n\t\t\t\t\tthis.keypath = this.ref;\n\t\t\t\t\tthis.value = this.viewmodel.get( this.ref );\n\t\t\t\t\tthis.bind();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn MemberResolver;\n\t}( types, resolveRef, Unresolved, getNewKeypath, ExpressionResolver );\n\n\t/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js */\n\tvar ReferenceExpressionResolver = function( resolveRef, Unresolved, MemberResolver ) {\n\n\t\tvar ReferenceExpressionResolver = function( mustache, template, callback ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar resolver = this,\n\t\t\t\tractive, ref, keypath, parentFragment;\n\t\t\tparentFragment = mustache.parentFragment;\n\t\t\tresolver.root = ractive = mustache.root;\n\t\t\tresolver.mustache = mustache;\n\t\t\tresolver.ref = ref = template.r;\n\t\t\tresolver.callback = callback;\n\t\t\tresolver.unresolved = [];\n\t\t\t// Find base keypath\n\t\t\tif ( keypath = resolveRef( ractive, ref, parentFragment ) ) {\n\t\t\t\tresolver.base = keypath;\n\t\t\t} else {\n\t\t\t\tresolver.baseResolver = new Unresolved( ractive, ref, parentFragment, function( keypath ) {\n\t\t\t\t\tresolver.base = keypath;\n\t\t\t\t\tresolver.baseResolver = null;\n\t\t\t\t\tresolver.bubble();\n\t\t\t\t} );\n\t\t\t}\n\t\t\t// Find values for members, or mark them as unresolved\n\t\t\tresolver.members = template.m.map( function( template ) {\n\t\t\t\treturn new MemberResolver( template, this$0, parentFragment );\n\t\t\t} );\n\t\t\tresolver.ready = true;\n\t\t\tresolver.bubble();\n\t\t};\n\t\tReferenceExpressionResolver.prototype = {\n\t\t\tgetKeypath: function() {\n\t\t\t\tvar values = this.members.map( getValue );\n\t\t\t\tif ( !values.every( isDefined ) || this.baseResolver ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn this.base + '.' + values.join( '.' );\n\t\t\t},\n\t\t\tbubble: function() {\n\t\t\t\tif ( !this.ready || this.baseResolver ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.callback( this.getKeypath() );\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tthis.members.forEach( unbind );\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tvar changed;\n\t\t\t\tthis.members.forEach( function( members ) {\n\t\t\t\t\tif ( members.rebind( indexRef, newIndex, oldKeypath, newKeypath ) ) {\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tif ( changed ) {\n\t\t\t\t\tthis.bubble();\n\t\t\t\t}\n\t\t\t},\n\t\t\tforceResolution: function() {\n\t\t\t\tif ( this.baseResolver ) {\n\t\t\t\t\tthis.base = this.ref;\n\t\t\t\t\tthis.baseResolver.unbind();\n\t\t\t\t\tthis.baseResolver = null;\n\t\t\t\t}\n\t\t\t\tthis.members.forEach( function( m ) {\n\t\t\t\t\treturn m.forceResolution();\n\t\t\t\t} );\n\t\t\t\tthis.bubble();\n\t\t\t}\n\t\t};\n\n\t\tfunction getValue( member ) {\n\t\t\treturn member.value;\n\t\t}\n\n\t\tfunction isDefined( value ) {\n\t\t\treturn value != undefined;\n\t\t}\n\n\t\tfunction unbind( member ) {\n\t\t\tmember.unbind();\n\t\t}\n\t\treturn ReferenceExpressionResolver;\n\t}( resolveRef, Unresolved, MemberResolver );\n\n\t/* virtualdom/items/shared/Mustache/initialise.js */\n\tvar initialise = function( types, runloop, resolveRef, ReferenceExpressionResolver, ExpressionResolver ) {\n\n\t\treturn function Mustache$init( mustache, options ) {\n\t\t\tvar ref, keypath, indexRefs, index, parentFragment, template;\n\t\t\tparentFragment = options.parentFragment;\n\t\t\ttemplate = options.template;\n\t\t\tmustache.root = parentFragment.root;\n\t\t\tmustache.parentFragment = parentFragment;\n\t\t\tmustache.pElement = parentFragment.pElement;\n\t\t\tmustache.template = options.template;\n\t\t\tmustache.index = options.index || 0;\n\t\t\tmustache.isStatic = options.template.s;\n\t\t\tmustache.type = options.template.t;\n\t\t\t// if this is a simple mustache, with a reference, we just need to resolve\n\t\t\t// the reference to a keypath\n\t\t\tif ( ref = template.r ) {\n\t\t\t\tindexRefs = parentFragment.indexRefs;\n\t\t\t\tif ( indexRefs && ( index = indexRefs[ ref ] ) !== undefined ) {\n\t\t\t\t\tmustache.indexRef = ref;\n\t\t\t\t\tmustache.setValue( index );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tkeypath = resolveRef( mustache.root, ref, mustache.parentFragment );\n\t\t\t\tif ( keypath !== undefined ) {\n\t\t\t\t\tmustache.resolve( keypath );\n\t\t\t\t} else {\n\t\t\t\t\tmustache.ref = ref;\n\t\t\t\t\trunloop.addUnresolved( mustache );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if it's an expression, we have a bit more work to do\n\t\t\tif ( options.template.x ) {\n\t\t\t\tmustache.resolver = new ExpressionResolver( mustache, parentFragment, options.template.x, resolveAndRebindChildren );\n\t\t\t}\n\t\t\tif ( options.template.rx ) {\n\t\t\t\tmustache.resolver = new ReferenceExpressionResolver( mustache, options.template.rx, resolveAndRebindChildren );\n\t\t\t}\n\t\t\t// Special case - inverted sections\n\t\t\tif ( mustache.template.n === types.SECTION_UNLESS && !mustache.hasOwnProperty( 'value' ) ) {\n\t\t\t\tmustache.setValue( undefined );\n\t\t\t}\n\n\t\t\tfunction resolveAndRebindChildren( newKeypath ) {\n\t\t\t\tvar oldKeypath = mustache.keypath;\n\t\t\t\tif ( newKeypath !== oldKeypath ) {\n\t\t\t\t\tmustache.resolve( newKeypath );\n\t\t\t\t\tif ( oldKeypath !== undefined ) {\n\t\t\t\t\t\tmustache.fragments && mustache.fragments.forEach( function( f ) {\n\t\t\t\t\t\t\tf.rebind( null, null, oldKeypath, newKeypath );\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}( types, runloop, resolveRef, ReferenceExpressionResolver, ExpressionResolver );\n\n\t/* virtualdom/items/shared/Mustache/resolve.js */\n\tvar resolve = function Mustache$resolve( keypath ) {\n\t\tvar wasResolved, value, twowayBinding;\n\t\t// If we resolved previously, we need to unregister\n\t\tif ( this.keypath != undefined ) {\n\t\t\t// undefined or null\n\t\t\tthis.root.viewmodel.unregister( this.keypath, this );\n\t\t\twasResolved = true;\n\t\t}\n\t\tthis.keypath = keypath;\n\t\t// If the new keypath exists, we need to register\n\t\t// with the viewmodel\n\t\tif ( keypath != undefined ) {\n\t\t\t// undefined or null\n\t\t\tvalue = this.root.viewmodel.get( keypath );\n\t\t\tthis.root.viewmodel.register( keypath, this );\n\t\t}\n\t\t// Either way we need to queue up a render (`value`\n\t\t// will be `undefined` if there's no keypath)\n\t\tthis.setValue( value );\n\t\t// Two-way bindings need to point to their new target keypath\n\t\tif ( wasResolved && ( twowayBinding = this.twowayBinding ) ) {\n\t\t\ttwowayBinding.rebound();\n\t\t}\n\t};\n\n\t/* virtualdom/items/shared/Mustache/rebind.js */\n\tvar rebind = function( getNewKeypath ) {\n\n\t\treturn function Mustache$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\tvar keypath;\n\t\t\t// Children first\n\t\t\tif ( this.fragments ) {\n\t\t\t\tthis.fragments.forEach( function( f ) {\n\t\t\t\t\treturn f.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t} );\n\t\t\t}\n\t\t\t// Expression mustache?\n\t\t\tif ( this.resolver ) {\n\t\t\t\tthis.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t}\n\t\t\t// Normal keypath mustache or reference expression?\n\t\t\tif ( this.keypath !== undefined ) {\n\t\t\t\tkeypath = getNewKeypath( this.keypath, oldKeypath, newKeypath );\n\t\t\t\t// was a new keypath created?\n\t\t\t\tif ( keypath !== undefined ) {\n\t\t\t\t\t// resolve it\n\t\t\t\t\tthis.resolve( keypath );\n\t\t\t\t}\n\t\t\t} else if ( indexRef !== undefined && this.indexRef === indexRef ) {\n\t\t\t\tthis.setValue( newIndex );\n\t\t\t}\n\t\t};\n\t}( getNewKeypath );\n\n\t/* virtualdom/items/shared/Mustache/_Mustache.js */\n\tvar Mustache = function( getValue, init, resolve, rebind ) {\n\n\t\treturn {\n\t\t\tgetValue: getValue,\n\t\t\tinit: init,\n\t\t\tresolve: resolve,\n\t\t\trebind: rebind\n\t\t};\n\t}( getValue, initialise, resolve, rebind );\n\n\t/* virtualdom/items/Interpolator.js */\n\tvar Interpolator = function( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach ) {\n\n\t\tvar Interpolator = function( options ) {\n\t\t\tthis.type = types.INTERPOLATOR;\n\t\t\tMustache.init( this, options );\n\t\t};\n\t\tInterpolator.prototype = {\n\t\t\tupdate: function() {\n\t\t\t\tthis.node.data = this.value == undefined ? '' : this.value;\n\t\t\t},\n\t\t\tresolve: Mustache.resolve,\n\t\t\trebind: Mustache.rebind,\n\t\t\tdetach: detach,\n\t\t\tunbind: unbind,\n\t\t\trender: function() {\n\t\t\t\tif ( !this.node ) {\n\t\t\t\t\tthis.node = document.createTextNode( this.value != undefined ? this.value : '' );\n\t\t\t\t}\n\t\t\t\treturn this.node;\n\t\t\t},\n\t\t\tunrender: function( shouldDestroy ) {\n\t\t\t\tif ( shouldDestroy ) {\n\t\t\t\t\tdetachNode( this.node );\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetValue: Mustache.getValue,\n\t\t\t// TEMP\n\t\t\tsetValue: function( value ) {\n\t\t\t\tvar wrapper;\n\t\t\t\t// TODO is there a better way to approach this?\n\t\t\t\tif ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {\n\t\t\t\t\tvalue = wrapper.get();\n\t\t\t\t}\n\t\t\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\tthis.parentFragment.bubble();\n\t\t\t\t\tif ( this.node ) {\n\t\t\t\t\t\trunloop.addView( this );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tfirstNode: function() {\n\t\t\t\treturn this.node;\n\t\t\t},\n\t\t\ttoString: function( escape ) {\n\t\t\t\tvar string = this.value != undefined ? '' + this.value : '';\n\t\t\t\treturn escape ? escapeHtml( string ) : string;\n\t\t\t}\n\t\t};\n\t\treturn Interpolator;\n\t}( types, runloop, escapeHtml, detachNode, isEqual, unbind, Mustache, detach );\n\n\t/* virtualdom/items/Section/prototype/bubble.js */\n\tvar virtualdom_items_Section$bubble = function Section$bubble() {\n\t\tthis.parentFragment.bubble();\n\t};\n\n\t/* virtualdom/items/Section/prototype/detach.js */\n\tvar virtualdom_items_Section$detach = function Section$detach() {\n\t\tvar docFrag;\n\t\tif ( this.fragments.length === 1 ) {\n\t\t\treturn this.fragments[ 0 ].detach();\n\t\t}\n\t\tdocFrag = document.createDocumentFragment();\n\t\tthis.fragments.forEach( function( item ) {\n\t\t\tdocFrag.appendChild( item.detach() );\n\t\t} );\n\t\treturn docFrag;\n\t};\n\n\t/* virtualdom/items/Section/prototype/find.js */\n\tvar virtualdom_items_Section$find = function Section$find( selector ) {\n\t\tvar i, len, queryResult;\n\t\tlen = this.fragments.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tif ( queryResult = this.fragments[ i ].find( selector ) ) {\n\t\t\t\treturn queryResult;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\n\t/* virtualdom/items/Section/prototype/findAll.js */\n\tvar virtualdom_items_Section$findAll = function Section$findAll( selector, query ) {\n\t\tvar i, len;\n\t\tlen = this.fragments.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tthis.fragments[ i ].findAll( selector, query );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Section/prototype/findAllComponents.js */\n\tvar virtualdom_items_Section$findAllComponents = function Section$findAllComponents( selector, query ) {\n\t\tvar i, len;\n\t\tlen = this.fragments.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tthis.fragments[ i ].findAllComponents( selector, query );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Section/prototype/findComponent.js */\n\tvar virtualdom_items_Section$findComponent = function Section$findComponent( selector ) {\n\t\tvar i, len, queryResult;\n\t\tlen = this.fragments.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tif ( queryResult = this.fragments[ i ].findComponent( selector ) ) {\n\t\t\t\treturn queryResult;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\n\t/* virtualdom/items/Section/prototype/findNextNode.js */\n\tvar virtualdom_items_Section$findNextNode = function Section$findNextNode( fragment ) {\n\t\tif ( this.fragments[ fragment.index + 1 ] ) {\n\t\t\treturn this.fragments[ fragment.index + 1 ].firstNode();\n\t\t}\n\t\treturn this.parentFragment.findNextNode( this );\n\t};\n\n\t/* virtualdom/items/Section/prototype/firstNode.js */\n\tvar virtualdom_items_Section$firstNode = function Section$firstNode() {\n\t\tvar len, i, node;\n\t\tif ( len = this.fragments.length ) {\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tif ( node = this.fragments[ i ].firstNode() ) {\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.parentFragment.findNextNode( this );\n\t};\n\n\t/* virtualdom/items/Section/prototype/shuffle.js */\n\tvar virtualdom_items_Section$shuffle = function( types, runloop, circular ) {\n\n\t\tvar Fragment;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\treturn function Section$shuffle( newIndices ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar section = this,\n\t\t\t\tparentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;\n\t\t\t// short circuit any double-updates, and ensure that this isn't applied to\n\t\t\t// non-list sections\n\t\t\tif ( this.shuffling || this.unbound || this.subtype && this.subtype !== types.SECTION_EACH ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.shuffling = true;\n\t\t\trunloop.scheduleTask( function() {\n\t\t\t\treturn this$0.shuffling = false;\n\t\t\t} );\n\t\t\tparentFragment = this.parentFragment;\n\t\t\treboundFragments = [];\n\t\t\t// first, rebind existing fragments\n\t\t\tnewIndices.forEach( function rebindIfNecessary( newIndex, oldIndex ) {\n\t\t\t\tvar fragment, by, oldKeypath, newKeypath;\n\t\t\t\tif ( newIndex === oldIndex ) {\n\t\t\t\t\treboundFragments[ newIndex ] = section.fragments[ oldIndex ];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfragment = section.fragments[ oldIndex ];\n\t\t\t\tif ( firstChange === undefined ) {\n\t\t\t\t\tfirstChange = oldIndex;\n\t\t\t\t}\n\t\t\t\t// does this fragment need to be torn down?\n\t\t\t\tif ( newIndex === -1 ) {\n\t\t\t\t\tsection.fragmentsToUnrender.push( fragment );\n\t\t\t\t\tfragment.unbind();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Otherwise, it needs to be rebound to a new index\n\t\t\t\tby = newIndex - oldIndex;\n\t\t\t\toldKeypath = section.keypath + '.' + oldIndex;\n\t\t\t\tnewKeypath = section.keypath + '.' + newIndex;\n\t\t\t\tfragment.rebind( section.template.i, newIndex, oldKeypath, newKeypath );\n\t\t\t\tfragment.index = newIndex;\n\t\t\t\treboundFragments[ newIndex ] = fragment;\n\t\t\t} );\n\t\t\tnewLength = this.root.get( this.keypath ).length;\n\t\t\t// If nothing changed with the existing fragments, then we start adding\n\t\t\t// new fragments at the end...\n\t\t\tif ( firstChange === undefined ) {\n\t\t\t\t// ...unless there are no new fragments to add\n\t\t\t\tif ( this.length === newLength ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfirstChange = this.length;\n\t\t\t}\n\t\t\tthis.length = this.fragments.length = newLength;\n\t\t\tif ( this.rendered ) {\n\t\t\t\trunloop.addView( this );\n\t\t\t}\n\t\t\t// Prepare new fragment options\n\t\t\tfragmentOptions = {\n\t\t\t\ttemplate: this.template.f,\n\t\t\t\troot: this.root,\n\t\t\t\towner: this\n\t\t\t};\n\t\t\tif ( this.template.i ) {\n\t\t\t\tfragmentOptions.indexRef = this.template.i;\n\t\t\t}\n\t\t\t// Add as many new fragments as we need to, or add back existing\n\t\t\t// (detached) fragments\n\t\t\tfor ( i = firstChange; i < newLength; i += 1 ) {\n\t\t\t\tfragment = reboundFragments[ i ];\n\t\t\t\tif ( !fragment ) {\n\t\t\t\t\tthis.fragmentsToCreate.push( i );\n\t\t\t\t}\n\t\t\t\tthis.fragments[ i ] = fragment;\n\t\t\t}\n\t\t};\n\t}( types, runloop, circular );\n\n\t/* virtualdom/items/Section/prototype/render.js */\n\tvar virtualdom_items_Section$render = function Section$render() {\n\t\tvar docFrag;\n\t\tdocFrag = this.docFrag = document.createDocumentFragment();\n\t\tthis.update();\n\t\tthis.rendered = true;\n\t\treturn docFrag;\n\t};\n\n\t/* utils/isArrayLike.js */\n\tvar isArrayLike = function() {\n\n\t\tvar pattern = /^\\[object (?:Array|FileList)\\]$/,\n\t\t\ttoString = Object.prototype.toString;\n\t\treturn function isArrayLike( obj ) {\n\t\t\treturn pattern.test( toString.call( obj ) );\n\t\t};\n\t}();\n\n\t/* virtualdom/items/Section/prototype/setValue.js */\n\tvar virtualdom_items_Section$setValue = function( types, isArrayLike, isObject, runloop, circular ) {\n\n\t\tvar __export;\n\t\tvar Fragment;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\t__export = function Section$setValue( value ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar wrapper, fragmentOptions;\n\t\t\tif ( this.updating ) {\n\t\t\t\t// If a child of this section causes a re-evaluation - for example, an\n\t\t\t\t// expression refers to a function that mutates the array that this\n\t\t\t\t// section depends on - we'll end up with a double rendering bug (see\n\t\t\t\t// https://github.com/ractivejs/ractive/issues/748). This prevents it.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.updating = true;\n\t\t\t// with sections, we need to get the fake value if we have a wrapped object\n\t\t\tif ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {\n\t\t\t\tvalue = wrapper.get();\n\t\t\t}\n\t\t\t// If any fragments are awaiting creation after a splice,\n\t\t\t// this is the place to do it\n\t\t\tif ( this.fragmentsToCreate.length ) {\n\t\t\t\tfragmentOptions = {\n\t\t\t\t\ttemplate: this.template.f,\n\t\t\t\t\troot: this.root,\n\t\t\t\t\tpElement: this.pElement,\n\t\t\t\t\towner: this,\n\t\t\t\t\tindexRef: this.template.i\n\t\t\t\t};\n\t\t\t\tthis.fragmentsToCreate.forEach( function( index ) {\n\t\t\t\t\tvar fragment;\n\t\t\t\t\tfragmentOptions.context = this$0.keypath + '.' + index;\n\t\t\t\t\tfragmentOptions.index = index;\n\t\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\t\tthis$0.fragmentsToRender.push( this$0.fragments[ index ] = fragment );\n\t\t\t\t} );\n\t\t\t\tthis.fragmentsToCreate.length = 0;\n\t\t\t} else if ( reevaluateSection( this, value ) ) {\n\t\t\t\tthis.bubble();\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\trunloop.addView( this );\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.value = value;\n\t\t\tthis.updating = false;\n\t\t};\n\n\t\tfunction reevaluateSection( section, value ) {\n\t\t\tvar fragmentOptions = {\n\t\t\t\ttemplate: section.template.f,\n\t\t\t\troot: section.root,\n\t\t\t\tpElement: section.parentFragment.pElement,\n\t\t\t\towner: section\n\t\t\t};\n\t\t\t// If we already know the section type, great\n\t\t\t// TODO can this be optimised? i.e. pick an reevaluateSection function during init\n\t\t\t// and avoid doing this each time?\n\t\t\tif ( section.subtype ) {\n\t\t\t\tswitch ( section.subtype ) {\n\t\t\t\t\tcase types.SECTION_IF:\n\t\t\t\t\t\treturn reevaluateConditionalSection( section, value, false, fragmentOptions );\n\t\t\t\t\tcase types.SECTION_UNLESS:\n\t\t\t\t\t\treturn reevaluateConditionalSection( section, value, true, fragmentOptions );\n\t\t\t\t\tcase types.SECTION_WITH:\n\t\t\t\t\t\treturn reevaluateContextSection( section, fragmentOptions );\n\t\t\t\t\tcase types.SECTION_IF_WITH:\n\t\t\t\t\t\treturn reevaluateConditionalContextSection( section, value, fragmentOptions );\n\t\t\t\t\tcase types.SECTION_EACH:\n\t\t\t\t\t\tif ( isObject( value ) ) {\n\t\t\t\t\t\t\treturn reevaluateListObjectSection( section, value, fragmentOptions );\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise we need to work out what sort of section we're dealing with\n\t\t\tsection.ordered = !!isArrayLike( value );\n\t\t\t// Ordered list section\n\t\t\tif ( section.ordered ) {\n\t\t\t\treturn reevaluateListSection( section, value, fragmentOptions );\n\t\t\t}\n\t\t\t// Unordered list, or context\n\t\t\tif ( isObject( value ) || typeof value === 'function' ) {\n\t\t\t\t// Index reference indicates section should be treated as a list\n\t\t\t\tif ( section.template.i ) {\n\t\t\t\t\treturn reevaluateListObjectSection( section, value, fragmentOptions );\n\t\t\t\t}\n\t\t\t\t// Otherwise, object provides context for contents\n\t\t\t\treturn reevaluateContextSection( section, fragmentOptions );\n\t\t\t}\n\t\t\t// Conditional section\n\t\t\treturn reevaluateConditionalSection( section, value, false, fragmentOptions );\n\t\t}\n\n\t\tfunction reevaluateListSection( section, value, fragmentOptions ) {\n\t\t\tvar i, length, fragment;\n\t\t\tlength = value.length;\n\t\t\tif ( length === section.length ) {\n\t\t\t\t// Nothing to do\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// if the array is shorter than it was previously, remove items\n\t\t\tif ( length < section.length ) {\n\t\t\t\tsection.fragmentsToUnrender = section.fragments.splice( length, section.length - length );\n\t\t\t\tsection.fragmentsToUnrender.forEach( unbind );\n\t\t\t} else {\n\t\t\t\tif ( length > section.length ) {\n\t\t\t\t\t// add any new ones\n\t\t\t\t\tfor ( i = section.length; i < length; i += 1 ) {\n\t\t\t\t\t\t// append list item to context stack\n\t\t\t\t\t\tfragmentOptions.context = section.keypath + '.' + i;\n\t\t\t\t\t\tfragmentOptions.index = i;\n\t\t\t\t\t\tif ( section.template.i ) {\n\t\t\t\t\t\t\tfragmentOptions.indexRef = section.template.i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\t\t\tsection.fragmentsToRender.push( section.fragments[ i ] = fragment );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsection.length = length;\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction reevaluateListObjectSection( section, value, fragmentOptions ) {\n\t\t\tvar id, i, hasKey, fragment, changed;\n\t\t\thasKey = section.hasKey || ( section.hasKey = {} );\n\t\t\t// remove any fragments that should no longer exist\n\t\t\ti = section.fragments.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tfragment = section.fragments[ i ];\n\t\t\t\tif ( !( fragment.index in value ) ) {\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tfragment.unbind();\n\t\t\t\t\tsection.fragmentsToUnrender.push( fragment );\n\t\t\t\t\tsection.fragments.splice( i, 1 );\n\t\t\t\t\thasKey[ fragment.index ] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// add any that haven't been created yet\n\t\t\tfor ( id in value ) {\n\t\t\t\tif ( !hasKey[ id ] ) {\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tfragmentOptions.context = section.keypath + '.' + id;\n\t\t\t\t\tfragmentOptions.index = id;\n\t\t\t\t\tif ( section.template.i ) {\n\t\t\t\t\t\tfragmentOptions.indexRef = section.template.i;\n\t\t\t\t\t}\n\t\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\t\tsection.fragmentsToRender.push( fragment );\n\t\t\t\t\tsection.fragments.push( fragment );\n\t\t\t\t\thasKey[ id ] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsection.length = section.fragments.length;\n\t\t\treturn changed;\n\t\t}\n\n\t\tfunction reevaluateConditionalContextSection( section, value, fragmentOptions ) {\n\t\t\tif ( value ) {\n\t\t\t\treturn reevaluateContextSection( section, fragmentOptions );\n\t\t\t} else {\n\t\t\t\treturn removeSectionFragments( section );\n\t\t\t}\n\t\t}\n\n\t\tfunction reevaluateContextSection( section, fragmentOptions ) {\n\t\t\tvar fragment;\n\t\t\t// ...then if it isn't rendered, render it, adding section.keypath to the context stack\n\t\t\t// (if it is already rendered, then any children dependent on the context stack\n\t\t\t// will update themselves without any prompting)\n\t\t\tif ( !section.length ) {\n\t\t\t\t// append this section to the context stack\n\t\t\t\tfragmentOptions.context = section.keypath;\n\t\t\t\tfragmentOptions.index = 0;\n\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\tsection.fragmentsToRender.push( section.fragments[ 0 ] = fragment );\n\t\t\t\tsection.length = 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction reevaluateConditionalSection( section, value, inverted, fragmentOptions ) {\n\t\t\tvar doRender, emptyArray, emptyObject, fragment, name;\n\t\t\temptyArray = isArrayLike( value ) && value.length === 0;\n\t\t\temptyObject = false;\n\t\t\tif ( !isArrayLike( value ) && isObject( value ) ) {\n\t\t\t\temptyObject = true;\n\t\t\t\tfor ( name in value ) {\n\t\t\t\t\temptyObject = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( inverted ) {\n\t\t\t\tdoRender = emptyArray || emptyObject || !value;\n\t\t\t} else {\n\t\t\t\tdoRender = value && !emptyArray && !emptyObject;\n\t\t\t}\n\t\t\tif ( doRender ) {\n\t\t\t\tif ( !section.length ) {\n\t\t\t\t\t// no change to context stack\n\t\t\t\t\tfragmentOptions.index = 0;\n\t\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\t\tsection.fragmentsToRender.push( section.fragments[ 0 ] = fragment );\n\t\t\t\t\tsection.length = 1;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif ( section.length > 1 ) {\n\t\t\t\t\tsection.fragmentsToUnrender = section.fragments.splice( 1 );\n\t\t\t\t\tsection.fragmentsToUnrender.forEach( unbind );\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn removeSectionFragments( section );\n\t\t\t}\n\t\t}\n\n\t\tfunction removeSectionFragments( section ) {\n\t\t\tif ( section.length ) {\n\t\t\t\tsection.fragmentsToUnrender = section.fragments.splice( 0, section.fragments.length ).filter( isRendered );\n\t\t\t\tsection.fragmentsToUnrender.forEach( unbind );\n\t\t\t\tsection.length = section.fragmentsToRender.length = 0;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction unbind( fragment ) {\n\t\t\tfragment.unbind();\n\t\t}\n\n\t\tfunction isRendered( fragment ) {\n\t\t\treturn fragment.rendered;\n\t\t}\n\t\treturn __export;\n\t}( types, isArrayLike, isObject, runloop, circular );\n\n\t/* virtualdom/items/Section/prototype/toString.js */\n\tvar virtualdom_items_Section$toString = function Section$toString( escape ) {\n\t\tvar str, i, len;\n\t\tstr = '';\n\t\ti = 0;\n\t\tlen = this.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tstr += this.fragments[ i ].toString( escape );\n\t\t}\n\t\treturn str;\n\t};\n\n\t/* virtualdom/items/Section/prototype/unbind.js */\n\tvar virtualdom_items_Section$unbind = function( unbind ) {\n\n\t\tvar __export;\n\t\t__export = function Section$unbind() {\n\t\t\tthis.fragments.forEach( unbindFragment );\n\t\t\tunbind.call( this );\n\t\t\tthis.length = 0;\n\t\t\tthis.unbound = true;\n\t\t};\n\n\t\tfunction unbindFragment( fragment ) {\n\t\t\tfragment.unbind();\n\t\t}\n\t\treturn __export;\n\t}( unbind );\n\n\t/* virtualdom/items/Section/prototype/unrender.js */\n\tvar virtualdom_items_Section$unrender = function() {\n\n\t\tvar __export;\n\t\t__export = function Section$unrender( shouldDestroy ) {\n\t\t\tthis.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );\n\t\t};\n\n\t\tfunction unrenderAndDestroy( fragment ) {\n\t\t\tfragment.unrender( true );\n\t\t}\n\n\t\tfunction unrender( fragment ) {\n\t\t\tfragment.unrender( false );\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* virtualdom/items/Section/prototype/update.js */\n\tvar virtualdom_items_Section$update = function Section$update() {\n\t\tvar fragment, renderIndex, renderedFragments, anchor, target, i, len;\n\t\t// `this.renderedFragments` is in the order of the previous render.\n\t\t// If fragments have shuffled about, this allows us to quickly\n\t\t// reinsert them in the correct place\n\t\trenderedFragments = this.renderedFragments;\n\t\t// Remove fragments that have been marked for destruction\n\t\twhile ( fragment = this.fragmentsToUnrender.pop() ) {\n\t\t\tfragment.unrender( true );\n\t\t\trenderedFragments.splice( renderedFragments.indexOf( fragment ), 1 );\n\t\t}\n\t\t// Render new fragments (but don't insert them yet)\n\t\twhile ( fragment = this.fragmentsToRender.shift() ) {\n\t\t\tfragment.render();\n\t\t}\n\t\tif ( this.rendered ) {\n\t\t\ttarget = this.parentFragment.getNode();\n\t\t}\n\t\tlen = this.fragments.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tfragment = this.fragments[ i ];\n\t\t\trenderIndex = renderedFragments.indexOf( fragment, i );\n\t\t\t// search from current index - it's guaranteed to be the same or higher\n\t\t\tif ( renderIndex === i ) {\n\t\t\t\t// already in the right place. insert accumulated nodes (if any) and carry on\n\t\t\t\tif ( this.docFrag.childNodes.length ) {\n\t\t\t\t\tanchor = fragment.firstNode();\n\t\t\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.docFrag.appendChild( fragment.detach() );\n\t\t\t// update renderedFragments\n\t\t\tif ( renderIndex !== -1 ) {\n\t\t\t\trenderedFragments.splice( renderIndex, 1 );\n\t\t\t}\n\t\t\trenderedFragments.splice( i, 0, fragment );\n\t\t}\n\t\tif ( this.rendered && this.docFrag.childNodes.length ) {\n\t\t\tanchor = this.parentFragment.findNextNode( this );\n\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t}\n\t\t// Save the rendering order for next time\n\t\tthis.renderedFragments = this.fragments.slice();\n\t};\n\n\t/* virtualdom/items/Section/_Section.js */\n\tvar Section = function( types, Mustache, bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, shuffle, render, setValue, toString, unbind, unrender, update ) {\n\n\t\tvar Section = function( options ) {\n\t\t\tthis.type = types.SECTION;\n\t\t\tthis.subtype = options.template.n;\n\t\t\tthis.inverted = this.subtype === types.SECTION_UNLESS;\n\t\t\tthis.pElement = options.pElement;\n\t\t\tthis.fragments = [];\n\t\t\tthis.fragmentsToCreate = [];\n\t\t\tthis.fragmentsToRender = [];\n\t\t\tthis.fragmentsToUnrender = [];\n\t\t\tthis.renderedFragments = [];\n\t\t\tthis.length = 0;\n\t\t\t// number of times this section is rendered\n\t\t\tMustache.init( this, options );\n\t\t};\n\t\tSection.prototype = {\n\t\t\tbubble: bubble,\n\t\t\tdetach: detach,\n\t\t\tfind: find,\n\t\t\tfindAll: findAll,\n\t\t\tfindAllComponents: findAllComponents,\n\t\t\tfindComponent: findComponent,\n\t\t\tfindNextNode: findNextNode,\n\t\t\tfirstNode: firstNode,\n\t\t\tgetValue: Mustache.getValue,\n\t\t\tshuffle: shuffle,\n\t\t\trebind: Mustache.rebind,\n\t\t\trender: render,\n\t\t\tresolve: Mustache.resolve,\n\t\t\tsetValue: setValue,\n\t\t\ttoString: toString,\n\t\t\tunbind: unbind,\n\t\t\tunrender: unrender,\n\t\t\tupdate: update\n\t\t};\n\t\treturn Section;\n\t}( types, Mustache, virtualdom_items_Section$bubble, virtualdom_items_Section$detach, virtualdom_items_Section$find, virtualdom_items_Section$findAll, virtualdom_items_Section$findAllComponents, virtualdom_items_Section$findComponent, virtualdom_items_Section$findNextNode, virtualdom_items_Section$firstNode, virtualdom_items_Section$shuffle, virtualdom_items_Section$render, virtualdom_items_Section$setValue, virtualdom_items_Section$toString, virtualdom_items_Section$unbind, virtualdom_items_Section$unrender, virtualdom_items_Section$update );\n\n\t/* virtualdom/items/Triple/prototype/detach.js */\n\tvar virtualdom_items_Triple$detach = function Triple$detach() {\n\t\tvar len, i;\n\t\tif ( this.docFrag ) {\n\t\t\tlen = this.nodes.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tthis.docFrag.appendChild( this.nodes[ i ] );\n\t\t\t}\n\t\t\treturn this.docFrag;\n\t\t}\n\t};\n\n\t/* virtualdom/items/Triple/prototype/find.js */\n\tvar virtualdom_items_Triple$find = function( matches ) {\n\n\t\treturn function Triple$find( selector ) {\n\t\t\tvar i, len, node, queryResult;\n\t\t\tlen = this.nodes.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tnode = this.nodes[ i ];\n\t\t\t\tif ( node.nodeType !== 1 ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( matches( node, selector ) ) {\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t\tif ( queryResult = node.querySelector( selector ) ) {\n\t\t\t\t\treturn queryResult;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t}( matches );\n\n\t/* virtualdom/items/Triple/prototype/findAll.js */\n\tvar virtualdom_items_Triple$findAll = function( matches ) {\n\n\t\treturn function Triple$findAll( selector, queryResult ) {\n\t\t\tvar i, len, node, queryAllResult, numNodes, j;\n\t\t\tlen = this.nodes.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tnode = this.nodes[ i ];\n\t\t\t\tif ( node.nodeType !== 1 ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( matches( node, selector ) ) {\n\t\t\t\t\tqueryResult.push( node );\n\t\t\t\t}\n\t\t\t\tif ( queryAllResult = node.querySelectorAll( selector ) ) {\n\t\t\t\t\tnumNodes = queryAllResult.length;\n\t\t\t\t\tfor ( j = 0; j < numNodes; j += 1 ) {\n\t\t\t\t\t\tqueryResult.push( queryAllResult[ j ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}( matches );\n\n\t/* virtualdom/items/Triple/prototype/firstNode.js */\n\tvar virtualdom_items_Triple$firstNode = function Triple$firstNode() {\n\t\tif ( this.rendered && this.nodes[ 0 ] ) {\n\t\t\treturn this.nodes[ 0 ];\n\t\t}\n\t\treturn this.parentFragment.findNextNode( this );\n\t};\n\n\t/* virtualdom/items/Triple/helpers/insertHtml.js */\n\tvar insertHtml = function( namespaces, createElement ) {\n\n\t\tvar __export;\n\t\tvar elementCache = {},\n\t\t\tieBug, ieBlacklist;\n\t\ttry {\n\t\t\tcreateElement( 'table' ).innerHTML = 'foo';\n\t\t} catch ( err ) {\n\t\t\tieBug = true;\n\t\t\tieBlacklist = {\n\t\t\t\tTABLE: [\n\t\t\t\t\t'<table class=\"x\">',\n\t\t\t\t\t'</table>'\n\t\t\t\t],\n\t\t\t\tTHEAD: [\n\t\t\t\t\t'<table><thead class=\"x\">',\n\t\t\t\t\t'</thead></table>'\n\t\t\t\t],\n\t\t\t\tTBODY: [\n\t\t\t\t\t'<table><tbody class=\"x\">',\n\t\t\t\t\t'</tbody></table>'\n\t\t\t\t],\n\t\t\t\tTR: [\n\t\t\t\t\t'<table><tr class=\"x\">',\n\t\t\t\t\t'</tr></table>'\n\t\t\t\t],\n\t\t\t\tSELECT: [\n\t\t\t\t\t'<select class=\"x\">',\n\t\t\t\t\t'</select>'\n\t\t\t\t]\n\t\t\t};\n\t\t}\n\t\t__export = function( html, node, docFrag ) {\n\t\t\tvar container, nodes = [],\n\t\t\t\twrapper, selectedOption, child, i;\n\t\t\t// render 0 and false\n\t\t\tif ( html != null && html !== '' ) {\n\t\t\t\tif ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {\n\t\t\t\t\tcontainer = element( 'DIV' );\n\t\t\t\t\tcontainer.innerHTML = wrapper[ 0 ] + html + wrapper[ 1 ];\n\t\t\t\t\tcontainer = container.querySelector( '.x' );\n\t\t\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t\t\t}\n\t\t\t\t} else if ( node.namespaceURI === namespaces.svg ) {\n\t\t\t\t\tcontainer = element( 'DIV' );\n\t\t\t\t\tcontainer.innerHTML = '<svg class=\"x\">' + html + '</svg>';\n\t\t\t\t\tcontainer = container.querySelector( '.x' );\n\t\t\t\t} else {\n\t\t\t\t\tcontainer = element( node.tagName );\n\t\t\t\t\tcontainer.innerHTML = html;\n\t\t\t\t}\n\t\t\t\twhile ( child = container.firstChild ) {\n\t\t\t\t\tnodes.push( child );\n\t\t\t\t\tdocFrag.appendChild( child );\n\t\t\t\t}\n\t\t\t\t// This is really annoying. Extracting <option> nodes from the\n\t\t\t\t// temporary container <select> causes the remaining ones to\n\t\t\t\t// become selected. So now we have to deselect them. IE8, you\n\t\t\t\t// amaze me. You really do\n\t\t\t\tif ( ieBug && node.tagName === 'SELECT' ) {\n\t\t\t\t\ti = nodes.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( nodes[ i ] !== selectedOption ) {\n\t\t\t\t\t\t\tnodes[ i ].selected = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nodes;\n\t\t};\n\n\t\tfunction element( tagName ) {\n\t\t\treturn elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );\n\t\t}\n\t\treturn __export;\n\t}( namespaces, createElement );\n\n\t/* utils/toArray.js */\n\tvar toArray = function toArray( arrayLike ) {\n\t\tvar array = [],\n\t\t\ti = arrayLike.length;\n\t\twhile ( i-- ) {\n\t\t\tarray[ i ] = arrayLike[ i ];\n\t\t}\n\t\treturn array;\n\t};\n\n\t/* virtualdom/items/Triple/helpers/updateSelect.js */\n\tvar updateSelect = function( toArray ) {\n\n\t\tvar __export;\n\t\t__export = function updateSelect( parentElement ) {\n\t\t\tvar selectedOptions, option, value;\n\t\t\tif ( !parentElement || parentElement.name !== 'select' || !parentElement.binding ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tselectedOptions = toArray( parentElement.node.options ).filter( isSelected );\n\t\t\t// If one of them had a `selected` attribute, we need to sync\n\t\t\t// the model to the view\n\t\t\tif ( parentElement.getAttribute( 'multiple' ) ) {\n\t\t\t\tvalue = selectedOptions.map( function( o ) {\n\t\t\t\t\treturn o.value;\n\t\t\t\t} );\n\t\t\t} else if ( option = selectedOptions[ 0 ] ) {\n\t\t\t\tvalue = option.value;\n\t\t\t}\n\t\t\tif ( value !== undefined ) {\n\t\t\t\tparentElement.binding.setValue( value );\n\t\t\t}\n\t\t\tparentElement.bubble();\n\t\t};\n\n\t\tfunction isSelected( option ) {\n\t\t\treturn option.selected;\n\t\t}\n\t\treturn __export;\n\t}( toArray );\n\n\t/* virtualdom/items/Triple/prototype/render.js */\n\tvar virtualdom_items_Triple$render = function( insertHtml, updateSelect ) {\n\n\t\treturn function Triple$render() {\n\t\t\tif ( this.rendered ) {\n\t\t\t\tthrow new Error( 'Attempted to render an item that was already rendered' );\n\t\t\t}\n\t\t\tthis.docFrag = document.createDocumentFragment();\n\t\t\tthis.nodes = insertHtml( this.value, this.parentFragment.getNode(), this.docFrag );\n\t\t\t// Special case - we're inserting the contents of a <select>\n\t\t\tupdateSelect( this.pElement );\n\t\t\tthis.rendered = true;\n\t\t\treturn this.docFrag;\n\t\t};\n\t}( insertHtml, updateSelect );\n\n\t/* virtualdom/items/Triple/prototype/setValue.js */\n\tvar virtualdom_items_Triple$setValue = function( runloop ) {\n\n\t\treturn function Triple$setValue( value ) {\n\t\t\tvar wrapper;\n\t\t\t// TODO is there a better way to approach this?\n\t\t\tif ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {\n\t\t\t\tvalue = wrapper.get();\n\t\t\t}\n\t\t\tif ( value !== this.value ) {\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.parentFragment.bubble();\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\trunloop.addView( this );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}( runloop );\n\n\t/* virtualdom/items/Triple/prototype/toString.js */\n\tvar virtualdom_items_Triple$toString = function( decodeCharacterReferences ) {\n\n\t\treturn function Triple$toString() {\n\t\t\treturn this.value != undefined ? decodeCharacterReferences( '' + this.value ) : '';\n\t\t};\n\t}( decodeCharacterReferences );\n\n\t/* virtualdom/items/Triple/prototype/unrender.js */\n\tvar virtualdom_items_Triple$unrender = function( detachNode ) {\n\n\t\treturn function Triple$unrender( shouldDestroy ) {\n\t\t\tif ( this.rendered && shouldDestroy ) {\n\t\t\t\tthis.nodes.forEach( detachNode );\n\t\t\t\tthis.rendered = false;\n\t\t\t}\n\t\t};\n\t}( detachNode );\n\n\t/* virtualdom/items/Triple/prototype/update.js */\n\tvar virtualdom_items_Triple$update = function( insertHtml, updateSelect ) {\n\n\t\treturn function Triple$update() {\n\t\t\tvar node, parentNode;\n\t\t\tif ( !this.rendered ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Remove existing nodes\n\t\t\twhile ( this.nodes && this.nodes.length ) {\n\t\t\t\tnode = this.nodes.pop();\n\t\t\t\tnode.parentNode.removeChild( node );\n\t\t\t}\n\t\t\t// Insert new nodes\n\t\t\tparentNode = this.parentFragment.getNode();\n\t\t\tthis.nodes = insertHtml( this.value, parentNode, this.docFrag );\n\t\t\tparentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );\n\t\t\t// Special case - we're inserting the contents of a <select>\n\t\t\tupdateSelect( this.pElement );\n\t\t};\n\t}( insertHtml, updateSelect );\n\n\t/* virtualdom/items/Triple/_Triple.js */\n\tvar Triple = function( types, Mustache, detach, find, findAll, firstNode, render, setValue, toString, unrender, update, unbind ) {\n\n\t\tvar Triple = function( options ) {\n\t\t\tthis.type = types.TRIPLE;\n\t\t\tMustache.init( this, options );\n\t\t};\n\t\tTriple.prototype = {\n\t\t\tdetach: detach,\n\t\t\tfind: find,\n\t\t\tfindAll: findAll,\n\t\t\tfirstNode: firstNode,\n\t\t\tgetValue: Mustache.getValue,\n\t\t\trebind: Mustache.rebind,\n\t\t\trender: render,\n\t\t\tresolve: Mustache.resolve,\n\t\t\tsetValue: setValue,\n\t\t\ttoString: toString,\n\t\t\tunbind: unbind,\n\t\t\tunrender: unrender,\n\t\t\tupdate: update\n\t\t};\n\t\treturn Triple;\n\t}( types, Mustache, virtualdom_items_Triple$detach, virtualdom_items_Triple$find, virtualdom_items_Triple$findAll, virtualdom_items_Triple$firstNode, virtualdom_items_Triple$render, virtualdom_items_Triple$setValue, virtualdom_items_Triple$toString, virtualdom_items_Triple$unrender, virtualdom_items_Triple$update, unbind );\n\n\t/* virtualdom/items/Element/prototype/bubble.js */\n\tvar virtualdom_items_Element$bubble = function() {\n\t\tthis.parentFragment.bubble();\n\t};\n\n\t/* virtualdom/items/Element/prototype/detach.js */\n\tvar virtualdom_items_Element$detach = function Element$detach() {\n\t\tvar node = this.node,\n\t\t\tparentNode;\n\t\tif ( node ) {\n\t\t\t// need to check for parent node - DOM may have been altered\n\t\t\t// by something other than Ractive! e.g. jQuery UI...\n\t\t\tif ( parentNode = node.parentNode ) {\n\t\t\t\tparentNode.removeChild( node );\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/prototype/find.js */\n\tvar virtualdom_items_Element$find = function( matches ) {\n\n\t\treturn function( selector ) {\n\t\t\tif ( matches( this.node, selector ) ) {\n\t\t\t\treturn this.node;\n\t\t\t}\n\t\t\tif ( this.fragment && this.fragment.find ) {\n\t\t\t\treturn this.fragment.find( selector );\n\t\t\t}\n\t\t};\n\t}( matches );\n\n\t/* virtualdom/items/Element/prototype/findAll.js */\n\tvar virtualdom_items_Element$findAll = function( selector, query ) {\n\t\t// Add this node to the query, if applicable, and register the\n\t\t// query on this element\n\t\tif ( query._test( this, true ) && query.live ) {\n\t\t\t( this.liveQueries || ( this.liveQueries = [] ) ).push( query );\n\t\t}\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.findAll( selector, query );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/prototype/findAllComponents.js */\n\tvar virtualdom_items_Element$findAllComponents = function( selector, query ) {\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.findAllComponents( selector, query );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/prototype/findComponent.js */\n\tvar virtualdom_items_Element$findComponent = function( selector ) {\n\t\tif ( this.fragment ) {\n\t\t\treturn this.fragment.findComponent( selector );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/prototype/findNextNode.js */\n\tvar virtualdom_items_Element$findNextNode = function Element$findNextNode() {\n\t\treturn null;\n\t};\n\n\t/* virtualdom/items/Element/prototype/firstNode.js */\n\tvar virtualdom_items_Element$firstNode = function Element$firstNode() {\n\t\treturn this.node;\n\t};\n\n\t/* virtualdom/items/Element/prototype/getAttribute.js */\n\tvar virtualdom_items_Element$getAttribute = function Element$getAttribute( name ) {\n\t\tif ( !this.attributes || !this.attributes[ name ] ) {\n\t\t\treturn;\n\t\t}\n\t\treturn this.attributes[ name ].value;\n\t};\n\n\t/* virtualdom/items/Element/shared/enforceCase.js */\n\tvar enforceCase = function() {\n\n\t\tvar svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;\n\t\tsvgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );\n\t\tsvgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );\n\t\tcreateMap = function( items ) {\n\t\t\tvar map = {},\n\t\t\t\ti = items.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tmap[ items[ i ].toLowerCase() ] = items[ i ];\n\t\t\t}\n\t\t\treturn map;\n\t\t};\n\t\tmap = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );\n\t\treturn function( elementName ) {\n\t\t\tvar lowerCaseElementName = elementName.toLowerCase();\n\t\t\treturn map[ lowerCaseElementName ] || lowerCaseElementName;\n\t\t};\n\t}();\n\n\t/* virtualdom/items/Element/Attribute/prototype/bubble.js */\n\tvar virtualdom_items_Element_Attribute$bubble = function( runloop, isEqual ) {\n\n\t\treturn function Attribute$bubble() {\n\t\t\tvar value = this.fragment.getValue();\n\t\t\t// TODO this can register the attribute multiple times (see render test\n\t\t\t// 'Attribute with nested mustaches')\n\t\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\t\t// Need to clear old id from ractive.nodes\n\t\t\t\tif ( this.name === 'id' && this.value ) {\n\t\t\t\t\tdelete this.root.nodes[ this.value ];\n\t\t\t\t}\n\t\t\t\tthis.value = value;\n\t\t\t\tif ( this.name === 'value' && this.node ) {\n\t\t\t\t\t// We need to store the value on the DOM like this so we\n\t\t\t\t\t// can retrieve it later without it being coerced to a string\n\t\t\t\t\tthis.node._ractive.value = value;\n\t\t\t\t}\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\trunloop.addView( this );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}( runloop, isEqual );\n\n\t/* config/booleanAttributes.js */\n\tvar booleanAttributes = function() {\n\n\t\t// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n\t\tvar booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|draggable|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\n\t\treturn booleanAttributes;\n\t}();\n\n\t/* virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js */\n\tvar determineNameAndNamespace = function( namespaces, enforceCase ) {\n\n\t\treturn function( attribute, name ) {\n\t\t\tvar colonIndex, namespacePrefix;\n\t\t\t// are we dealing with a namespaced attribute, e.g. xlink:href?\n\t\t\tcolonIndex = name.indexOf( ':' );\n\t\t\tif ( colonIndex !== -1 ) {\n\t\t\t\t// looks like we are, yes...\n\t\t\t\tnamespacePrefix = name.substr( 0, colonIndex );\n\t\t\t\t// ...unless it's a namespace *declaration*, which we ignore (on the assumption\n\t\t\t\t// that only valid namespaces will be used)\n\t\t\t\tif ( namespacePrefix !== 'xmlns' ) {\n\t\t\t\t\tname = name.substring( colonIndex + 1 );\n\t\t\t\t\tattribute.name = enforceCase( name );\n\t\t\t\t\tattribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];\n\t\t\t\t\tattribute.namespacePrefix = namespacePrefix;\n\t\t\t\t\tif ( !attribute.namespace ) {\n\t\t\t\t\t\tthrow 'Unknown namespace (\"' + namespacePrefix + '\")';\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// SVG attribute names are case sensitive\n\t\t\tattribute.name = attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name;\n\t\t};\n\t}( namespaces, enforceCase );\n\n\t/* virtualdom/items/Element/Attribute/helpers/getInterpolator.js */\n\tvar getInterpolator = function( types ) {\n\n\t\treturn function getInterpolator( attribute ) {\n\t\t\tvar items = attribute.fragment.items;\n\t\t\tif ( items.length !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( items[ 0 ].type === types.INTERPOLATOR ) {\n\t\t\t\treturn items[ 0 ];\n\t\t\t}\n\t\t};\n\t}( types );\n\n\t/* virtualdom/items/Element/Attribute/helpers/determinePropertyName.js */\n\tvar determinePropertyName = function( namespaces, booleanAttributes ) {\n\n\t\tvar propertyNames = {\n\t\t\t'accept-charset': 'acceptCharset',\n\t\t\taccesskey: 'accessKey',\n\t\t\tbgcolor: 'bgColor',\n\t\t\t'class': 'className',\n\t\t\tcodebase: 'codeBase',\n\t\t\tcolspan: 'colSpan',\n\t\t\tcontenteditable: 'contentEditable',\n\t\t\tdatetime: 'dateTime',\n\t\t\tdirname: 'dirName',\n\t\t\t'for': 'htmlFor',\n\t\t\t'http-equiv': 'httpEquiv',\n\t\t\tismap: 'isMap',\n\t\t\tmaxlength: 'maxLength',\n\t\t\tnovalidate: 'noValidate',\n\t\t\tpubdate: 'pubDate',\n\t\t\treadonly: 'readOnly',\n\t\t\trowspan: 'rowSpan',\n\t\t\ttabindex: 'tabIndex',\n\t\t\tusemap: 'useMap'\n\t\t};\n\t\treturn function( attribute, options ) {\n\t\t\tvar propertyName;\n\t\t\tif ( attribute.pNode && !attribute.namespace && ( !options.pNode.namespaceURI || options.pNode.namespaceURI === namespaces.html ) ) {\n\t\t\t\tpropertyName = propertyNames[ attribute.name ] || attribute.name;\n\t\t\t\tif ( options.pNode[ propertyName ] !== undefined ) {\n\t\t\t\t\tattribute.propertyName = propertyName;\n\t\t\t\t}\n\t\t\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n\t\t\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n\t\t\t\tif ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {\n\t\t\t\t\tattribute.useProperty = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}( namespaces, booleanAttributes );\n\n\t/* virtualdom/items/Element/Attribute/prototype/init.js */\n\tvar virtualdom_items_Element_Attribute$init = function( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular ) {\n\n\t\tvar Fragment;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\treturn function Attribute$init( options ) {\n\t\t\tthis.type = types.ATTRIBUTE;\n\t\t\tthis.element = options.element;\n\t\t\tthis.root = options.root;\n\t\t\tdetermineNameAndNamespace( this, options.name );\n\t\t\t// if it's an empty attribute, or just a straight key-value pair, with no\n\t\t\t// mustache shenanigans, set the attribute accordingly and go home\n\t\t\tif ( !options.value || typeof options.value === 'string' ) {\n\t\t\t\tthis.value = booleanAttributes.test( this.name ) ? true : options.value || '';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// otherwise we need to do some work\n\t\t\t// share parentFragment with parent element\n\t\t\tthis.parentFragment = this.element.parentFragment;\n\t\t\tthis.fragment = new Fragment( {\n\t\t\t\ttemplate: options.value,\n\t\t\t\troot: this.root,\n\t\t\t\towner: this\n\t\t\t} );\n\t\t\tthis.value = this.fragment.getValue();\n\t\t\t// Store a reference to this attribute's interpolator, if its fragment\n\t\t\t// takes the form `{{foo}}`. This is necessary for two-way binding and\n\t\t\t// for correctly rendering HTML later\n\t\t\tthis.interpolator = getInterpolator( this );\n\t\t\tthis.isBindable = !!this.interpolator && !this.interpolator.isStatic;\n\t\t\t// can we establish this attribute's property name equivalent?\n\t\t\tdeterminePropertyName( this, options );\n\t\t\t// mark as ready\n\t\t\tthis.ready = true;\n\t\t};\n\t}( types, booleanAttributes, determineNameAndNamespace, getInterpolator, determinePropertyName, circular );\n\n\t/* virtualdom/items/Element/Attribute/prototype/rebind.js */\n\tvar virtualdom_items_Element_Attribute$rebind = function Attribute$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/render.js */\n\tvar virtualdom_items_Element_Attribute$render = function( namespaces, booleanAttributes ) {\n\n\t\tvar propertyNames = {\n\t\t\t'accept-charset': 'acceptCharset',\n\t\t\t'accesskey': 'accessKey',\n\t\t\t'bgcolor': 'bgColor',\n\t\t\t'class': 'className',\n\t\t\t'codebase': 'codeBase',\n\t\t\t'colspan': 'colSpan',\n\t\t\t'contenteditable': 'contentEditable',\n\t\t\t'datetime': 'dateTime',\n\t\t\t'dirname': 'dirName',\n\t\t\t'for': 'htmlFor',\n\t\t\t'http-equiv': 'httpEquiv',\n\t\t\t'ismap': 'isMap',\n\t\t\t'maxlength': 'maxLength',\n\t\t\t'novalidate': 'noValidate',\n\t\t\t'pubdate': 'pubDate',\n\t\t\t'readonly': 'readOnly',\n\t\t\t'rowspan': 'rowSpan',\n\t\t\t'tabindex': 'tabIndex',\n\t\t\t'usemap': 'useMap'\n\t\t};\n\t\treturn function Attribute$render( node ) {\n\t\t\tvar propertyName;\n\t\t\tthis.node = node;\n\t\t\t// should we use direct property access, or setAttribute?\n\t\t\tif ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {\n\t\t\t\tpropertyName = propertyNames[ this.name ] || this.name;\n\t\t\t\tif ( node[ propertyName ] !== undefined ) {\n\t\t\t\t\tthis.propertyName = propertyName;\n\t\t\t\t}\n\t\t\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n\t\t\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n\t\t\t\tif ( booleanAttributes.test( propertyName ) || propertyName === 'value' ) {\n\t\t\t\t\tthis.useProperty = true;\n\t\t\t\t}\n\t\t\t\tif ( propertyName === 'value' ) {\n\t\t\t\t\tthis.useProperty = true;\n\t\t\t\t\tnode._ractive.value = this.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.rendered = true;\n\t\t\tthis.update();\n\t\t};\n\t}( namespaces, booleanAttributes );\n\n\t/* virtualdom/items/Element/Attribute/prototype/toString.js */\n\tvar virtualdom_items_Element_Attribute$toString = function( booleanAttributes ) {\n\n\t\tvar __export;\n\t\t__export = function Attribute$toString() {\n\t\t\tvar name = ( fragment = this ).name,\n\t\t\t\tnamespacePrefix = fragment.namespacePrefix,\n\t\t\t\tvalue = fragment.value,\n\t\t\t\tinterpolator = fragment.interpolator,\n\t\t\t\tfragment = fragment.fragment;\n\t\t\t// Special case - select and textarea values (should not be stringified)\n\t\t\tif ( name === 'value' && ( this.element.name === 'select' || this.element.name === 'textarea' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Special case - content editable\n\t\t\tif ( name === 'value' && this.element.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Special case - radio names\n\t\t\tif ( name === 'name' && this.element.name === 'input' && interpolator ) {\n\t\t\t\treturn 'name={{' + ( interpolator.keypath || interpolator.ref ) + '}}';\n\t\t\t}\n\t\t\t// Boolean attributes\n\t\t\tif ( booleanAttributes.test( name ) ) {\n\t\t\t\treturn value ? name : '';\n\t\t\t}\n\t\t\tif ( fragment ) {\n\t\t\t\tvalue = fragment.toString();\n\t\t\t}\n\t\t\tif ( namespacePrefix ) {\n\t\t\t\tname = namespacePrefix + ':' + name;\n\t\t\t}\n\t\t\treturn value ? name + '=\"' + escape( value ) + '\"' : name;\n\t\t};\n\n\t\tfunction escape( value ) {\n\t\t\treturn value.replace( /&/g, '&amp;' ).replace( /\"/g, '&quot;' ).replace( /'/g, '&#39;' );\n\t\t}\n\t\treturn __export;\n\t}( booleanAttributes );\n\n\t/* virtualdom/items/Element/Attribute/prototype/unbind.js */\n\tvar virtualdom_items_Element_Attribute$unbind = function Attribute$unbind() {\n\t\t// ignore non-dynamic attributes\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t}\n\t\tif ( this.name === 'id' ) {\n\t\t\tdelete this.root.nodes[ this.value ];\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js */\n\tvar virtualdom_items_Element_Attribute$update_updateSelectValue = function Attribute$updateSelect() {\n\t\tvar value = this.value,\n\t\t\toptions, option, optionValue, i;\n\t\tif ( !this.locked ) {\n\t\t\tthis.node._ractive.value = value;\n\t\t\toptions = this.node.options;\n\t\t\ti = options.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\toption = options[ i ];\n\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\t// options inserted via a triple don't have _ractive\n\t\t\t\tif ( optionValue == value ) {\n\t\t\t\t\t// double equals as we may be comparing numbers with strings\n\t\t\t\t\toption.selected = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/* utils/arrayContains.js */\n\tvar arrayContains = function arrayContains( array, value ) {\n\t\tfor ( var i = 0, c = array.length; i < c; i++ ) {\n\t\t\tif ( array[ i ] == value ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js */\n\tvar virtualdom_items_Element_Attribute$update_updateMultipleSelectValue = function( arrayContains, isArray ) {\n\n\t\treturn function Attribute$updateMultipleSelect() {\n\t\t\tvar value = this.value,\n\t\t\t\toptions, i, option, optionValue;\n\t\t\tif ( !isArray( value ) ) {\n\t\t\t\tvalue = [ value ];\n\t\t\t}\n\t\t\toptions = this.node.options;\n\t\t\ti = options.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\toption = options[ i ];\n\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\t// options inserted via a triple don't have _ractive\n\t\t\t\toption.selected = arrayContains( value, optionValue );\n\t\t\t}\n\t\t};\n\t}( arrayContains, isArray );\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js */\n\tvar virtualdom_items_Element_Attribute$update_updateRadioName = function Attribute$updateRadioName() {\n\t\tvar node = ( value = this ).node,\n\t\t\tvalue = value.value;\n\t\tnode.checked = value == node._ractive.value;\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js */\n\tvar virtualdom_items_Element_Attribute$update_updateRadioValue = function( runloop ) {\n\n\t\treturn function Attribute$updateRadioValue() {\n\t\t\tvar wasChecked, node = this.node,\n\t\t\t\tbinding, bindings, i;\n\t\t\twasChecked = node.checked;\n\t\t\tnode.value = this.element.getAttribute( 'value' );\n\t\t\tnode.checked = this.element.getAttribute( 'value' ) === this.element.getAttribute( 'name' );\n\t\t\t// This is a special case - if the input was checked, and the value\n\t\t\t// changed so that it's no longer checked, the twoway binding is\n\t\t\t// most likely out of date. To fix it we have to jump through some\n\t\t\t// hoops... this is a little kludgy but it works\n\t\t\tif ( wasChecked && !node.checked && this.element.binding ) {\n\t\t\t\tbindings = this.element.binding.siblings;\n\t\t\t\tif ( i = bindings.length ) {\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tbinding = bindings[ i ];\n\t\t\t\t\t\tif ( !binding.element.node ) {\n\t\t\t\t\t\t\t// this is the initial render, siblings are still rendering!\n\t\t\t\t\t\t\t// we'll come back later...\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( binding.element.node.checked ) {\n\t\t\t\t\t\t\trunloop.addViewmodel( binding.root.viewmodel );\n\t\t\t\t\t\t\treturn binding.handleChange();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trunloop.addViewmodel( binding.root.viewmodel );\n\t\t\t\t\tthis.root.viewmodel.set( binding.keypath, undefined );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}( runloop );\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js */\n\tvar virtualdom_items_Element_Attribute$update_updateCheckboxName = function( isArray ) {\n\n\t\treturn function Attribute$updateCheckboxName() {\n\t\t\tvar element = ( value = this ).element,\n\t\t\t\tnode = value.node,\n\t\t\t\tvalue = value.value,\n\t\t\t\tvalueAttribute, i;\n\t\t\tvalueAttribute = element.getAttribute( 'value' );\n\t\t\tif ( !isArray( value ) ) {\n\t\t\t\tnode.checked = value == valueAttribute;\n\t\t\t} else {\n\t\t\t\ti = value.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( valueAttribute == value[ i ] ) {\n\t\t\t\t\t\tnode.checked = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}( isArray );\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateClassName.js */\n\tvar virtualdom_items_Element_Attribute$update_updateClassName = function Attribute$updateClassName() {\n\t\tvar node, value;\n\t\tnode = this.node;\n\t\tvalue = this.value;\n\t\tif ( value === undefined ) {\n\t\t\tvalue = '';\n\t\t}\n\t\tnode.className = value;\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js */\n\tvar virtualdom_items_Element_Attribute$update_updateIdAttribute = function Attribute$updateIdAttribute() {\n\t\tvar node = ( value = this ).node,\n\t\t\tvalue = value.value;\n\t\tthis.root.nodes[ value ] = node;\n\t\tnode.id = value;\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js */\n\tvar virtualdom_items_Element_Attribute$update_updateIEStyleAttribute = function Attribute$updateIEStyleAttribute() {\n\t\tvar node, value;\n\t\tnode = this.node;\n\t\tvalue = this.value;\n\t\tif ( value === undefined ) {\n\t\t\tvalue = '';\n\t\t}\n\t\tnode.style.setAttribute( 'cssText', value );\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js */\n\tvar virtualdom_items_Element_Attribute$update_updateContentEditableValue = function Attribute$updateContentEditableValue() {\n\t\tvar value = this.value;\n\t\tif ( value === undefined ) {\n\t\t\tvalue = '';\n\t\t}\n\t\tif ( !this.locked ) {\n\t\t\tthis.node.innerHTML = value;\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateValue.js */\n\tvar virtualdom_items_Element_Attribute$update_updateValue = function Attribute$updateValue() {\n\t\tvar node = ( value = this ).node,\n\t\t\tvalue = value.value;\n\t\t// store actual value, so it doesn't get coerced to a string\n\t\tnode._ractive.value = value;\n\t\t// with two-way binding, only update if the change wasn't initiated by the user\n\t\t// otherwise the cursor will often be sent to the wrong place\n\t\tif ( !this.locked ) {\n\t\t\tnode.value = value == undefined ? '' : value;\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js */\n\tvar virtualdom_items_Element_Attribute$update_updateBoolean = function Attribute$updateBooleanAttribute() {\n\t\t// with two-way binding, only update if the change wasn't initiated by the user\n\t\t// otherwise the cursor will often be sent to the wrong place\n\t\tif ( !this.locked ) {\n\t\t\tthis.node[ this.propertyName ] = this.value;\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js */\n\tvar virtualdom_items_Element_Attribute$update_updateEverythingElse = function( booleanAttributes ) {\n\n\t\treturn function Attribute$updateEverythingElse() {\n\t\t\tvar node = ( fragment = this ).node,\n\t\t\t\tnamespace = fragment.namespace,\n\t\t\t\tname = fragment.name,\n\t\t\t\tvalue = fragment.value,\n\t\t\t\tfragment = fragment.fragment;\n\t\t\tif ( namespace ) {\n\t\t\t\tnode.setAttributeNS( namespace, name, ( fragment || value ).toString() );\n\t\t\t} else if ( !booleanAttributes.test( name ) ) {\n\t\t\t\tnode.setAttribute( name, ( fragment || value ).toString() );\n\t\t\t} else {\n\t\t\t\tif ( value ) {\n\t\t\t\t\tnode.setAttribute( name, '' );\n\t\t\t\t} else {\n\t\t\t\t\tnode.removeAttribute( name );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}( booleanAttributes );\n\n\t/* virtualdom/items/Element/Attribute/prototype/update.js */\n\tvar virtualdom_items_Element_Attribute$update = function( namespaces, noop, updateSelectValue, updateMultipleSelectValue, updateRadioName, updateRadioValue, updateCheckboxName, updateClassName, updateIdAttribute, updateIEStyleAttribute, updateContentEditableValue, updateValue, updateBoolean, updateEverythingElse ) {\n\n\t\treturn function Attribute$update() {\n\t\t\tvar name = ( node = this ).name,\n\t\t\t\telement = node.element,\n\t\t\t\tnode = node.node,\n\t\t\t\ttype, updateMethod;\n\t\t\tif ( name === 'id' ) {\n\t\t\t\tupdateMethod = updateIdAttribute;\n\t\t\t} else if ( name === 'value' ) {\n\t\t\t\t// special case - selects\n\t\t\t\tif ( element.name === 'select' && name === 'value' ) {\n\t\t\t\t\tupdateMethod = element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;\n\t\t\t\t} else if ( element.name === 'textarea' ) {\n\t\t\t\t\tupdateMethod = updateValue;\n\t\t\t\t} else if ( element.getAttribute( 'contenteditable' ) != null ) {\n\t\t\t\t\tupdateMethod = updateContentEditableValue;\n\t\t\t\t} else if ( element.name === 'input' ) {\n\t\t\t\t\ttype = element.getAttribute( 'type' );\n\t\t\t\t\t// type='file' value='{{fileList}}'>\n\t\t\t\t\tif ( type === 'file' ) {\n\t\t\t\t\t\tupdateMethod = noop;\n\t\t\t\t\t} else if ( type === 'radio' && element.binding && element.binding.name === 'name' ) {\n\t\t\t\t\t\tupdateMethod = updateRadioValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdateMethod = updateValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( this.twoway && name === 'name' ) {\n\t\t\t\tif ( node.type === 'radio' ) {\n\t\t\t\t\tupdateMethod = updateRadioName;\n\t\t\t\t} else if ( node.type === 'checkbox' ) {\n\t\t\t\t\tupdateMethod = updateCheckboxName;\n\t\t\t\t}\n\t\t\t} else if ( name === 'style' && node.style.setAttribute ) {\n\t\t\t\tupdateMethod = updateIEStyleAttribute;\n\t\t\t} else if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) {\n\t\t\t\tupdateMethod = updateClassName;\n\t\t\t} else if ( this.useProperty ) {\n\t\t\t\tupdateMethod = updateBoolean;\n\t\t\t}\n\t\t\tif ( !updateMethod ) {\n\t\t\t\tupdateMethod = updateEverythingElse;\n\t\t\t}\n\t\t\tthis.update = updateMethod;\n\t\t\tthis.update();\n\t\t};\n\t}( namespaces, noop, virtualdom_items_Element_Attribute$update_updateSelectValue, virtualdom_items_Element_Attribute$update_updateMultipleSelectValue, virtualdom_items_Element_Attribute$update_updateRadioName, virtualdom_items_Element_Attribute$update_updateRadioValue, virtualdom_items_Element_Attribute$update_updateCheckboxName, virtualdom_items_Element_Attribute$update_updateClassName, virtualdom_items_Element_Attribute$update_updateIdAttribute, virtualdom_items_Element_Attribute$update_updateIEStyleAttribute, virtualdom_items_Element_Attribute$update_updateContentEditableValue, virtualdom_items_Element_Attribute$update_updateValue, virtualdom_items_Element_Attribute$update_updateBoolean, virtualdom_items_Element_Attribute$update_updateEverythingElse );\n\n\t/* virtualdom/items/Element/Attribute/_Attribute.js */\n\tvar Attribute = function( bubble, init, rebind, render, toString, unbind, update ) {\n\n\t\tvar Attribute = function( options ) {\n\t\t\tthis.init( options );\n\t\t};\n\t\tAttribute.prototype = {\n\t\t\tbubble: bubble,\n\t\t\tinit: init,\n\t\t\trebind: rebind,\n\t\t\trender: render,\n\t\t\ttoString: toString,\n\t\t\tunbind: unbind,\n\t\t\tupdate: update\n\t\t};\n\t\treturn Attribute;\n\t}( virtualdom_items_Element_Attribute$bubble, virtualdom_items_Element_Attribute$init, virtualdom_items_Element_Attribute$rebind, virtualdom_items_Element_Attribute$render, virtualdom_items_Element_Attribute$toString, virtualdom_items_Element_Attribute$unbind, virtualdom_items_Element_Attribute$update );\n\n\t/* virtualdom/items/Element/prototype/init/createAttributes.js */\n\tvar virtualdom_items_Element$init_createAttributes = function( Attribute ) {\n\n\t\treturn function( element, attributes ) {\n\t\t\tvar name, attribute, result = [];\n\t\t\tfor ( name in attributes ) {\n\t\t\t\tif ( attributes.hasOwnProperty( name ) ) {\n\t\t\t\t\tattribute = new Attribute( {\n\t\t\t\t\t\telement: element,\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: attributes[ name ],\n\t\t\t\t\t\troot: element.root\n\t\t\t\t\t} );\n\t\t\t\t\tresult.push( result[ name ] = attribute );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t}( Attribute );\n\n\t/* virtualdom/items/Element/ConditionalAttribute/_ConditionalAttribute.js */\n\tvar ConditionalAttribute = function( circular, namespaces, createElement, toArray ) {\n\n\t\tvar __export;\n\t\tvar Fragment, div;\n\t\tif ( typeof document !== 'undefined' ) {\n\t\t\tdiv = createElement( 'div' );\n\t\t}\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\tvar ConditionalAttribute = function( element, template ) {\n\t\t\tthis.element = element;\n\t\t\tthis.root = element.root;\n\t\t\tthis.parentFragment = element.parentFragment;\n\t\t\tthis.attributes = [];\n\t\t\tthis.fragment = new Fragment( {\n\t\t\t\troot: element.root,\n\t\t\t\towner: this,\n\t\t\t\ttemplate: [ template ]\n\t\t\t} );\n\t\t};\n\t\tConditionalAttribute.prototype = {\n\t\t\tbubble: function() {\n\t\t\t\tif ( this.node ) {\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t\tthis.element.bubble();\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t},\n\t\t\trender: function( node ) {\n\t\t\t\tthis.node = node;\n\t\t\t\tthis.isSvg = node.namespaceURI === namespaces.svg;\n\t\t\t\tthis.update();\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tthis.fragment.unbind();\n\t\t\t},\n\t\t\tupdate: function() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar str, attrs;\n\t\t\t\tstr = this.fragment.toString();\n\t\t\t\tattrs = parseAttributes( str, this.isSvg );\n\t\t\t\t// any attributes that previously existed but no longer do\n\t\t\t\t// must be removed\n\t\t\t\tthis.attributes.filter( function( a ) {\n\t\t\t\t\treturn notIn( attrs, a );\n\t\t\t\t} ).forEach( function( a ) {\n\t\t\t\t\tthis$0.node.removeAttribute( a.name );\n\t\t\t\t} );\n\t\t\t\tattrs.forEach( function( a ) {\n\t\t\t\t\tthis$0.node.setAttribute( a.name, a.value );\n\t\t\t\t} );\n\t\t\t\tthis.attributes = attrs;\n\t\t\t},\n\t\t\ttoString: function() {\n\t\t\t\treturn this.fragment.toString();\n\t\t\t}\n\t\t};\n\t\t__export = ConditionalAttribute;\n\n\t\tfunction parseAttributes( str, isSvg ) {\n\t\t\tvar tag = isSvg ? 'svg' : 'div';\n\t\t\tdiv.innerHTML = '<' + tag + ' ' + str + '></' + tag + '>';\n\t\t\treturn toArray( div.childNodes[ 0 ].attributes );\n\t\t}\n\n\t\tfunction notIn( haystack, needle ) {\n\t\t\tvar i = haystack.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( haystack[ i ].name === needle.name ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn __export;\n\t}( circular, namespaces, createElement, toArray );\n\n\t/* virtualdom/items/Element/prototype/init/createConditionalAttributes.js */\n\tvar virtualdom_items_Element$init_createConditionalAttributes = function( ConditionalAttribute ) {\n\n\t\treturn function( element, attributes ) {\n\t\t\tif ( !attributes ) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\treturn attributes.map( function( a ) {\n\t\t\t\treturn new ConditionalAttribute( element, a );\n\t\t\t} );\n\t\t};\n\t}( ConditionalAttribute );\n\n\t/* utils/extend.js */\n\tvar extend = function( target ) {\n\t\tvar SLICE$0 = Array.prototype.slice;\n\t\tvar sources = SLICE$0.call( arguments, 1 );\n\t\tvar prop, source;\n\t\twhile ( source = sources.shift() ) {\n\t\t\tfor ( prop in source ) {\n\t\t\t\tif ( source.hasOwnProperty( prop ) ) {\n\t\t\t\t\ttarget[ prop ] = source[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t};\n\n\t/* virtualdom/items/Element/Binding/Binding.js */\n\tvar Binding = function( runloop, warn, create, extend, removeFromArray ) {\n\n\t\tvar Binding = function( element ) {\n\t\t\tvar interpolator, keypath, value;\n\t\t\tthis.element = element;\n\t\t\tthis.root = element.root;\n\t\t\tthis.attribute = element.attributes[ this.name || 'value' ];\n\t\t\tinterpolator = this.attribute.interpolator;\n\t\t\tinterpolator.twowayBinding = this;\n\t\t\tif ( interpolator.keypath && interpolator.keypath.substr === '${' ) {\n\t\t\t\twarn( 'Two-way binding does not work with expressions: ' + interpolator.keypath );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// A mustache may be *ambiguous*. Let's say we were given\n\t\t\t// `value=\"{{bar}}\"`. If the context was `foo`, and `foo.bar`\n\t\t\t// *wasn't* `undefined`, the keypath would be `foo.bar`.\n\t\t\t// Then, any user input would result in `foo.bar` being updated.\n\t\t\t//\n\t\t\t// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be\n\t\t\t// left with an unresolved partial keypath - so we are forced to make an\n\t\t\t// assumption. That assumption is that the input in question should\n\t\t\t// be forced to resolve to `bar`, and any user input would affect `bar`\n\t\t\t// and not `foo.bar`.\n\t\t\t//\n\t\t\t// Did that make any sense? No? Oh. Sorry. Well the moral of the story is\n\t\t\t// be explicit when using two-way data-binding about what keypath you're\n\t\t\t// updating. Using it in lists is probably a recipe for confusion...\n\t\t\tif ( !interpolator.keypath ) {\n\t\t\t\tif ( interpolator.ref ) {\n\t\t\t\t\tinterpolator.resolve( interpolator.ref );\n\t\t\t\t}\n\t\t\t\t// If we have a reference expression resolver, we have to force\n\t\t\t\t// members to attach themselves to the root\n\t\t\t\tif ( interpolator.resolver ) {\n\t\t\t\t\tinterpolator.resolver.forceResolution();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.keypath = keypath = interpolator.keypath;\n\t\t\t// initialise value, if it's undefined\n\t\t\tif ( this.root.viewmodel.get( keypath ) === undefined && this.getInitialValue ) {\n\t\t\t\tvalue = this.getInitialValue();\n\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\tthis.root.viewmodel.set( keypath, value );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tBinding.prototype = {\n\t\t\thandleChange: function() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\trunloop.start( this.root );\n\t\t\t\tthis.attribute.locked = true;\n\t\t\t\tthis.root.viewmodel.set( this.keypath, this.getValue() );\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\treturn this$0.attribute.locked = false;\n\t\t\t\t} );\n\t\t\t\trunloop.end();\n\t\t\t},\n\t\t\trebound: function() {\n\t\t\t\tvar bindings, oldKeypath, newKeypath;\n\t\t\t\toldKeypath = this.keypath;\n\t\t\t\tnewKeypath = this.attribute.interpolator.keypath;\n\t\t\t\t// The attribute this binding is linked to has already done the work\n\t\t\t\tif ( oldKeypath === newKeypath ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tremoveFromArray( this.root._twowayBindings[ oldKeypath ], this );\n\t\t\t\tthis.keypath = newKeypath;\n\t\t\t\tbindings = this.root._twowayBindings[ newKeypath ] || ( this.root._twowayBindings[ newKeypath ] = [] );\n\t\t\t\tbindings.push( this );\n\t\t\t},\n\t\t\tunbind: function() {}\n\t\t};\n\t\tBinding.extend = function( properties ) {\n\t\t\tvar Parent = this,\n\t\t\t\tSpecialisedBinding;\n\t\t\tSpecialisedBinding = function( element ) {\n\t\t\t\tBinding.call( this, element );\n\t\t\t\tif ( this.init ) {\n\t\t\t\t\tthis.init();\n\t\t\t\t}\n\t\t\t};\n\t\t\tSpecialisedBinding.prototype = create( Parent.prototype );\n\t\t\textend( SpecialisedBinding.prototype, properties );\n\t\t\tSpecialisedBinding.extend = Binding.extend;\n\t\t\treturn SpecialisedBinding;\n\t\t};\n\t\treturn Binding;\n\t}( runloop, warn, create, extend, removeFromArray );\n\n\t/* virtualdom/items/Element/Binding/shared/handleDomEvent.js */\n\tvar handleDomEvent = function handleChange() {\n\t\tthis._ractive.binding.handleChange();\n\t};\n\n\t/* virtualdom/items/Element/Binding/ContentEditableBinding.js */\n\tvar ContentEditableBinding = function( Binding, handleDomEvent ) {\n\n\t\tvar ContentEditableBinding = Binding.extend( {\n\t\t\tgetInitialValue: function() {\n\t\t\t\treturn this.element.fragment ? this.element.fragment.toString() : '';\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\tif ( !this.root.lazy ) {\n\t\t\t\t\tnode.addEventListener( 'input', handleDomEvent, false );\n\t\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\t\tnode.addEventListener( 'keyup', handleDomEvent, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'input', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'keyup', handleDomEvent, false );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\treturn this.element.node.innerHTML;\n\t\t\t}\n\t\t} );\n\t\treturn ContentEditableBinding;\n\t}( Binding, handleDomEvent );\n\n\t/* virtualdom/items/Element/Binding/shared/getSiblings.js */\n\tvar getSiblings = function() {\n\n\t\tvar sets = {};\n\t\treturn function getSiblings( id, group, keypath ) {\n\t\t\tvar hash = id + group + keypath;\n\t\t\treturn sets[ hash ] || ( sets[ hash ] = [] );\n\t\t};\n\t}();\n\n\t/* virtualdom/items/Element/Binding/RadioBinding.js */\n\tvar RadioBinding = function( runloop, removeFromArray, Binding, getSiblings, handleDomEvent ) {\n\n\t\tvar RadioBinding = Binding.extend( {\n\t\t\tname: 'checked',\n\t\t\tinit: function() {\n\t\t\t\tthis.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );\n\t\t\t\tthis.siblings.push( this );\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t},\n\t\t\thandleChange: function() {\n\t\t\t\trunloop.start( this.root );\n\t\t\t\tthis.siblings.forEach( function( binding ) {\n\t\t\t\t\tbinding.root.viewmodel.set( binding.keypath, binding.getValue() );\n\t\t\t\t} );\n\t\t\t\trunloop.end();\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\treturn this.element.node.checked;\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tremoveFromArray( this.siblings, this );\n\t\t\t}\n\t\t} );\n\t\treturn RadioBinding;\n\t}( runloop, removeFromArray, Binding, getSiblings, handleDomEvent );\n\n\t/* virtualdom/items/Element/Binding/RadioNameBinding.js */\n\tvar RadioNameBinding = function( removeFromArray, Binding, handleDomEvent, getSiblings ) {\n\n\t\tvar RadioNameBinding = Binding.extend( {\n\t\t\tname: 'name',\n\t\t\tinit: function() {\n\t\t\t\tthis.siblings = getSiblings( this.root._guid, 'radioname', this.keypath );\n\t\t\t\tthis.siblings.push( this );\n\t\t\t\tthis.radioName = true;\n\t\t\t\t// so that ractive.updateModel() knows what to do with this\n\t\t\t\tthis.attribute.twoway = true;\n\t\t\t},\n\t\t\tgetInitialValue: function() {\n\t\t\t\tif ( this.element.getAttribute( 'checked' ) ) {\n\t\t\t\t\treturn this.element.getAttribute( 'value' );\n\t\t\t\t}\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.name = '{{' + this.keypath + '}}';\n\t\t\t\tnode.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\treturn node._ractive ? node._ractive.value : node.value;\n\t\t\t},\n\t\t\thandleChange: function() {\n\t\t\t\t// If this <input> is the one that's checked, then the value of its\n\t\t\t\t// `name` keypath gets set to its value\n\t\t\t\tif ( this.element.node.checked ) {\n\t\t\t\t\tBinding.prototype.handleChange.call( this );\n\t\t\t\t}\n\t\t\t},\n\t\t\trebound: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tvar node;\n\t\t\t\tBinding.prototype.rebound.call( this, indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\tif ( node = this.element.node ) {\n\t\t\t\t\tnode.name = '{{' + this.keypath + '}}';\n\t\t\t\t}\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tremoveFromArray( this.siblings, this );\n\t\t\t}\n\t\t} );\n\t\treturn RadioNameBinding;\n\t}( removeFromArray, Binding, handleDomEvent, getSiblings );\n\n\t/* virtualdom/items/Element/Binding/CheckboxNameBinding.js */\n\tvar CheckboxNameBinding = function( isArray, removeFromArray, Binding, getSiblings, handleDomEvent ) {\n\n\t\tvar CheckboxNameBinding = Binding.extend( {\n\t\t\tname: 'name',\n\t\t\tgetInitialValue: function() {\n\t\t\t\t// This only gets called once per group (of inputs that\n\t\t\t\t// share a name), because it only gets called if there\n\t\t\t\t// isn't an initial value. By the same token, we can make\n\t\t\t\t// a note of that fact that there was no initial value,\n\t\t\t\t// and populate it using any `checked` attributes that\n\t\t\t\t// exist (which users should avoid, but which we should\n\t\t\t\t// support anyway to avoid breaking expectations)\n\t\t\t\tthis.noInitialValue = true;\n\t\t\t\treturn [];\n\t\t\t},\n\t\t\tinit: function() {\n\t\t\t\tvar existingValue, bindingValue, noInitialValue;\n\t\t\t\tthis.checkboxName = true;\n\t\t\t\t// so that ractive.updateModel() knows what to do with this\n\t\t\t\tthis.attribute.twoway = true;\n\t\t\t\t// we set this property so that the attribute gets the correct update method\n\t\t\t\t// Each input has a reference to an array containing it and its\n\t\t\t\t// siblings, as two-way binding depends on being able to ascertain\n\t\t\t\t// the status of all inputs within the group\n\t\t\t\tthis.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath );\n\t\t\t\tthis.siblings.push( this );\n\t\t\t\tif ( this.noInitialValue ) {\n\t\t\t\t\tthis.siblings.noInitialValue = true;\n\t\t\t\t}\n\t\t\t\tnoInitialValue = this.siblings.noInitialValue;\n\t\t\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\t\t\tbindingValue = this.element.getAttribute( 'value' );\n\t\t\t\tif ( noInitialValue ) {\n\t\t\t\t\tthis.isChecked = this.element.getAttribute( 'checked' );\n\t\t\t\t\tif ( this.isChecked ) {\n\t\t\t\t\t\texistingValue.push( bindingValue );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.shouldOverride = true;\n\t\t\t\t}\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tremoveFromArray( this.siblings, this );\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tvar node = this.element.node,\n\t\t\t\t\texistingValue, bindingValue, i;\n\t\t\t\tif ( this.shouldOverride ) {\n\t\t\t\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\t\t\t\tbindingValue = this.element.getAttribute( 'value' );\n\t\t\t\t\tif ( isArray( existingValue ) ) {\n\t\t\t\t\t\ti = existingValue.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( existingValue[ i ] == bindingValue ) {\n\t\t\t\t\t\t\t\tthis.isChecked = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.isChecked = existingValue == bindingValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.name = '{{' + this.keypath + '}}';\n\t\t\t\tnode.checked = this.isChecked;\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\t// in case of IE emergency, bind to click event as well\n\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t},\n\t\t\tchanged: function() {\n\t\t\t\tvar wasChecked = !!this.isChecked;\n\t\t\t\tthis.isChecked = this.element.node.checked;\n\t\t\t\treturn this.isChecked === wasChecked;\n\t\t\t},\n\t\t\thandleChange: function() {\n\t\t\t\tthis.isChecked = this.element.node.checked;\n\t\t\t\tBinding.prototype.handleChange.call( this );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\treturn this.siblings.filter( isChecked ).map( getValue );\n\t\t\t}\n\t\t} );\n\n\t\tfunction isChecked( binding ) {\n\t\t\treturn binding.isChecked;\n\t\t}\n\n\t\tfunction getValue( binding ) {\n\t\t\treturn binding.element.getAttribute( 'value' );\n\t\t}\n\t\treturn CheckboxNameBinding;\n\t}( isArray, removeFromArray, Binding, getSiblings, handleDomEvent );\n\n\t/* virtualdom/items/Element/Binding/CheckboxBinding.js */\n\tvar CheckboxBinding = function( Binding, handleDomEvent ) {\n\n\t\tvar CheckboxBinding = Binding.extend( {\n\t\t\tname: 'checked',\n\t\t\trender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\treturn this.element.node.checked;\n\t\t\t}\n\t\t} );\n\t\treturn CheckboxBinding;\n\t}( Binding, handleDomEvent );\n\n\t/* virtualdom/items/Element/Binding/SelectBinding.js */\n\tvar SelectBinding = function( runloop, Binding, handleDomEvent ) {\n\n\t\tvar SelectBinding = Binding.extend( {\n\t\t\tgetInitialValue: function() {\n\t\t\t\tvar options = this.element.options,\n\t\t\t\t\tlen, i, value, optionWasSelected;\n\t\t\t\tif ( this.element.getAttribute( 'value' ) !== undefined ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ti = len = options.length;\n\t\t\t\tif ( !len ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// take the final selected option...\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( options[ i ].getAttribute( 'selected' ) ) {\n\t\t\t\t\t\tvalue = options[ i ].getAttribute( 'value' );\n\t\t\t\t\t\toptionWasSelected = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// or the first non-disabled option, if none are selected\n\t\t\t\tif ( !optionWasSelected ) {\n\t\t\t\t\twhile ( ++i < len ) {\n\t\t\t\t\t\tif ( !options[ i ].getAttribute( 'disabled' ) ) {\n\t\t\t\t\t\t\tvalue = options[ i ].getAttribute( 'value' );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// This is an optimisation (aka hack) that allows us to forgo some\n\t\t\t\t// other more expensive work\n\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\tthis.element.attributes.value.value = value;\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t},\n\t\t\t// TODO this method is an anomaly... is it necessary?\n\t\t\tsetValue: function( value ) {\n\t\t\t\trunloop.addViewmodel( this.root.viewmodel );\n\t\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\tvar options, i, len, option, optionValue;\n\t\t\t\toptions = this.element.node.options;\n\t\t\t\tlen = options.length;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( options[ i ].selected ) {\n\t\t\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\t\t\treturn optionValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tforceUpdate: function() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar value = this.getValue();\n\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\tthis.attribute.locked = true;\n\t\t\t\t\trunloop.addViewmodel( this.root.viewmodel );\n\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\treturn this$0.attribute.locked = false;\n\t\t\t\t\t} );\n\t\t\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\treturn SelectBinding;\n\t}( runloop, Binding, handleDomEvent );\n\n\t/* utils/arrayContentsMatch.js */\n\tvar arrayContentsMatch = function( isArray ) {\n\n\t\treturn function( a, b ) {\n\t\t\tvar i;\n\t\t\tif ( !isArray( a ) || !isArray( b ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( a.length !== b.length ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti = a.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( a[ i ] !== b[ i ] ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t}( isArray );\n\n\t/* virtualdom/items/Element/Binding/MultipleSelectBinding.js */\n\tvar MultipleSelectBinding = function( runloop, arrayContentsMatch, SelectBinding, handleDomEvent ) {\n\n\t\tvar MultipleSelectBinding = SelectBinding.extend( {\n\t\t\tgetInitialValue: function() {\n\t\t\t\treturn this.element.options.filter( function( option ) {\n\t\t\t\t\treturn option.getAttribute( 'selected' );\n\t\t\t\t} ).map( function( option ) {\n\t\t\t\t\treturn option.getAttribute( 'value' );\n\t\t\t\t} );\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tvar valueFromModel;\n\t\t\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\tvalueFromModel = this.root.viewmodel.get( this.keypath );\n\t\t\t\tif ( valueFromModel === undefined ) {\n\t\t\t\t\t// get value from DOM, if possible\n\t\t\t\t\tthis.handleChange();\n\t\t\t\t}\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t},\n\t\t\tsetValue: function() {\n\t\t\t\tthrow new Error( 'TODO not implemented yet' );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\tvar selectedValues, options, i, len, option, optionValue;\n\t\t\t\tselectedValues = [];\n\t\t\t\toptions = this.element.node.options;\n\t\t\t\tlen = options.length;\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( option.selected ) {\n\t\t\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\t\t\tselectedValues.push( optionValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn selectedValues;\n\t\t\t},\n\t\t\thandleChange: function() {\n\t\t\t\tvar attribute, previousValue, value;\n\t\t\t\tattribute = this.attribute;\n\t\t\t\tpreviousValue = attribute.value;\n\t\t\t\tvalue = this.getValue();\n\t\t\t\tif ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {\n\t\t\t\t\tSelectBinding.prototype.handleChange.call( this );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tforceUpdate: function() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar value = this.getValue();\n\t\t\t\tif ( value !== undefined ) {\n\t\t\t\t\tthis.attribute.locked = true;\n\t\t\t\t\trunloop.addViewmodel( this.root.viewmodel );\n\t\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\t\treturn this$0.attribute.locked = false;\n\t\t\t\t\t} );\n\t\t\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t\t\t}\n\t\t\t},\n\t\t\tupdateModel: function() {\n\t\t\t\tif ( this.attribute.value === undefined || !this.attribute.value.length ) {\n\t\t\t\t\tthis.root.viewmodel.set( this.keypath, this.initialValue );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\treturn MultipleSelectBinding;\n\t}( runloop, arrayContentsMatch, SelectBinding, handleDomEvent );\n\n\t/* virtualdom/items/Element/Binding/FileListBinding.js */\n\tvar FileListBinding = function( Binding, handleDomEvent ) {\n\n\t\tvar FileListBinding = Binding.extend( {\n\t\t\trender: function() {\n\t\t\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\treturn this.element.node.files;\n\t\t\t}\n\t\t} );\n\t\treturn FileListBinding;\n\t}( Binding, handleDomEvent );\n\n\t/* virtualdom/items/Element/Binding/GenericBinding.js */\n\tvar GenericBinding = function( Binding, handleDomEvent ) {\n\n\t\tvar __export;\n\t\tvar GenericBinding, getOptions;\n\t\tgetOptions = {\n\t\t\tevaluateWrapped: true\n\t\t};\n\t\tGenericBinding = Binding.extend( {\n\t\t\tgetInitialValue: function() {\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\treturn this.element.node.value;\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\t\t\tif ( !this.root.lazy ) {\n\t\t\t\t\tnode.addEventListener( 'input', handleDomEvent, false );\n\t\t\t\t\tif ( node.attachEvent ) {\n\t\t\t\t\t\tnode.addEventListener( 'keyup', handleDomEvent, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.addEventListener( 'blur', handleBlur, false );\n\t\t\t},\n\t\t\tunrender: function() {\n\t\t\t\tvar node = this.element.node;\n\t\t\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'input', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'keyup', handleDomEvent, false );\n\t\t\t\tnode.removeEventListener( 'blur', handleBlur, false );\n\t\t\t}\n\t\t} );\n\t\t__export = GenericBinding;\n\n\t\tfunction handleBlur() {\n\t\t\tvar value;\n\t\t\thandleDomEvent.call( this );\n\t\t\tvalue = this._ractive.root.viewmodel.get( this._ractive.binding.keypath, getOptions );\n\t\t\tthis.value = value == undefined ? '' : value;\n\t\t}\n\t\treturn __export;\n\t}( Binding, handleDomEvent );\n\n\t/* virtualdom/items/Element/Binding/NumericBinding.js */\n\tvar NumericBinding = function( GenericBinding ) {\n\n\t\treturn GenericBinding.extend( {\n\t\t\tgetInitialValue: function() {\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\tvar value = parseFloat( this.element.node.value );\n\t\t\t\treturn isNaN( value ) ? undefined : value;\n\t\t\t}\n\t\t} );\n\t}( GenericBinding );\n\n\t/* virtualdom/items/Element/prototype/init/createTwowayBinding.js */\n\tvar virtualdom_items_Element$init_createTwowayBinding = function( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding ) {\n\n\t\tvar __export;\n\t\t__export = function createTwowayBinding( element ) {\n\t\t\tvar attributes = element.attributes,\n\t\t\t\ttype, Binding, bindName, bindChecked;\n\t\t\t// if this is a late binding, and there's already one, it\n\t\t\t// needs to be torn down\n\t\t\tif ( element.binding ) {\n\t\t\t\telement.binding.teardown();\n\t\t\t\telement.binding = null;\n\t\t\t}\n\t\t\t// contenteditable\n\t\t\tif ( element.getAttribute( 'contenteditable' ) && isBindable( attributes.value ) ) {\n\t\t\t\tBinding = ContentEditableBinding;\n\t\t\t} else if ( element.name === 'input' ) {\n\t\t\t\ttype = element.getAttribute( 'type' );\n\t\t\t\tif ( type === 'radio' || type === 'checkbox' ) {\n\t\t\t\t\tbindName = isBindable( attributes.name );\n\t\t\t\t\tbindChecked = isBindable( attributes.checked );\n\t\t\t\t\t// we can either bind the name attribute, or the checked attribute - not both\n\t\t\t\t\tif ( bindName && bindChecked ) {\n\t\t\t\t\t\tlog.error( {\n\t\t\t\t\t\t\tmessage: 'badRadioInputBinding'\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\tif ( bindName ) {\n\t\t\t\t\t\tBinding = type === 'radio' ? RadioNameBinding : CheckboxNameBinding;\n\t\t\t\t\t} else if ( bindChecked ) {\n\t\t\t\t\t\tBinding = type === 'radio' ? RadioBinding : CheckboxBinding;\n\t\t\t\t\t}\n\t\t\t\t} else if ( type === 'file' && isBindable( attributes.value ) ) {\n\t\t\t\t\tBinding = FileListBinding;\n\t\t\t\t} else if ( isBindable( attributes.value ) ) {\n\t\t\t\t\tBinding = type === 'number' || type === 'range' ? NumericBinding : GenericBinding;\n\t\t\t\t}\n\t\t\t} else if ( element.name === 'select' && isBindable( attributes.value ) ) {\n\t\t\t\tBinding = element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SelectBinding;\n\t\t\t} else if ( element.name === 'textarea' && isBindable( attributes.value ) ) {\n\t\t\t\tBinding = GenericBinding;\n\t\t\t}\n\t\t\tif ( Binding ) {\n\t\t\t\treturn new Binding( element );\n\t\t\t}\n\t\t};\n\n\t\tfunction isBindable( attribute ) {\n\t\t\treturn attribute && attribute.isBindable;\n\t\t}\n\t\treturn __export;\n\t}( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding );\n\n\t/* virtualdom/items/Element/EventHandler/prototype/bubble.js */\n\tvar virtualdom_items_Element_EventHandler$bubble = function EventHandler$bubble() {\n\t\tvar hasAction = this.getAction();\n\t\tif ( hasAction && !this.hasListener ) {\n\t\t\tthis.listen();\n\t\t} else if ( !hasAction && this.hasListener ) {\n\t\t\tthis.unrender();\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/EventHandler/prototype/fire.js */\n\tvar virtualdom_items_Element_EventHandler$fire = function( fireEvent ) {\n\n\t\treturn function EventHandler$fire( event ) {\n\t\t\tfireEvent( this.root, this.getAction(), {\n\t\t\t\tevent: event\n\t\t\t} );\n\t\t};\n\t}( Ractive$shared_fireEvent );\n\n\t/* virtualdom/items/Element/EventHandler/prototype/getAction.js */\n\tvar virtualdom_items_Element_EventHandler$getAction = function EventHandler$getAction() {\n\t\treturn this.action.toString().trim();\n\t};\n\n\t/* virtualdom/items/Element/EventHandler/prototype/init.js */\n\tvar virtualdom_items_Element_EventHandler$init = function( removeFromArray, getFunctionFromString, resolveRef, Unresolved, circular, fireEvent, log ) {\n\n\t\tvar __export;\n\t\tvar Fragment, getValueOptions = {\n\t\t\t\targs: true\n\t\t\t},\n\t\t\teventPattern = /^event(?:\\.(.+))?/;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\t__export = function EventHandler$init( element, name, template ) {\n\t\t\tvar handler = this,\n\t\t\t\taction, args, indexRefs, ractive, parentFragment;\n\t\t\thandler.element = element;\n\t\t\thandler.root = element.root;\n\t\t\thandler.name = name;\n\t\t\tif ( name.indexOf( '*' ) !== -1 ) {\n\t\t\t\tlog.error( {\n\t\t\t\t\tdebug: this.root.debug,\n\t\t\t\t\tmessage: 'noElementProxyEventWildcards',\n\t\t\t\t\targs: {\n\t\t\t\t\t\telement: element.tagName,\n\t\t\t\t\t\tevent: name\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tthis.invalid = true;\n\t\t\t}\n\t\t\tif ( template.m ) {\n\t\t\t\t// This is a method call\n\t\t\t\thandler.method = template.m;\n\t\t\t\thandler.args = args = [];\n\t\t\t\thandler.unresolved = [];\n\t\t\t\thandler.refs = template.a.r;\n\t\t\t\thandler.fn = getFunctionFromString( template.a.s, handler.refs.length );\n\t\t\t\tparentFragment = element.parentFragment;\n\t\t\t\tindexRefs = parentFragment.indexRefs;\n\t\t\t\tractive = handler.root;\n\t\t\t\t// Create resolvers for each reference\n\t\t\t\ttemplate.a.r.forEach( function( reference, i ) {\n\t\t\t\t\tvar index, keypath, match, unresolved;\n\t\t\t\t\t// Is this an index reference?\n\t\t\t\t\tif ( indexRefs && ( index = indexRefs[ reference ] ) !== undefined ) {\n\t\t\t\t\t\targs[ i ] = {\n\t\t\t\t\t\t\tindexRef: reference,\n\t\t\t\t\t\t\tvalue: index\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( match = eventPattern.exec( reference ) ) {\n\t\t\t\t\t\targs[ i ] = {\n\t\t\t\t\t\t\teventObject: true,\n\t\t\t\t\t\t\trefinements: match[ 1 ] ? match[ 1 ].split( '.' ) : []\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Can we resolve it immediately?\n\t\t\t\t\tif ( keypath = resolveRef( ractive, reference, parentFragment ) ) {\n\t\t\t\t\t\targs[ i ] = {\n\t\t\t\t\t\t\tkeypath: keypath\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Couldn't resolve yet\n\t\t\t\t\targs[ i ] = null;\n\t\t\t\t\tunresolved = new Unresolved( ractive, reference, parentFragment, function( keypath ) {\n\t\t\t\t\t\thandler.resolve( i, keypath );\n\t\t\t\t\t\tremoveFromArray( handler.unresolved, unresolved );\n\t\t\t\t\t} );\n\t\t\t\t\thandler.unresolved.push( unresolved );\n\t\t\t\t} );\n\t\t\t\tthis.fire = fireMethodCall;\n\t\t\t} else {\n\t\t\t\t// Get action ('foo' in 'on-click='foo')\n\t\t\t\taction = template.n || template;\n\t\t\t\tif ( typeof action !== 'string' ) {\n\t\t\t\t\taction = new Fragment( {\n\t\t\t\t\t\ttemplate: action,\n\t\t\t\t\t\troot: this.root,\n\t\t\t\t\t\towner: this\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tthis.action = action;\n\t\t\t\t// Get parameters\n\t\t\t\tif ( template.d ) {\n\t\t\t\t\tthis.dynamicParams = new Fragment( {\n\t\t\t\t\t\ttemplate: template.d,\n\t\t\t\t\t\troot: this.root,\n\t\t\t\t\t\towner: this.element\n\t\t\t\t\t} );\n\t\t\t\t\tthis.fire = fireEventWithDynamicParams;\n\t\t\t\t} else if ( template.a ) {\n\t\t\t\t\tthis.params = template.a;\n\t\t\t\t\tthis.fire = fireEventWithParams;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfunction fireMethodCall( event ) {\n\t\t\tvar ractive, values, args;\n\t\t\tractive = this.root;\n\t\t\tif ( typeof ractive[ this.method ] !== 'function' ) {\n\t\t\t\tthrow new Error( 'Attempted to call a non-existent method (\"' + this.method + '\")' );\n\t\t\t}\n\t\t\tvalues = this.args.map( function( arg ) {\n\t\t\t\tvar value, len, i;\n\t\t\t\tif ( !arg ) {\n\t\t\t\t\t// not yet resolved\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif ( arg.indexRef ) {\n\t\t\t\t\treturn arg.value;\n\t\t\t\t}\n\t\t\t\t// TODO the refinements stuff would be better handled at parse time\n\t\t\t\tif ( arg.eventObject ) {\n\t\t\t\t\tvalue = event;\n\t\t\t\t\tif ( len = arg.refinements.length ) {\n\t\t\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\t\t\tvalue = value[ arg.refinements[ i ] ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvalue = ractive.get( arg.keypath );\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} );\n\t\t\targs = this.fn.apply( null, values );\n\t\t\tractive[ this.method ].apply( ractive, args );\n\t\t}\n\n\t\tfunction fireEventWithParams( event ) {\n\t\t\tfireEvent( this.root, this.getAction(), {\n\t\t\t\tevent: event,\n\t\t\t\targs: this.params\n\t\t\t} );\n\t\t}\n\n\t\tfunction fireEventWithDynamicParams( event ) {\n\t\t\tvar args = this.dynamicParams.getValue( getValueOptions );\n\t\t\t// need to strip [] from ends if a string!\n\t\t\tif ( typeof args === 'string' ) {\n\t\t\t\targs = args.substr( 1, args.length - 2 );\n\t\t\t}\n\t\t\tfireEvent( this.root, this.getAction(), {\n\t\t\t\tevent: event,\n\t\t\t\targs: args\n\t\t\t} );\n\t\t}\n\t\treturn __export;\n\t}( removeFromArray, getFunctionFromString, resolveRef, Unresolved, circular, Ractive$shared_fireEvent, log );\n\n\t/* virtualdom/items/Element/EventHandler/shared/genericHandler.js */\n\tvar genericHandler = function genericHandler( event ) {\n\t\tvar storage, handler;\n\t\tstorage = this._ractive;\n\t\thandler = storage.events[ event.type ];\n\t\thandler.fire( {\n\t\t\tnode: this,\n\t\t\toriginal: event,\n\t\t\tindex: storage.index,\n\t\t\tkeypath: storage.keypath,\n\t\t\tcontext: storage.root.get( storage.keypath )\n\t\t} );\n\t};\n\n\t/* virtualdom/items/Element/EventHandler/prototype/listen.js */\n\tvar virtualdom_items_Element_EventHandler$listen = function( config, genericHandler, log ) {\n\n\t\tvar __export;\n\t\tvar customHandlers = {},\n\t\t\ttouchEvents = {\n\t\t\t\ttouchstart: true,\n\t\t\t\ttouchmove: true,\n\t\t\t\ttouchend: true,\n\t\t\t\ttouchcancel: true,\n\t\t\t\t//not w3c, but supported in some browsers\n\t\t\t\ttouchleave: true\n\t\t\t};\n\t\t__export = function EventHandler$listen() {\n\t\t\tvar definition, name = this.name;\n\t\t\tif ( this.invalid ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( definition = config.registries.events.find( this.root, name ) ) {\n\t\t\t\tthis.custom = definition( this.node, getCustomHandler( name ) );\n\t\t\t} else {\n\t\t\t\t// Looks like we're dealing with a standard DOM event... but let's check\n\t\t\t\tif ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) ) {\n\t\t\t\t\t// okay to use touch events if this browser doesn't support them\n\t\t\t\t\tif ( !touchEvents[ name ] ) {\n\t\t\t\t\t\tlog.error( {\n\t\t\t\t\t\t\tdebug: this.root.debug,\n\t\t\t\t\t\t\tmessage: 'missingPlugin',\n\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\tplugin: 'event',\n\t\t\t\t\t\t\t\tname: name\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.node.addEventListener( name, genericHandler, false );\n\t\t\t}\n\t\t\tthis.hasListener = true;\n\t\t};\n\n\t\tfunction getCustomHandler( name ) {\n\t\t\tif ( !customHandlers[ name ] ) {\n\t\t\t\tcustomHandlers[ name ] = function( event ) {\n\t\t\t\t\tvar storage = event.node._ractive;\n\t\t\t\t\tevent.index = storage.index;\n\t\t\t\t\tevent.keypath = storage.keypath;\n\t\t\t\t\tevent.context = storage.root.get( storage.keypath );\n\t\t\t\t\tstorage.events[ name ].fire( event );\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn customHandlers[ name ];\n\t\t}\n\t\treturn __export;\n\t}( config, genericHandler, log );\n\n\t/* virtualdom/items/Element/EventHandler/prototype/rebind.js */\n\tvar virtualdom_items_Element_EventHandler$rebind = function( getNewKeypath ) {\n\n\t\treturn function EventHandler$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\tif ( this.method ) {\n\t\t\t\tthis.args.forEach( function( arg ) {\n\t\t\t\t\tif ( arg.indexRef && arg.indexRef === indexRef ) {\n\t\t\t\t\t\targ.value = newIndex;\n\t\t\t\t\t}\n\t\t\t\t\tif ( arg.keypath && ( newKeypath = getNewKeypath( arg.keypath, oldKeypath, newKeypath ) ) ) {\n\t\t\t\t\t\targ.keypath = newKeypath;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( typeof this.action !== 'string' ) {\n\t\t\t\tthis.action.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t}\n\t\t\tif ( this.dynamicParams ) {\n\t\t\t\tthis.dynamicParams.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t}\n\t\t};\n\t}( getNewKeypath );\n\n\t/* virtualdom/items/Element/EventHandler/prototype/render.js */\n\tvar virtualdom_items_Element_EventHandler$render = function EventHandler$render() {\n\t\tthis.node = this.element.node;\n\t\t// store this on the node itself, so it can be retrieved by a\n\t\t// universal handler\n\t\tthis.node._ractive.events[ this.name ] = this;\n\t\tif ( this.method || this.getAction() ) {\n\t\t\tthis.listen();\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/EventHandler/prototype/resolve.js */\n\tvar virtualdom_items_Element_EventHandler$resolve = function EventHandler$resolve( index, keypath ) {\n\t\tthis.args[ index ] = {\n\t\t\tkeypath: keypath\n\t\t};\n\t};\n\n\t/* virtualdom/items/Element/EventHandler/prototype/unbind.js */\n\tvar virtualdom_items_Element_EventHandler$unbind = function() {\n\n\t\tvar __export;\n\t\t__export = function EventHandler$unbind() {\n\t\t\tif ( this.method ) {\n\t\t\t\tthis.unresolved.forEach( teardown );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Tear down dynamic name\n\t\t\tif ( typeof this.action !== 'string' ) {\n\t\t\t\tthis.action.unbind();\n\t\t\t}\n\t\t\t// Tear down dynamic parameters\n\t\t\tif ( this.dynamicParams ) {\n\t\t\t\tthis.dynamicParams.unbind();\n\t\t\t}\n\t\t};\n\n\t\tfunction teardown( x ) {\n\t\t\tx.teardown();\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* virtualdom/items/Element/EventHandler/prototype/unrender.js */\n\tvar virtualdom_items_Element_EventHandler$unrender = function( genericHandler ) {\n\n\t\treturn function EventHandler$unrender() {\n\t\t\tif ( this.custom ) {\n\t\t\t\tthis.custom.teardown();\n\t\t\t} else {\n\t\t\t\tthis.node.removeEventListener( this.name, genericHandler, false );\n\t\t\t}\n\t\t\tthis.hasListener = false;\n\t\t};\n\t}( genericHandler );\n\n\t/* virtualdom/items/Element/EventHandler/_EventHandler.js */\n\tvar EventHandler = function( bubble, fire, getAction, init, listen, rebind, render, resolve, unbind, unrender ) {\n\n\t\tvar EventHandler = function( element, name, template ) {\n\t\t\tthis.init( element, name, template );\n\t\t};\n\t\tEventHandler.prototype = {\n\t\t\tbubble: bubble,\n\t\t\tfire: fire,\n\t\t\tgetAction: getAction,\n\t\t\tinit: init,\n\t\t\tlisten: listen,\n\t\t\trebind: rebind,\n\t\t\trender: render,\n\t\t\tresolve: resolve,\n\t\t\tunbind: unbind,\n\t\t\tunrender: unrender\n\t\t};\n\t\treturn EventHandler;\n\t}( virtualdom_items_Element_EventHandler$bubble, virtualdom_items_Element_EventHandler$fire, virtualdom_items_Element_EventHandler$getAction, virtualdom_items_Element_EventHandler$init, virtualdom_items_Element_EventHandler$listen, virtualdom_items_Element_EventHandler$rebind, virtualdom_items_Element_EventHandler$render, virtualdom_items_Element_EventHandler$resolve, virtualdom_items_Element_EventHandler$unbind, virtualdom_items_Element_EventHandler$unrender );\n\n\t/* virtualdom/items/Element/prototype/init/createEventHandlers.js */\n\tvar virtualdom_items_Element$init_createEventHandlers = function( EventHandler ) {\n\n\t\treturn function( element, template ) {\n\t\t\tvar i, name, names, handler, result = [];\n\t\t\tfor ( name in template ) {\n\t\t\t\tif ( template.hasOwnProperty( name ) ) {\n\t\t\t\t\tnames = name.split( '-' );\n\t\t\t\t\ti = names.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\thandler = new EventHandler( element, names[ i ], template[ name ] );\n\t\t\t\t\t\tresult.push( handler );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t}( EventHandler );\n\n\t/* virtualdom/items/Element/Decorator/_Decorator.js */\n\tvar Decorator = function( log, circular, config ) {\n\n\t\tvar Fragment, getValueOptions, Decorator;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\tgetValueOptions = {\n\t\t\targs: true\n\t\t};\n\t\tDecorator = function( element, template ) {\n\t\t\tvar decorator = this,\n\t\t\t\tractive, name, fragment;\n\t\t\tdecorator.element = element;\n\t\t\tdecorator.root = ractive = element.root;\n\t\t\tname = template.n || template;\n\t\t\tif ( typeof name !== 'string' ) {\n\t\t\t\tfragment = new Fragment( {\n\t\t\t\t\ttemplate: name,\n\t\t\t\t\troot: ractive,\n\t\t\t\t\towner: element\n\t\t\t\t} );\n\t\t\t\tname = fragment.toString();\n\t\t\t\tfragment.unbind();\n\t\t\t}\n\t\t\tif ( template.a ) {\n\t\t\t\tdecorator.params = template.a;\n\t\t\t} else if ( template.d ) {\n\t\t\t\tdecorator.fragment = new Fragment( {\n\t\t\t\t\ttemplate: template.d,\n\t\t\t\t\troot: ractive,\n\t\t\t\t\towner: element\n\t\t\t\t} );\n\t\t\t\tdecorator.params = decorator.fragment.getValue( getValueOptions );\n\t\t\t\tdecorator.fragment.bubble = function() {\n\t\t\t\t\tthis.dirtyArgs = this.dirtyValue = true;\n\t\t\t\t\tdecorator.params = this.getValue( getValueOptions );\n\t\t\t\t\tif ( decorator.ready ) {\n\t\t\t\t\t\tdecorator.update();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tdecorator.fn = config.registries.decorators.find( ractive, name );\n\t\t\tif ( !decorator.fn ) {\n\t\t\t\tlog.error( {\n\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\tmessage: 'missingPlugin',\n\t\t\t\t\targs: {\n\t\t\t\t\t\tplugin: 'decorator',\n\t\t\t\t\t\tname: name\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\t\tDecorator.prototype = {\n\t\t\tinit: function() {\n\t\t\t\tvar decorator = this,\n\t\t\t\t\tnode, result, args;\n\t\t\t\tnode = decorator.element.node;\n\t\t\t\tif ( decorator.params ) {\n\t\t\t\t\targs = [ node ].concat( decorator.params );\n\t\t\t\t\tresult = decorator.fn.apply( decorator.root, args );\n\t\t\t\t} else {\n\t\t\t\t\tresult = decorator.fn.call( decorator.root, node );\n\t\t\t\t}\n\t\t\t\tif ( !result || !result.teardown ) {\n\t\t\t\t\tthrow new Error( 'Decorator definition must return an object with a teardown method' );\n\t\t\t\t}\n\t\t\t\t// TODO does this make sense?\n\t\t\t\tdecorator.actual = result;\n\t\t\t\tdecorator.ready = true;\n\t\t\t},\n\t\t\tupdate: function() {\n\t\t\t\tif ( this.actual.update ) {\n\t\t\t\t\tthis.actual.update.apply( this.root, this.params );\n\t\t\t\t} else {\n\t\t\t\t\tthis.actual.teardown( true );\n\t\t\t\t\tthis.init();\n\t\t\t\t}\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t}\n\t\t\t},\n\t\t\tteardown: function( updating ) {\n\t\t\t\tthis.actual.teardown();\n\t\t\t\tif ( !updating && this.fragment ) {\n\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn Decorator;\n\t}( log, circular, config );\n\n\t/* virtualdom/items/Element/special/select/sync.js */\n\tvar sync = function( toArray ) {\n\n\t\tvar __export;\n\t\t__export = function syncSelect( selectElement ) {\n\t\t\tvar selectNode, selectValue, isMultiple, options, optionWasSelected;\n\t\t\tselectNode = selectElement.node;\n\t\t\tif ( !selectNode ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toptions = toArray( selectNode.options );\n\t\t\tselectValue = selectElement.getAttribute( 'value' );\n\t\t\tisMultiple = selectElement.getAttribute( 'multiple' );\n\t\t\t// If the <select> has a specified value, that should override\n\t\t\t// these options\n\t\t\tif ( selectValue !== undefined ) {\n\t\t\t\toptions.forEach( function( o ) {\n\t\t\t\t\tvar optionValue, shouldSelect;\n\t\t\t\t\toptionValue = o._ractive ? o._ractive.value : o.value;\n\t\t\t\t\tshouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;\n\t\t\t\t\tif ( shouldSelect ) {\n\t\t\t\t\t\toptionWasSelected = true;\n\t\t\t\t\t}\n\t\t\t\t\to.selected = shouldSelect;\n\t\t\t\t} );\n\t\t\t\tif ( !optionWasSelected ) {\n\t\t\t\t\tif ( options[ 0 ] ) {\n\t\t\t\t\t\toptions[ 0 ].selected = true;\n\t\t\t\t\t}\n\t\t\t\t\tif ( selectElement.binding ) {\n\t\t\t\t\t\tselectElement.binding.forceUpdate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( selectElement.binding ) {\n\t\t\t\tselectElement.binding.forceUpdate();\n\t\t\t}\n\t\t};\n\n\t\tfunction valueContains( selectValue, optionValue ) {\n\t\t\tvar i = selectValue.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( selectValue[ i ] == optionValue ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}( toArray );\n\n\t/* virtualdom/items/Element/special/select/bubble.js */\n\tvar bubble = function( runloop, syncSelect ) {\n\n\t\treturn function bubbleSelect() {\n\t\t\tvar this$0 = this;\n\t\t\tif ( !this.dirty ) {\n\t\t\t\tthis.dirty = true;\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\tsyncSelect( this$0 );\n\t\t\t\t\tthis$0.dirty = false;\n\t\t\t\t} );\n\t\t\t}\n\t\t\tthis.parentFragment.bubble();\n\t\t};\n\t}( runloop, sync );\n\n\t/* virtualdom/items/Element/special/option/findParentSelect.js */\n\tvar findParentSelect = function findParentSelect( element ) {\n\t\tdo {\n\t\t\tif ( element.name === 'select' ) {\n\t\t\t\treturn element;\n\t\t\t}\n\t\t} while ( element = element.parent );\n\t};\n\n\t/* virtualdom/items/Element/special/option/init.js */\n\tvar init = function( findParentSelect ) {\n\n\t\treturn function initOption( option, template ) {\n\t\t\toption.select = findParentSelect( option.parent );\n\t\t\t// we might be inside a <datalist> element\n\t\t\tif ( !option.select ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toption.select.options.push( option );\n\t\t\t// If the value attribute is missing, use the element's content\n\t\t\tif ( !template.a ) {\n\t\t\t\ttemplate.a = {};\n\t\t\t}\n\t\t\t// ...as long as it isn't disabled\n\t\t\tif ( !template.a.value && !template.a.hasOwnProperty( 'disabled' ) ) {\n\t\t\t\ttemplate.a.value = template.f;\n\t\t\t}\n\t\t\t// If there is a `selected` attribute, but the <select>\n\t\t\t// already has a value, delete it\n\t\t\tif ( 'selected' in template.a && option.select.getAttribute( 'value' ) !== undefined ) {\n\t\t\t\tdelete template.a.selected;\n\t\t\t}\n\t\t};\n\t}( findParentSelect );\n\n\t/* virtualdom/items/Element/prototype/init.js */\n\tvar virtualdom_items_Element$init = function( types, enforceCase, createAttributes, createConditionalAttributes, createTwowayBinding, createEventHandlers, Decorator, bubbleSelect, initOption, circular ) {\n\n\t\tvar Fragment;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\treturn function Element$init( options ) {\n\t\t\tvar parentFragment, template, ractive, binding, bindings;\n\t\t\tthis.type = types.ELEMENT;\n\t\t\t// stuff we'll need later\n\t\t\tparentFragment = this.parentFragment = options.parentFragment;\n\t\t\ttemplate = this.template = options.template;\n\t\t\tthis.parent = options.pElement || parentFragment.pElement;\n\t\t\tthis.root = ractive = parentFragment.root;\n\t\t\tthis.index = options.index;\n\t\t\tthis.name = enforceCase( template.e );\n\t\t\t// Special case - <option> elements\n\t\t\tif ( this.name === 'option' ) {\n\t\t\t\tinitOption( this, template );\n\t\t\t}\n\t\t\t// Special case - <select> elements\n\t\t\tif ( this.name === 'select' ) {\n\t\t\t\tthis.options = [];\n\t\t\t\tthis.bubble = bubbleSelect;\n\t\t\t}\n\t\t\t// create attributes\n\t\t\tthis.attributes = createAttributes( this, template.a );\n\t\t\tthis.conditionalAttributes = createConditionalAttributes( this, template.m );\n\t\t\t// append children, if there are any\n\t\t\tif ( template.f ) {\n\t\t\t\tthis.fragment = new Fragment( {\n\t\t\t\t\ttemplate: template.f,\n\t\t\t\t\troot: ractive,\n\t\t\t\t\towner: this,\n\t\t\t\t\tpElement: this\n\t\t\t\t} );\n\t\t\t}\n\t\t\t// create twoway binding\n\t\t\tif ( ractive.twoway && ( binding = createTwowayBinding( this, template.a ) ) ) {\n\t\t\t\tthis.binding = binding;\n\t\t\t\t// register this with the root, so that we can do ractive.updateModel()\n\t\t\t\tbindings = this.root._twowayBindings[ binding.keypath ] || ( this.root._twowayBindings[ binding.keypath ] = [] );\n\t\t\t\tbindings.push( binding );\n\t\t\t}\n\t\t\t// create event proxies\n\t\t\tif ( template.v ) {\n\t\t\t\tthis.eventHandlers = createEventHandlers( this, template.v );\n\t\t\t}\n\t\t\t// create decorator\n\t\t\tif ( template.o ) {\n\t\t\t\tthis.decorator = new Decorator( this, template.o );\n\t\t\t}\n\t\t\t// create transitions\n\t\t\tthis.intro = template.t0 || template.t1;\n\t\t\tthis.outro = template.t0 || template.t2;\n\t\t};\n\t}( types, enforceCase, virtualdom_items_Element$init_createAttributes, virtualdom_items_Element$init_createConditionalAttributes, virtualdom_items_Element$init_createTwowayBinding, virtualdom_items_Element$init_createEventHandlers, Decorator, bubble, init, circular );\n\n\t/* virtualdom/items/shared/utils/startsWith.js */\n\tvar startsWith = function( startsWithKeypath ) {\n\n\t\treturn function startsWith( target, keypath ) {\n\t\t\treturn target === keypath || startsWithKeypath( target, keypath );\n\t\t};\n\t}( startsWithKeypath );\n\n\t/* virtualdom/items/shared/utils/assignNewKeypath.js */\n\tvar assignNewKeypath = function( startsWith, getNewKeypath ) {\n\n\t\treturn function assignNewKeypath( target, property, oldKeypath, newKeypath ) {\n\t\t\tvar existingKeypath = target[ property ];\n\t\t\tif ( !existingKeypath || startsWith( existingKeypath, newKeypath ) || !startsWith( existingKeypath, oldKeypath ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttarget[ property ] = getNewKeypath( existingKeypath, oldKeypath, newKeypath );\n\t\t};\n\t}( startsWith, getNewKeypath );\n\n\t/* virtualdom/items/Element/prototype/rebind.js */\n\tvar virtualdom_items_Element$rebind = function( assignNewKeypath ) {\n\n\t\treturn function Element$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\tvar i, storage, liveQueries, ractive;\n\t\t\tif ( this.attributes ) {\n\t\t\t\tthis.attributes.forEach( rebind );\n\t\t\t}\n\t\t\tif ( this.conditionalAttributes ) {\n\t\t\t\tthis.conditionalAttributes.forEach( rebind );\n\t\t\t}\n\t\t\tif ( this.eventHandlers ) {\n\t\t\t\tthis.eventHandlers.forEach( rebind );\n\t\t\t}\n\t\t\tif ( this.decorator ) {\n\t\t\t\trebind( this.decorator );\n\t\t\t}\n\t\t\t// rebind children\n\t\t\tif ( this.fragment ) {\n\t\t\t\trebind( this.fragment );\n\t\t\t}\n\t\t\t// Update live queries, if necessary\n\t\t\tif ( liveQueries = this.liveQueries ) {\n\t\t\t\tractive = this.root;\n\t\t\t\ti = liveQueries.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tliveQueries[ i ]._makeDirty();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( this.node && ( storage = this.node._ractive ) ) {\n\t\t\t\t// adjust keypath if needed\n\t\t\t\tassignNewKeypath( storage, 'keypath', oldKeypath, newKeypath );\n\t\t\t\tif ( indexRef != undefined ) {\n\t\t\t\t\tstorage.index[ indexRef ] = newIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction rebind( thing ) {\n\t\t\t\tthing.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t}\n\t\t};\n\t}( assignNewKeypath );\n\n\t/* virtualdom/items/Element/special/img/render.js */\n\tvar render = function renderImage( img ) {\n\t\tvar loadHandler;\n\t\t// if this is an <img>, and we're in a crap browser, we may need to prevent it\n\t\t// from overriding width and height when it loads the src\n\t\tif ( img.attributes.width || img.attributes.height ) {\n\t\t\timg.node.addEventListener( 'load', loadHandler = function() {\n\t\t\t\tvar width = img.getAttribute( 'width' ),\n\t\t\t\t\theight = img.getAttribute( 'height' );\n\t\t\t\tif ( width !== undefined ) {\n\t\t\t\t\timg.node.setAttribute( 'width', width );\n\t\t\t\t}\n\t\t\t\tif ( height !== undefined ) {\n\t\t\t\t\timg.node.setAttribute( 'height', height );\n\t\t\t\t}\n\t\t\t\timg.node.removeEventListener( 'load', loadHandler, false );\n\t\t\t}, false );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Element/Transition/prototype/init.js */\n\tvar virtualdom_items_Element_Transition$init = function( log, config, circular ) {\n\n\t\tvar Fragment, getValueOptions = {};\n\t\t// TODO what are the options?\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\treturn function Transition$init( element, template, isIntro ) {\n\t\t\tvar t = this,\n\t\t\t\tractive, name, fragment;\n\t\t\tt.element = element;\n\t\t\tt.root = ractive = element.root;\n\t\t\tt.isIntro = isIntro;\n\t\t\tname = template.n || template;\n\t\t\tif ( typeof name !== 'string' ) {\n\t\t\t\tfragment = new Fragment( {\n\t\t\t\t\ttemplate: name,\n\t\t\t\t\troot: ractive,\n\t\t\t\t\towner: element\n\t\t\t\t} );\n\t\t\t\tname = fragment.toString();\n\t\t\t\tfragment.unbind();\n\t\t\t}\n\t\t\tt.name = name;\n\t\t\tif ( template.a ) {\n\t\t\t\tt.params = template.a;\n\t\t\t} else if ( template.d ) {\n\t\t\t\t// TODO is there a way to interpret dynamic arguments without all the\n\t\t\t\t// 'dependency thrashing'?\n\t\t\t\tfragment = new Fragment( {\n\t\t\t\t\ttemplate: template.d,\n\t\t\t\t\troot: ractive,\n\t\t\t\t\towner: element\n\t\t\t\t} );\n\t\t\t\tt.params = fragment.getValue( getValueOptions );\n\t\t\t\tfragment.unbind();\n\t\t\t}\n\t\t\tt._fn = config.registries.transitions.find( ractive, name );\n\t\t\tif ( !t._fn ) {\n\t\t\t\tlog.error( {\n\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\tmessage: 'missingPlugin',\n\t\t\t\t\targs: {\n\t\t\t\t\t\tplugin: 'transition',\n\t\t\t\t\t\tname: name\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn;\n\t\t\t}\n\t\t};\n\t}( log, config, circular );\n\n\t/* utils/camelCase.js */\n\tvar camelCase = function( hyphenatedStr ) {\n\t\treturn hyphenatedStr.replace( /-([a-zA-Z])/g, function( match, $1 ) {\n\t\t\treturn $1.toUpperCase();\n\t\t} );\n\t};\n\n\t/* virtualdom/items/Element/Transition/helpers/prefix.js */\n\tvar prefix = function( isClient, vendors, createElement, camelCase ) {\n\n\t\tvar prefix, prefixCache, testStyle;\n\t\tif ( !isClient ) {\n\t\t\tprefix = null;\n\t\t} else {\n\t\t\tprefixCache = {};\n\t\t\ttestStyle = createElement( 'div' ).style;\n\t\t\tprefix = function( prop ) {\n\t\t\t\tvar i, vendor, capped;\n\t\t\t\tprop = camelCase( prop );\n\t\t\t\tif ( !prefixCache[ prop ] ) {\n\t\t\t\t\tif ( testStyle[ prop ] !== undefined ) {\n\t\t\t\t\t\tprefixCache[ prop ] = prop;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// test vendors...\n\t\t\t\t\t\tcapped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );\n\t\t\t\t\t\ti = vendors.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tvendor = vendors[ i ];\n\t\t\t\t\t\t\tif ( testStyle[ vendor + capped ] !== undefined ) {\n\t\t\t\t\t\t\t\tprefixCache[ prop ] = vendor + capped;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn prefixCache[ prop ];\n\t\t\t};\n\t\t}\n\t\treturn prefix;\n\t}( isClient, vendors, createElement, camelCase );\n\n\t/* virtualdom/items/Element/Transition/prototype/getStyle.js */\n\tvar virtualdom_items_Element_Transition$getStyle = function( legacy, isClient, isArray, prefix ) {\n\n\t\tvar getStyle, getComputedStyle;\n\t\tif ( !isClient ) {\n\t\t\tgetStyle = null;\n\t\t} else {\n\t\t\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\t\t\tgetStyle = function( props ) {\n\t\t\t\tvar computedStyle, styles, i, prop, value;\n\t\t\t\tcomputedStyle = getComputedStyle( this.node );\n\t\t\t\tif ( typeof props === 'string' ) {\n\t\t\t\t\tvalue = computedStyle[ prefix( props ) ];\n\t\t\t\t\tif ( value === '0px' ) {\n\t\t\t\t\t\tvalue = 0;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tif ( !isArray( props ) ) {\n\t\t\t\t\tthrow new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );\n\t\t\t\t}\n\t\t\t\tstyles = {};\n\t\t\t\ti = props.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tprop = props[ i ];\n\t\t\t\t\tvalue = computedStyle[ prefix( prop ) ];\n\t\t\t\t\tif ( value === '0px' ) {\n\t\t\t\t\t\tvalue = 0;\n\t\t\t\t\t}\n\t\t\t\t\tstyles[ prop ] = value;\n\t\t\t\t}\n\t\t\t\treturn styles;\n\t\t\t};\n\t\t}\n\t\treturn getStyle;\n\t}( legacy, isClient, isArray, prefix );\n\n\t/* virtualdom/items/Element/Transition/prototype/setStyle.js */\n\tvar virtualdom_items_Element_Transition$setStyle = function( prefix ) {\n\n\t\treturn function( style, value ) {\n\t\t\tvar prop;\n\t\t\tif ( typeof style === 'string' ) {\n\t\t\t\tthis.node.style[ prefix( style ) ] = value;\n\t\t\t} else {\n\t\t\t\tfor ( prop in style ) {\n\t\t\t\t\tif ( style.hasOwnProperty( prop ) ) {\n\t\t\t\t\t\tthis.node.style[ prefix( prop ) ] = style[ prop ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\t}( prefix );\n\n\t/* shared/Ticker.js */\n\tvar Ticker = function( warn, getTime, animations ) {\n\n\t\tvar __export;\n\t\tvar Ticker = function( options ) {\n\t\t\tvar easing;\n\t\t\tthis.duration = options.duration;\n\t\t\tthis.step = options.step;\n\t\t\tthis.complete = options.complete;\n\t\t\t// easing\n\t\t\tif ( typeof options.easing === 'string' ) {\n\t\t\t\teasing = options.root.easing[ options.easing ];\n\t\t\t\tif ( !easing ) {\n\t\t\t\t\twarn( 'Missing easing function (\"' + options.easing + '\"). You may need to download a plugin from [TODO]' );\n\t\t\t\t\teasing = linear;\n\t\t\t\t}\n\t\t\t} else if ( typeof options.easing === 'function' ) {\n\t\t\t\teasing = options.easing;\n\t\t\t} else {\n\t\t\t\teasing = linear;\n\t\t\t}\n\t\t\tthis.easing = easing;\n\t\t\tthis.start = getTime();\n\t\t\tthis.end = this.start + this.duration;\n\t\t\tthis.running = true;\n\t\t\tanimations.add( this );\n\t\t};\n\t\tTicker.prototype = {\n\t\t\ttick: function( now ) {\n\t\t\t\tvar elapsed, eased;\n\t\t\t\tif ( !this.running ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif ( now > this.end ) {\n\t\t\t\t\tif ( this.step ) {\n\t\t\t\t\t\tthis.step( 1 );\n\t\t\t\t\t}\n\t\t\t\t\tif ( this.complete ) {\n\t\t\t\t\t\tthis.complete( 1 );\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telapsed = now - this.start;\n\t\t\t\teased = this.easing( elapsed / this.duration );\n\t\t\t\tif ( this.step ) {\n\t\t\t\t\tthis.step( eased );\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tstop: function() {\n\t\t\t\tif ( this.abort ) {\n\t\t\t\t\tthis.abort();\n\t\t\t\t}\n\t\t\t\tthis.running = false;\n\t\t\t}\n\t\t};\n\t\t__export = Ticker;\n\n\t\tfunction linear( t ) {\n\t\t\treturn t;\n\t\t}\n\t\treturn __export;\n\t}( warn, getTime, animations );\n\n\t/* virtualdom/items/Element/Transition/helpers/unprefix.js */\n\tvar unprefix = function( vendors ) {\n\n\t\tvar unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );\n\t\treturn function( prop ) {\n\t\t\treturn prop.replace( unprefixPattern, '' );\n\t\t};\n\t}( vendors );\n\n\t/* virtualdom/items/Element/Transition/helpers/hyphenate.js */\n\tvar hyphenate = function( vendors ) {\n\n\t\tvar vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );\n\t\treturn function( str ) {\n\t\t\tvar hyphenated;\n\t\t\tif ( !str ) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tif ( vendorPattern.test( str ) ) {\n\t\t\t\tstr = '-' + str;\n\t\t\t}\n\t\t\thyphenated = str.replace( /[A-Z]/g, function( match ) {\n\t\t\t\treturn '-' + match.toLowerCase();\n\t\t\t} );\n\t\t\treturn hyphenated;\n\t\t};\n\t}( vendors );\n\n\t/* virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js */\n\tvar virtualdom_items_Element_Transition$animateStyle_createTransitions = function( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate ) {\n\n\t\tvar createTransitions, testStyle, TRANSITION, TRANSITIONEND, CSS_TRANSITIONS_ENABLED, TRANSITION_DURATION, TRANSITION_PROPERTY, TRANSITION_TIMING_FUNCTION, canUseCssTransitions = {},\n\t\t\tcannotUseCssTransitions = {};\n\t\tif ( !isClient ) {\n\t\t\tcreateTransitions = null;\n\t\t} else {\n\t\t\ttestStyle = createElement( 'div' ).style;\n\t\t\t// determine some facts about our environment\n\t\t\t( function() {\n\t\t\t\tif ( testStyle.transition !== undefined ) {\n\t\t\t\t\tTRANSITION = 'transition';\n\t\t\t\t\tTRANSITIONEND = 'transitionend';\n\t\t\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t\t\t} else if ( testStyle.webkitTransition !== undefined ) {\n\t\t\t\t\tTRANSITION = 'webkitTransition';\n\t\t\t\t\tTRANSITIONEND = 'webkitTransitionEnd';\n\t\t\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t\t\t} else {\n\t\t\t\t\tCSS_TRANSITIONS_ENABLED = false;\n\t\t\t\t}\n\t\t\t}() );\n\t\t\tif ( TRANSITION ) {\n\t\t\t\tTRANSITION_DURATION = TRANSITION + 'Duration';\n\t\t\t\tTRANSITION_PROPERTY = TRANSITION + 'Property';\n\t\t\t\tTRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';\n\t\t\t}\n\t\t\tcreateTransitions = function( t, to, options, changedProperties, resolve ) {\n\t\t\t\t// Wait a beat (otherwise the target styles will be applied immediately)\n\t\t\t\t// TODO use a fastdom-style mechanism?\n\t\t\t\tsetTimeout( function() {\n\t\t\t\t\tvar hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;\n\t\t\t\t\tcheckComplete = function() {\n\t\t\t\t\t\tif ( jsTransitionsComplete && cssTransitionsComplete ) {\n\t\t\t\t\t\t\t// will changes to events and fire have an unexpected consequence here?\n\t\t\t\t\t\t\tt.root.fire( t.name + ':end', t.node, t.isIntro );\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t// this is used to keep track of which elements can use CSS to animate\n\t\t\t\t\t// which properties\n\t\t\t\t\thashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;\n\t\t\t\t\tt.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );\n\t\t\t\t\tt.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );\n\t\t\t\t\tt.node.style[ TRANSITION_DURATION ] = options.duration / 1000 + 's';\n\t\t\t\t\ttransitionEndHandler = function( event ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\tindex = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );\n\t\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( changedProperties.length ) {\n\t\t\t\t\t\t\t// still transitioning...\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t};\n\t\t\t\t\tt.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\tsetTimeout( function() {\n\t\t\t\t\t\tvar i = changedProperties.length,\n\t\t\t\t\t\t\thash, originalValue, index, propertiesToTransitionInJs = [],\n\t\t\t\t\t\t\tprop, suffix;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tprop = changedProperties[ i ];\n\t\t\t\t\t\t\thash = hashPrefix + prop;\n\t\t\t\t\t\t\tif ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = to[ prop ];\n\t\t\t\t\t\t\t\t// If we're not sure if CSS transitions are supported for\n\t\t\t\t\t\t\t\t// this tag/property combo, find out now\n\t\t\t\t\t\t\t\tif ( !canUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t\t\t\t\t\t\t\t\t// if this property is transitionable in this browser,\n\t\t\t\t\t\t\t\t\t// the current style will be different from the target style\n\t\t\t\t\t\t\t\t\tcanUseCssTransitions[ hash ] = t.getStyle( prop ) != to[ prop ];\n\t\t\t\t\t\t\t\t\tcannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];\n\t\t\t\t\t\t\t\t\t// Reset, if we're going to use timers after all\n\t\t\t\t\t\t\t\t\tif ( cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = originalValue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\t// we need to fall back to timer-based stuff\n\t\t\t\t\t\t\t\tif ( originalValue === undefined ) {\n\t\t\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// need to remove this from changedProperties, otherwise transitionEndHandler\n\t\t\t\t\t\t\t\t// will get confused\n\t\t\t\t\t\t\t\tindex = changedProperties.indexOf( prop );\n\t\t\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\t\t\twarn( 'Something very strange happened with transitions. If you see this message, please let @RactiveJS know. Thanks!' );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// TODO Determine whether this property is animatable at all\n\t\t\t\t\t\t\t\tsuffix = /[^\\d]*$/.exec( to[ prop ] )[ 0 ];\n\t\t\t\t\t\t\t\t// ...then kick off a timer-based transition\n\t\t\t\t\t\t\t\tpropertiesToTransitionInJs.push( {\n\t\t\t\t\t\t\t\t\tname: prefix( prop ),\n\t\t\t\t\t\t\t\t\tinterpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),\n\t\t\t\t\t\t\t\t\tsuffix: suffix\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// javascript transitions\n\t\t\t\t\t\tif ( propertiesToTransitionInJs.length ) {\n\t\t\t\t\t\t\tnew Ticker( {\n\t\t\t\t\t\t\t\troot: t.root,\n\t\t\t\t\t\t\t\tduration: options.duration,\n\t\t\t\t\t\t\t\teasing: camelCase( options.easing || '' ),\n\t\t\t\t\t\t\t\tstep: function( pos ) {\n\t\t\t\t\t\t\t\t\tvar prop, i;\n\t\t\t\t\t\t\t\t\ti = propertiesToTransitionInJs.length;\n\t\t\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\t\t\tprop = propertiesToTransitionInJs[ i ];\n\t\t\t\t\t\t\t\t\t\tt.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcomplete: function() {\n\t\t\t\t\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !changedProperties.length ) {\n\t\t\t\t\t\t\t// We need to cancel the transitionEndHandler, and deal with\n\t\t\t\t\t\t\t// the fact that it will never fire\n\t\t\t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 0 );\n\t\t\t\t}, options.delay || 0 );\n\t\t\t};\n\t\t}\n\t\treturn createTransitions;\n\t}( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate );\n\n\t/* virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js */\n\tvar virtualdom_items_Element_Transition$animateStyle_visibility = function( vendors ) {\n\n\t\tvar hidden, vendor, prefix, i, visibility;\n\t\tif ( typeof document !== 'undefined' ) {\n\t\t\thidden = 'hidden';\n\t\t\tvisibility = {};\n\t\t\tif ( hidden in document ) {\n\t\t\t\tprefix = '';\n\t\t\t} else {\n\t\t\t\ti = vendors.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvendor = vendors[ i ];\n\t\t\t\t\thidden = vendor + 'Hidden';\n\t\t\t\t\tif ( hidden in document ) {\n\t\t\t\t\t\tprefix = vendor;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( prefix !== undefined ) {\n\t\t\t\tdocument.addEventListener( prefix + 'visibilitychange', onChange );\n\t\t\t\t// initialise\n\t\t\t\tonChange();\n\t\t\t} else {\n\t\t\t\t// gah, we're in an old browser\n\t\t\t\tif ( 'onfocusout' in document ) {\n\t\t\t\t\tdocument.addEventListener( 'focusout', onHide );\n\t\t\t\t\tdocument.addEventListener( 'focusin', onShow );\n\t\t\t\t} else {\n\t\t\t\t\twindow.addEventListener( 'pagehide', onHide );\n\t\t\t\t\twindow.addEventListener( 'blur', onHide );\n\t\t\t\t\twindow.addEventListener( 'pageshow', onShow );\n\t\t\t\t\twindow.addEventListener( 'focus', onShow );\n\t\t\t\t}\n\t\t\t\tvisibility.hidden = false;\n\t\t\t}\n\t\t}\n\n\t\tfunction onChange() {\n\t\t\tvisibility.hidden = document[ hidden ];\n\t\t}\n\n\t\tfunction onHide() {\n\t\t\tvisibility.hidden = true;\n\t\t}\n\n\t\tfunction onShow() {\n\t\t\tvisibility.hidden = false;\n\t\t}\n\t\treturn visibility;\n\t}( vendors );\n\n\t/* virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js */\n\tvar virtualdom_items_Element_Transition$animateStyle__animateStyle = function( legacy, isClient, warn, Promise, prefix, createTransitions, visibility ) {\n\n\t\tvar animateStyle, getComputedStyle, resolved;\n\t\tif ( !isClient ) {\n\t\t\tanimateStyle = null;\n\t\t} else {\n\t\t\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\t\t\tanimateStyle = function( style, value, options, complete ) {\n\t\t\t\tvar t = this,\n\t\t\t\t\tto;\n\t\t\t\t// Special case - page isn't visible. Don't animate anything, because\n\t\t\t\t// that way you'll never get CSS transitionend events\n\t\t\t\tif ( visibility.hidden ) {\n\t\t\t\t\tthis.setStyle( style, value );\n\t\t\t\t\treturn resolved || ( resolved = Promise.resolve() );\n\t\t\t\t}\n\t\t\t\tif ( typeof style === 'string' ) {\n\t\t\t\t\tto = {};\n\t\t\t\t\tto[ style ] = value;\n\t\t\t\t} else {\n\t\t\t\t\tto = style;\n\t\t\t\t\t// shuffle arguments\n\t\t\t\t\tcomplete = options;\n\t\t\t\t\toptions = value;\n\t\t\t\t}\n\t\t\t\t// As of 0.3.9, transition authors should supply an `option` object with\n\t\t\t\t// `duration` and `easing` properties (and optional `delay`), plus a\n\t\t\t\t// callback function that gets called after the animation completes\n\t\t\t\t// TODO remove this check in a future version\n\t\t\t\tif ( !options ) {\n\t\t\t\t\twarn( 'The \"' + t.name + '\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340' );\n\t\t\t\t\toptions = t;\n\t\t\t\t\tcomplete = t.complete;\n\t\t\t\t}\n\t\t\t\tvar promise = new Promise( function( resolve ) {\n\t\t\t\t\tvar propertyNames, changedProperties, computedStyle, current, from, i, prop;\n\t\t\t\t\t// Edge case - if duration is zero, set style synchronously and complete\n\t\t\t\t\tif ( !options.duration ) {\n\t\t\t\t\t\tt.setStyle( to );\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// Get a list of the properties we're animating\n\t\t\t\t\tpropertyNames = Object.keys( to );\n\t\t\t\t\tchangedProperties = [];\n\t\t\t\t\t// Store the current styles\n\t\t\t\t\tcomputedStyle = getComputedStyle( t.node );\n\t\t\t\t\tfrom = {};\n\t\t\t\t\ti = propertyNames.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tprop = propertyNames[ i ];\n\t\t\t\t\t\tcurrent = computedStyle[ prefix( prop ) ];\n\t\t\t\t\t\tif ( current === '0px' ) {\n\t\t\t\t\t\t\tcurrent = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// we need to know if we're actually changing anything\n\t\t\t\t\t\tif ( current != to[ prop ] ) {\n\t\t\t\t\t\t\t// use != instead of !==, so we can compare strings with numbers\n\t\t\t\t\t\t\tchangedProperties.push( prop );\n\t\t\t\t\t\t\t// make the computed style explicit, so we can animate where\n\t\t\t\t\t\t\t// e.g. height='auto'\n\t\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = current;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// If we're not actually changing anything, the transitionend event\n\t\t\t\t\t// will never fire! So we complete early\n\t\t\t\t\tif ( !changedProperties.length ) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcreateTransitions( t, to, options, changedProperties, resolve );\n\t\t\t\t} );\n\t\t\t\t// If a callback was supplied, do the honours\n\t\t\t\t// TODO remove this check in future\n\t\t\t\tif ( complete ) {\n\t\t\t\t\twarn( 't.animateStyle returns a Promise as of 0.4.0. Transition authors should do t.animateStyle(...).then(callback)' );\n\t\t\t\t\tpromise.then( complete );\n\t\t\t\t}\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t}\n\t\treturn animateStyle;\n\t}( legacy, isClient, warn, Promise, prefix, virtualdom_items_Element_Transition$animateStyle_createTransitions, virtualdom_items_Element_Transition$animateStyle_visibility );\n\n\t/* utils/fillGaps.js */\n\tvar fillGaps = function( target ) {\n\t\tvar SLICE$0 = Array.prototype.slice;\n\t\tvar sources = SLICE$0.call( arguments, 1 );\n\t\tsources.forEach( function( s ) {\n\t\t\tfor ( var key in s ) {\n\t\t\t\tif ( s.hasOwnProperty( key ) && !( key in target ) ) {\n\t\t\t\t\ttarget[ key ] = s[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\treturn target;\n\t};\n\n\t/* virtualdom/items/Element/Transition/prototype/processParams.js */\n\tvar virtualdom_items_Element_Transition$processParams = function( fillGaps ) {\n\n\t\treturn function( params, defaults ) {\n\t\t\tif ( typeof params === 'number' ) {\n\t\t\t\tparams = {\n\t\t\t\t\tduration: params\n\t\t\t\t};\n\t\t\t} else if ( typeof params === 'string' ) {\n\t\t\t\tif ( params === 'slow' ) {\n\t\t\t\t\tparams = {\n\t\t\t\t\t\tduration: 600\n\t\t\t\t\t};\n\t\t\t\t} else if ( params === 'fast' ) {\n\t\t\t\t\tparams = {\n\t\t\t\t\t\tduration: 200\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tparams = {\n\t\t\t\t\t\tduration: 400\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else if ( !params ) {\n\t\t\t\tparams = {};\n\t\t\t}\n\t\t\treturn fillGaps( {}, params, defaults );\n\t\t};\n\t}( fillGaps );\n\n\t/* virtualdom/items/Element/Transition/prototype/start.js */\n\tvar virtualdom_items_Element_Transition$start = function() {\n\n\t\tvar __export;\n\t\t__export = function Transition$start() {\n\t\t\tvar t = this,\n\t\t\t\tnode, originalStyle, completed;\n\t\t\tnode = t.node = t.element.node;\n\t\t\toriginalStyle = node.getAttribute( 'style' );\n\t\t\t// create t.complete() - we don't want this on the prototype,\n\t\t\t// because we don't want `this` silliness when passing it as\n\t\t\t// an argument\n\t\t\tt.complete = function( noReset ) {\n\t\t\t\tif ( completed ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( !noReset && t.isIntro ) {\n\t\t\t\t\tresetStyle( node, originalStyle );\n\t\t\t\t}\n\t\t\t\tnode._ractive.transition = null;\n\t\t\t\tt._manager.remove( t );\n\t\t\t\tcompleted = true;\n\t\t\t};\n\t\t\t// If the transition function doesn't exist, abort\n\t\t\tif ( !t._fn ) {\n\t\t\t\tt.complete();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tt._fn.apply( t.root, [ t ].concat( t.params ) );\n\t\t};\n\n\t\tfunction resetStyle( node, style ) {\n\t\t\tif ( style ) {\n\t\t\t\tnode.setAttribute( 'style', style );\n\t\t\t} else {\n\t\t\t\t// Next line is necessary, to remove empty style attribute!\n\t\t\t\t// See http://stackoverflow.com/a/7167553\n\t\t\t\tnode.getAttribute( 'style' );\n\t\t\t\tnode.removeAttribute( 'style' );\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* virtualdom/items/Element/Transition/_Transition.js */\n\tvar Transition = function( init, getStyle, setStyle, animateStyle, processParams, start, circular ) {\n\n\t\tvar Fragment, Transition;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\tTransition = function( owner, template, isIntro ) {\n\t\t\tthis.init( owner, template, isIntro );\n\t\t};\n\t\tTransition.prototype = {\n\t\t\tinit: init,\n\t\t\tstart: start,\n\t\t\tgetStyle: getStyle,\n\t\t\tsetStyle: setStyle,\n\t\t\tanimateStyle: animateStyle,\n\t\t\tprocessParams: processParams\n\t\t};\n\t\treturn Transition;\n\t}( virtualdom_items_Element_Transition$init, virtualdom_items_Element_Transition$getStyle, virtualdom_items_Element_Transition$setStyle, virtualdom_items_Element_Transition$animateStyle__animateStyle, virtualdom_items_Element_Transition$processParams, virtualdom_items_Element_Transition$start, circular );\n\n\t/* virtualdom/items/Element/prototype/render.js */\n\tvar virtualdom_items_Element$render = function( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, renderImage, Transition ) {\n\n\t\tvar __export;\n\t\tvar updateCss, updateScript;\n\t\tupdateCss = function() {\n\t\t\tvar node = this.node,\n\t\t\t\tcontent = this.fragment.toString( false );\n\t\t\t// IE8 has no styleSheet unless there's a type text/css\n\t\t\tif ( window && window.appearsToBeIELessEqual8 ) {\n\t\t\t\tnode.type = 'text/css';\n\t\t\t}\n\t\t\tif ( node.styleSheet ) {\n\t\t\t\tnode.styleSheet.cssText = content;\n\t\t\t} else {\n\t\t\t\twhile ( node.hasChildNodes() ) {\n\t\t\t\t\tnode.removeChild( node.firstChild );\n\t\t\t\t}\n\t\t\t\tnode.appendChild( document.createTextNode( content ) );\n\t\t\t}\n\t\t};\n\t\tupdateScript = function() {\n\t\t\tif ( !this.node.type || this.node.type === 'text/javascript' ) {\n\t\t\t\twarn( 'Script tag was updated. This does not cause the code to be re-evaluated!' );\n\t\t\t}\n\t\t\tthis.node.text = this.fragment.toString( false );\n\t\t};\n\t\t__export = function Element$render() {\n\t\t\tvar this$0 = this;\n\t\t\tvar root = this.root,\n\t\t\t\tnamespace, node;\n\t\t\tnamespace = getNamespace( this );\n\t\t\tnode = this.node = createElement( this.name, namespace );\n\t\t\t// Is this a top-level node of a component? If so, we may need to add\n\t\t\t// a data-rvcguid attribute, for CSS encapsulation\n\t\t\t// NOTE: css no longer copied to instance, so we check constructor.css -\n\t\t\t// we can enhance to handle instance, but this is more \"correct\" with current\n\t\t\t// functionality\n\t\t\tif ( root.constructor.css && this.parentFragment.getNode() === root.el ) {\n\t\t\t\tthis.node.setAttribute( 'data-rvcguid', root.constructor._guid );\n\t\t\t}\n\t\t\t// Add _ractive property to the node - we use this object to store stuff\n\t\t\t// related to proxy events, two-way bindings etc\n\t\t\tdefineProperty( this.node, '_ractive', {\n\t\t\t\tvalue: {\n\t\t\t\t\tproxy: this,\n\t\t\t\t\tkeypath: getInnerContext( this.parentFragment ),\n\t\t\t\t\tindex: this.parentFragment.indexRefs,\n\t\t\t\t\tevents: create( null ),\n\t\t\t\t\troot: root\n\t\t\t\t}\n\t\t\t} );\n\t\t\t// Render attributes\n\t\t\tthis.attributes.forEach( function( a ) {\n\t\t\t\treturn a.render( node );\n\t\t\t} );\n\t\t\tthis.conditionalAttributes.forEach( function( a ) {\n\t\t\t\treturn a.render( node );\n\t\t\t} );\n\t\t\t// Render children\n\t\t\tif ( this.fragment ) {\n\t\t\t\t// Special case - <script> element\n\t\t\t\tif ( this.name === 'script' ) {\n\t\t\t\t\tthis.bubble = updateScript;\n\t\t\t\t\tthis.node.text = this.fragment.toString( false );\n\t\t\t\t\t// bypass warning initially\n\t\t\t\t\tthis.fragment.unrender = noop;\n\t\t\t\t} else if ( this.name === 'style' ) {\n\t\t\t\t\tthis.bubble = updateCss;\n\t\t\t\t\tthis.bubble();\n\t\t\t\t\tthis.fragment.unrender = noop;\n\t\t\t\t} else if ( this.binding && this.getAttribute( 'contenteditable' ) ) {\n\t\t\t\t\tthis.fragment.unrender = noop;\n\t\t\t\t} else {\n\t\t\t\t\tthis.node.appendChild( this.fragment.render() );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Add proxy event handlers\n\t\t\tif ( this.eventHandlers ) {\n\t\t\t\tthis.eventHandlers.forEach( function( h ) {\n\t\t\t\t\treturn h.render();\n\t\t\t\t} );\n\t\t\t}\n\t\t\t// deal with two-way bindings\n\t\t\tif ( this.binding ) {\n\t\t\t\tthis.binding.render();\n\t\t\t\tthis.node._ractive.binding = this.binding;\n\t\t\t}\n\t\t\t// Special case: if this is an <img>, and we're in a crap browser, we may\n\t\t\t// need to prevent it from overriding width and height when it loads the src\n\t\t\tif ( this.name === 'img' ) {\n\t\t\t\trenderImage( this );\n\t\t\t}\n\t\t\t// apply decorator(s)\n\t\t\tif ( this.decorator && this.decorator.fn ) {\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\tthis$0.decorator.init();\n\t\t\t\t} );\n\t\t\t}\n\t\t\t// trigger intro transition\n\t\t\tif ( root.transitionsEnabled && this.intro ) {\n\t\t\t\tvar transition = new Transition( this, this.intro, true );\n\t\t\t\trunloop.registerTransition( transition );\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\treturn transition.start();\n\t\t\t\t} );\n\t\t\t\tthis.transition = transition;\n\t\t\t}\n\t\t\tif ( this.name === 'option' ) {\n\t\t\t\tprocessOption( this );\n\t\t\t}\n\t\t\tif ( this.node.autofocus ) {\n\t\t\t\t// Special case. Some browsers (*cough* Firefix *cough*) have a problem\n\t\t\t\t// with dynamically-generated elements having autofocus, and they won't\n\t\t\t\t// allow you to programmatically focus the element until it's in the DOM\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\treturn this$0.node.focus();\n\t\t\t\t} );\n\t\t\t}\n\t\t\tupdateLiveQueries( this );\n\t\t\treturn this.node;\n\t\t};\n\n\t\tfunction getNamespace( element ) {\n\t\t\tvar namespace, xmlns, parent;\n\t\t\t// Use specified namespace...\n\t\t\tif ( xmlns = element.getAttribute( 'xmlns' ) ) {\n\t\t\t\tnamespace = xmlns;\n\t\t\t} else if ( element.name === 'svg' ) {\n\t\t\t\tnamespace = namespaces.svg;\n\t\t\t} else if ( parent = element.parent ) {\n\t\t\t\t// ...or HTML, if the parent is a <foreignObject>\n\t\t\t\tif ( parent.name === 'foreignObject' ) {\n\t\t\t\t\tnamespace = namespaces.html;\n\t\t\t\t} else {\n\t\t\t\t\tnamespace = parent.node.namespaceURI;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnamespace = element.root.el.namespaceURI;\n\t\t\t}\n\t\t\treturn namespace;\n\t\t}\n\n\t\tfunction processOption( option ) {\n\t\t\tvar optionValue, selectValue, i;\n\t\t\tif ( !option.select ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tselectValue = option.select.getAttribute( 'value' );\n\t\t\tif ( selectValue === undefined ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toptionValue = option.getAttribute( 'value' );\n\t\t\tif ( option.select.node.multiple && isArray( selectValue ) ) {\n\t\t\t\ti = selectValue.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( optionValue == selectValue[ i ] ) {\n\t\t\t\t\t\toption.node.selected = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toption.node.selected = optionValue == selectValue;\n\t\t\t}\n\t\t}\n\n\t\tfunction updateLiveQueries( element ) {\n\t\t\tvar instance, liveQueries, i, selector, query;\n\t\t\t// Does this need to be added to any live queries?\n\t\t\tinstance = element.root;\n\t\t\tdo {\n\t\t\t\tliveQueries = instance._liveQueries;\n\t\t\t\ti = liveQueries.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tselector = liveQueries[ i ];\n\t\t\t\t\tquery = liveQueries[ '_' + selector ];\n\t\t\t\t\tif ( query._test( element ) ) {\n\t\t\t\t\t\t// keep register of applicable selectors, for when we teardown\n\t\t\t\t\t\t( element.liveQueries || ( element.liveQueries = [] ) ).push( query );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while ( instance = instance._parent );\n\t\t}\n\t\treturn __export;\n\t}( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, render, Transition );\n\n\t/* virtualdom/items/Element/prototype/toString.js */\n\tvar virtualdom_items_Element$toString = function( voidElementNames, isArray, escapeHtml ) {\n\n\t\tvar __export;\n\t\t__export = function() {\n\t\t\tvar str, escape;\n\t\t\tstr = '<' + ( this.template.y ? '!DOCTYPE' : this.template.e );\n\t\t\tstr += this.attributes.map( stringifyAttribute ).join( '' ) + this.conditionalAttributes.map( stringifyAttribute ).join( '' );\n\t\t\t// Special case - selected options\n\t\t\tif ( this.name === 'option' && optionIsSelected( this ) ) {\n\t\t\t\tstr += ' selected';\n\t\t\t}\n\t\t\t// Special case - two-way radio name bindings\n\t\t\tif ( this.name === 'input' && inputIsCheckedRadio( this ) ) {\n\t\t\t\tstr += ' checked';\n\t\t\t}\n\t\t\tstr += '>';\n\t\t\t// Special case - textarea\n\t\t\tif ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {\n\t\t\t\tstr += escapeHtml( this.getAttribute( 'value' ) );\n\t\t\t} else if ( this.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\t\t\tstr += this.getAttribute( 'value' );\n\t\t\t}\n\t\t\tif ( this.fragment ) {\n\t\t\t\tescape = this.name !== 'script' && this.name !== 'style';\n\t\t\t\tstr += this.fragment.toString( escape );\n\t\t\t}\n\t\t\t// add a closing tag if this isn't a void element\n\t\t\tif ( !voidElementNames.test( this.template.e ) ) {\n\t\t\t\tstr += '</' + this.template.e + '>';\n\t\t\t}\n\t\t\treturn str;\n\t\t};\n\n\t\tfunction optionIsSelected( element ) {\n\t\t\tvar optionValue, selectValue, i;\n\t\t\toptionValue = element.getAttribute( 'value' );\n\t\t\tif ( optionValue === undefined || !element.select ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tselectValue = element.select.getAttribute( 'value' );\n\t\t\tif ( selectValue == optionValue ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {\n\t\t\t\ti = selectValue.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( selectValue[ i ] == optionValue ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction inputIsCheckedRadio( element ) {\n\t\t\tvar attributes, typeAttribute, valueAttribute, nameAttribute;\n\t\t\tattributes = element.attributes;\n\t\t\ttypeAttribute = attributes.type;\n\t\t\tvalueAttribute = attributes.value;\n\t\t\tnameAttribute = attributes.name;\n\t\t\tif ( !typeAttribute || typeAttribute.value !== 'radio' || !valueAttribute || !nameAttribute.interpolator ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( valueAttribute.value === nameAttribute.interpolator.value ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction stringifyAttribute( attribute ) {\n\t\t\tvar str = attribute.toString();\n\t\t\treturn str ? ' ' + str : '';\n\t\t}\n\t\treturn __export;\n\t}( voidElementNames, isArray, escapeHtml );\n\n\t/* virtualdom/items/Element/special/option/unbind.js */\n\tvar virtualdom_items_Element_special_option_unbind = function( removeFromArray ) {\n\n\t\treturn function unbindOption( option ) {\n\t\t\tif ( option.select ) {\n\t\t\t\tremoveFromArray( option.select.options, option );\n\t\t\t}\n\t\t};\n\t}( removeFromArray );\n\n\t/* virtualdom/items/Element/prototype/unbind.js */\n\tvar virtualdom_items_Element$unbind = function( unbindOption ) {\n\n\t\tvar __export;\n\t\t__export = function Element$unbind() {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.unbind();\n\t\t\t}\n\t\t\tif ( this.binding ) {\n\t\t\t\tthis.binding.unbind();\n\t\t\t}\n\t\t\tif ( this.eventHandlers ) {\n\t\t\t\tthis.eventHandlers.forEach( unbind );\n\t\t\t}\n\t\t\t// Special case - <option>\n\t\t\tif ( this.name === 'option' ) {\n\t\t\t\tunbindOption( this );\n\t\t\t}\n\t\t\tthis.attributes.forEach( unbind );\n\t\t\tthis.conditionalAttributes.forEach( unbind );\n\t\t};\n\n\t\tfunction unbind( x ) {\n\t\t\tx.unbind();\n\t\t}\n\t\treturn __export;\n\t}( virtualdom_items_Element_special_option_unbind );\n\n\t/* virtualdom/items/Element/prototype/unrender.js */\n\tvar virtualdom_items_Element$unrender = function( runloop, Transition ) {\n\n\t\tvar __export;\n\t\t__export = function Element$unrender( shouldDestroy ) {\n\t\t\tvar binding, bindings;\n\t\t\tif ( this.transition ) {\n\t\t\t\tthis.transition.complete();\n\t\t\t}\n\t\t\t// Detach as soon as we can\n\t\t\tif ( this.name === 'option' ) {\n\t\t\t\t// <option> elements detach immediately, so that\n\t\t\t\t// their parent <select> element syncs correctly, and\n\t\t\t\t// since option elements can't have transitions anyway\n\t\t\t\tthis.detach();\n\t\t\t} else if ( shouldDestroy ) {\n\t\t\t\trunloop.detachWhenReady( this );\n\t\t\t}\n\t\t\t// Children first. that way, any transitions on child elements will be\n\t\t\t// handled by the current transitionManager\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.unrender( false );\n\t\t\t}\n\t\t\tif ( binding = this.binding ) {\n\t\t\t\tthis.binding.unrender();\n\t\t\t\tthis.node._ractive.binding = null;\n\t\t\t\tbindings = this.root._twowayBindings[ binding.keypath ];\n\t\t\t\tbindings.splice( bindings.indexOf( binding ), 1 );\n\t\t\t}\n\t\t\t// Remove event handlers\n\t\t\tif ( this.eventHandlers ) {\n\t\t\t\tthis.eventHandlers.forEach( function( h ) {\n\t\t\t\t\treturn h.unrender();\n\t\t\t\t} );\n\t\t\t}\n\t\t\tif ( this.decorator ) {\n\t\t\t\tthis.decorator.teardown();\n\t\t\t}\n\t\t\t// trigger outro transition if necessary\n\t\t\tif ( this.root.transitionsEnabled && this.outro ) {\n\t\t\t\tvar transition = new Transition( this, this.outro, false );\n\t\t\t\trunloop.registerTransition( transition );\n\t\t\t\trunloop.scheduleTask( function() {\n\t\t\t\t\treturn transition.start();\n\t\t\t\t} );\n\t\t\t}\n\t\t\t// Remove this node from any live queries\n\t\t\tif ( this.liveQueries ) {\n\t\t\t\tremoveFromLiveQueries( this );\n\t\t\t}\n\t\t};\n\n\t\tfunction removeFromLiveQueries( element ) {\n\t\t\tvar query, selector, i;\n\t\t\ti = element.liveQueries.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tquery = element.liveQueries[ i ];\n\t\t\t\tselector = query.selector;\n\t\t\t\tquery._remove( element.node );\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}( runloop, Transition );\n\n\t/* virtualdom/items/Element/_Element.js */\n\tvar Element = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getAttribute, init, rebind, render, toString, unbind, unrender ) {\n\n\t\tvar Element = function( options ) {\n\t\t\tthis.init( options );\n\t\t};\n\t\tElement.prototype = {\n\t\t\tbubble: bubble,\n\t\t\tdetach: detach,\n\t\t\tfind: find,\n\t\t\tfindAll: findAll,\n\t\t\tfindAllComponents: findAllComponents,\n\t\t\tfindComponent: findComponent,\n\t\t\tfindNextNode: findNextNode,\n\t\t\tfirstNode: firstNode,\n\t\t\tgetAttribute: getAttribute,\n\t\t\tinit: init,\n\t\t\trebind: rebind,\n\t\t\trender: render,\n\t\t\ttoString: toString,\n\t\t\tunbind: unbind,\n\t\t\tunrender: unrender\n\t\t};\n\t\treturn Element;\n\t}( virtualdom_items_Element$bubble, virtualdom_items_Element$detach, virtualdom_items_Element$find, virtualdom_items_Element$findAll, virtualdom_items_Element$findAllComponents, virtualdom_items_Element$findComponent, virtualdom_items_Element$findNextNode, virtualdom_items_Element$firstNode, virtualdom_items_Element$getAttribute, virtualdom_items_Element$init, virtualdom_items_Element$rebind, virtualdom_items_Element$render, virtualdom_items_Element$toString, virtualdom_items_Element$unbind, virtualdom_items_Element$unrender );\n\n\t/* virtualdom/items/Partial/deIndent.js */\n\tvar deIndent = function() {\n\n\t\tvar __export;\n\t\tvar empty = /^\\s*$/,\n\t\t\tleadingWhitespace = /^\\s*/;\n\t\t__export = function( str ) {\n\t\t\tvar lines, firstLine, lastLine, minIndent;\n\t\t\tlines = str.split( '\\n' );\n\t\t\t// remove first and last line, if they only contain whitespace\n\t\t\tfirstLine = lines[ 0 ];\n\t\t\tif ( firstLine !== undefined && empty.test( firstLine ) ) {\n\t\t\t\tlines.shift();\n\t\t\t}\n\t\t\tlastLine = lines[ lines.length - 1 ];\n\t\t\tif ( lastLine !== undefined && empty.test( lastLine ) ) {\n\t\t\t\tlines.pop();\n\t\t\t}\n\t\t\tminIndent = lines.reduce( reducer, null );\n\t\t\tif ( minIndent ) {\n\t\t\t\tstr = lines.map( function( line ) {\n\t\t\t\t\treturn line.replace( minIndent, '' );\n\t\t\t\t} ).join( '\\n' );\n\t\t\t}\n\t\t\treturn str;\n\t\t};\n\n\t\tfunction reducer( previous, line ) {\n\t\t\tvar lineIndent = leadingWhitespace.exec( line )[ 0 ];\n\t\t\tif ( previous === null || lineIndent.length < previous.length ) {\n\t\t\t\treturn lineIndent;\n\t\t\t}\n\t\t\treturn previous;\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* virtualdom/items/Partial/getPartialTemplate.js */\n\tvar getPartialTemplate = function( log, config, parser, deIndent ) {\n\n\t\tvar __export;\n\t\t__export = function getPartialTemplate( ractive, name ) {\n\t\t\tvar partial;\n\t\t\t// If the partial in instance or view heirarchy instances, great\n\t\t\tif ( partial = getPartialFromRegistry( ractive, name ) ) {\n\t\t\t\treturn partial;\n\t\t\t}\n\t\t\t// Does it exist on the page as a script tag?\n\t\t\tpartial = parser.fromId( name, {\n\t\t\t\tnoThrow: true\n\t\t\t} );\n\t\t\tif ( partial ) {\n\t\t\t\t// is this necessary?\n\t\t\t\tpartial = deIndent( partial );\n\t\t\t\t// parse and register to this ractive instance\n\t\t\t\tvar parsed = parser.parse( partial, parser.getParseOptions( ractive ) );\n\t\t\t\t// register (and return main partial if there are others in the template)\n\t\t\t\treturn ractive.partials[ name ] = parsed.t;\n\t\t\t}\n\t\t};\n\n\t\tfunction getPartialFromRegistry( ractive, name ) {\n\t\t\tvar partials = config.registries.partials;\n\t\t\t// find first instance in the ractive or view hierarchy that has this partial\n\t\t\tvar instance = partials.findInstance( ractive, name );\n\t\t\tif ( !instance ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar partial = instance.partials[ name ],\n\t\t\t\tfn;\n\t\t\t// partial is a function?\n\t\t\tif ( typeof partial === 'function' ) {\n\t\t\t\tfn = partial.bind( instance );\n\t\t\t\tfn.isOwner = instance.partials.hasOwnProperty( name );\n\t\t\t\tpartial = fn( instance.data, parser );\n\t\t\t}\n\t\t\tif ( !partial ) {\n\t\t\t\tlog.warn( {\n\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\tmessage: 'noRegistryFunctionReturn',\n\t\t\t\t\targs: {\n\t\t\t\t\t\tregistry: 'partial',\n\t\t\t\t\t\tname: name\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If this was added manually to the registry,\n\t\t\t// but hasn't been parsed, parse it now\n\t\t\tif ( !parser.isParsed( partial ) ) {\n\t\t\t\t// use the parseOptions of the ractive instance on which it was found\n\t\t\t\tvar parsed = parser.parse( partial, parser.getParseOptions( instance ) );\n\t\t\t\t// Partials cannot contain nested partials!\n\t\t\t\t// TODO add a test for this\n\t\t\t\tif ( parsed.p ) {\n\t\t\t\t\tlog.warn( {\n\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\tmessage: 'noNestedPartials',\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\trname: name\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\t// if fn, use instance to store result, otherwise needs to go\n\t\t\t\t// in the correct point in prototype chain on instance or constructor\n\t\t\t\tvar target = fn ? instance : partials.findOwner( instance, name );\n\t\t\t\t// may be a template with partials, which need to be registered and main template extracted\n\t\t\t\ttarget.partials[ name ] = partial = parsed.t;\n\t\t\t}\n\t\t\t// store for reset\n\t\t\tif ( fn ) {\n\t\t\t\tpartial._fn = fn;\n\t\t\t}\n\t\t\treturn partial.v ? partial.t : partial;\n\t\t}\n\t\treturn __export;\n\t}( log, config, parser, deIndent );\n\n\t/* virtualdom/items/Partial/applyIndent.js */\n\tvar applyIndent = function( string, indent ) {\n\t\tvar indented;\n\t\tif ( !indent ) {\n\t\t\treturn string;\n\t\t}\n\t\tindented = string.split( '\\n' ).map( function( line, notFirstLine ) {\n\t\t\treturn notFirstLine ? indent + line : line;\n\t\t} ).join( '\\n' );\n\t\treturn indented;\n\t};\n\n\t/* virtualdom/items/Partial/_Partial.js */\n\tvar Partial = function( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind ) {\n\n\t\tvar Partial, Fragment;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\tPartial = function( options ) {\n\t\t\tvar parentFragment, template;\n\t\t\tparentFragment = this.parentFragment = options.parentFragment;\n\t\t\tthis.root = parentFragment.root;\n\t\t\tthis.type = types.PARTIAL;\n\t\t\tthis.index = options.index;\n\t\t\tthis.name = options.template.r;\n\t\t\tthis.fragment = this.fragmentToRender = this.fragmentToUnrender = null;\n\t\t\tMustache.init( this, options );\n\t\t\t// If this didn't resolve, it most likely means we have a named partial\n\t\t\t// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial\n\t\t\t// whose name is the value of `foo`')\n\t\t\tif ( !this.keypath && ( template = getPartialTemplate( this.root, this.name ) ) ) {\n\t\t\t\tunbind.call( this );\n\t\t\t\t// prevent any further changes\n\t\t\t\tthis.isNamed = true;\n\t\t\t\tthis.setTemplate( template );\n\t\t\t}\n\t\t};\n\t\tPartial.prototype = {\n\t\t\tbubble: function() {\n\t\t\t\tthis.parentFragment.bubble();\n\t\t\t},\n\t\t\tdetach: function() {\n\t\t\t\treturn this.fragment.detach();\n\t\t\t},\n\t\t\tfind: function( selector ) {\n\t\t\t\treturn this.fragment.find( selector );\n\t\t\t},\n\t\t\tfindAll: function( selector, query ) {\n\t\t\t\treturn this.fragment.findAll( selector, query );\n\t\t\t},\n\t\t\tfindComponent: function( selector ) {\n\t\t\t\treturn this.fragment.findComponent( selector );\n\t\t\t},\n\t\t\tfindAllComponents: function( selector, query ) {\n\t\t\t\treturn this.fragment.findAllComponents( selector, query );\n\t\t\t},\n\t\t\tfirstNode: function() {\n\t\t\t\treturn this.fragment.firstNode();\n\t\t\t},\n\t\t\tfindNextNode: function() {\n\t\t\t\treturn this.parentFragment.findNextNode( this );\n\t\t\t},\n\t\t\tgetValue: function() {\n\t\t\t\treturn this.fragment.getValue();\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\trebind.call( this, indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tthis.docFrag = document.createDocumentFragment();\n\t\t\t\tthis.update();\n\t\t\t\tthis.rendered = true;\n\t\t\t\treturn this.docFrag;\n\t\t\t},\n\t\t\tresolve: Mustache.resolve,\n\t\t\tsetValue: function( value ) {\n\t\t\t\tvar template;\n\t\t\t\tif ( value !== undefined && value === this.value ) {\n\t\t\t\t\t// nothing has changed, so no work to be done\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttemplate = getPartialTemplate( this.root, '' + value );\n\t\t\t\t// we may be here if we have a partial like `{{>foo}}` and `foo` is the\n\t\t\t\t// name of both a data property (whose value ISN'T the name of a partial)\n\t\t\t\t// and a partial. In those cases, this becomes a named partial\n\t\t\t\tif ( !template && ( template = getPartialTemplate( this.root, this.name ) ) ) {\n\t\t\t\t\tunbind.call( this );\n\t\t\t\t\tthis.isNamed = true;\n\t\t\t\t}\n\t\t\t\tif ( !template ) {\n\t\t\t\t\tlog.error( {\n\t\t\t\t\t\tdebug: this.root.debug,\n\t\t\t\t\t\tmessage: 'noTemplateForPartial',\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tname: this.name\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tthis.setTemplate( template || [] );\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.bubble();\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\trunloop.addView( this );\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetTemplate: function( template ) {\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t\tthis.fragmentToUnrender = this.fragment;\n\t\t\t\t}\n\t\t\t\tthis.fragment = new Fragment( {\n\t\t\t\t\ttemplate: template,\n\t\t\t\t\troot: this.root,\n\t\t\t\t\towner: this,\n\t\t\t\t\tpElement: this.parentFragment.pElement\n\t\t\t\t} );\n\t\t\t\tthis.fragmentToRender = this.fragment;\n\t\t\t},\n\t\t\ttoString: function( toString ) {\n\t\t\t\tvar string, previousItem, lastLine, match;\n\t\t\t\tstring = this.fragment.toString( toString );\n\t\t\t\tpreviousItem = this.parentFragment.items[ this.index - 1 ];\n\t\t\t\tif ( !previousItem || previousItem.type !== types.TEXT ) {\n\t\t\t\t\treturn string;\n\t\t\t\t}\n\t\t\t\tlastLine = previousItem.text.split( '\\n' ).pop();\n\t\t\t\tif ( match = /^\\s+$/.exec( lastLine ) ) {\n\t\t\t\t\treturn applyIndent( string, match[ 0 ] );\n\t\t\t\t}\n\t\t\t\treturn string;\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tif ( !this.isNamed ) {\n\t\t\t\t\t// dynamic partial - need to unbind self\n\t\t\t\t\tunbind.call( this );\n\t\t\t\t}\n\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t}\n\t\t\t},\n\t\t\tunrender: function( shouldDestroy ) {\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\tif ( this.fragment ) {\n\t\t\t\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\t\t\t}\n\t\t\t\t\tthis.rendered = false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tupdate: function() {\n\t\t\t\tvar target, anchor;\n\t\t\t\tif ( this.fragmentToUnrender ) {\n\t\t\t\t\tthis.fragmentToUnrender.unrender( true );\n\t\t\t\t\tthis.fragmentToUnrender = null;\n\t\t\t\t}\n\t\t\t\tif ( this.fragmentToRender ) {\n\t\t\t\t\tthis.docFrag.appendChild( this.fragmentToRender.render() );\n\t\t\t\t\tthis.fragmentToRender = null;\n\t\t\t\t}\n\t\t\t\tif ( this.rendered ) {\n\t\t\t\t\ttarget = this.parentFragment.getNode();\n\t\t\t\t\tanchor = this.parentFragment.findNextNode( this );\n\t\t\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn Partial;\n\t}( log, types, getPartialTemplate, applyIndent, circular, runloop, Mustache, rebind, unbind );\n\n\t/* virtualdom/items/Component/getComponent.js */\n\tvar getComponent = function( config, log, circular ) {\n\n\t\tvar Ractive;\n\t\tcircular.push( function() {\n\t\t\tRactive = circular.Ractive;\n\t\t} );\n\t\t// finds the component constructor in the registry or view hierarchy registries\n\t\treturn function getComponent( ractive, name ) {\n\t\t\tvar component, instance = config.registries.components.findInstance( ractive, name );\n\t\t\tif ( instance ) {\n\t\t\t\tcomponent = instance.components[ name ];\n\t\t\t\t// best test we have for not Ractive.extend\n\t\t\t\tif ( !component._parent ) {\n\t\t\t\t\t// function option, execute and store for reset\n\t\t\t\t\tvar fn = component.bind( instance );\n\t\t\t\t\tfn.isOwner = instance.components.hasOwnProperty( name );\n\t\t\t\t\tcomponent = fn( instance.data );\n\t\t\t\t\tif ( !component ) {\n\t\t\t\t\t\tlog.warn( {\n\t\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\t\tmessage: 'noRegistryFunctionReturn',\n\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\tregistry: 'component',\n\t\t\t\t\t\t\t\tname: name\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( typeof component === 'string' ) {\n\t\t\t\t\t\t//allow string lookup\n\t\t\t\t\t\tcomponent = getComponent( ractive, component );\n\t\t\t\t\t}\n\t\t\t\t\tcomponent._fn = fn;\n\t\t\t\t\tinstance.components[ name ] = component;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn component;\n\t\t};\n\t}( config, log, circular );\n\n\t/* virtualdom/items/Component/prototype/detach.js */\n\tvar virtualdom_items_Component$detach = function( Hook ) {\n\n\t\tvar detachHook = new Hook( 'detach' );\n\t\treturn function Component$detach() {\n\t\t\tvar detached = this.instance.fragment.detach();\n\t\t\tdetachHook.fire( this.instance );\n\t\t\treturn detached;\n\t\t};\n\t}( Ractive$shared_hooks_Hook );\n\n\t/* virtualdom/items/Component/prototype/find.js */\n\tvar virtualdom_items_Component$find = function Component$find( selector ) {\n\t\treturn this.instance.fragment.find( selector );\n\t};\n\n\t/* virtualdom/items/Component/prototype/findAll.js */\n\tvar virtualdom_items_Component$findAll = function Component$findAll( selector, query ) {\n\t\treturn this.instance.fragment.findAll( selector, query );\n\t};\n\n\t/* virtualdom/items/Component/prototype/findAllComponents.js */\n\tvar virtualdom_items_Component$findAllComponents = function Component$findAllComponents( selector, query ) {\n\t\tquery._test( this, true );\n\t\tif ( this.instance.fragment ) {\n\t\t\tthis.instance.fragment.findAllComponents( selector, query );\n\t\t}\n\t};\n\n\t/* virtualdom/items/Component/prototype/findComponent.js */\n\tvar virtualdom_items_Component$findComponent = function Component$findComponent( selector ) {\n\t\tif ( !selector || selector === this.name ) {\n\t\t\treturn this.instance;\n\t\t}\n\t\tif ( this.instance.fragment ) {\n\t\t\treturn this.instance.fragment.findComponent( selector );\n\t\t}\n\t\treturn null;\n\t};\n\n\t/* virtualdom/items/Component/prototype/findNextNode.js */\n\tvar virtualdom_items_Component$findNextNode = function Component$findNextNode() {\n\t\treturn this.parentFragment.findNextNode( this );\n\t};\n\n\t/* virtualdom/items/Component/prototype/firstNode.js */\n\tvar virtualdom_items_Component$firstNode = function Component$firstNode() {\n\t\tif ( this.rendered ) {\n\t\t\treturn this.instance.fragment.firstNode();\n\t\t}\n\t\treturn null;\n\t};\n\n\t/* virtualdom/items/Component/initialise/createModel/ComponentParameter.js */\n\tvar ComponentParameter = function( runloop, circular ) {\n\n\t\tvar Fragment, ComponentParameter;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\tComponentParameter = function( component, key, value ) {\n\t\t\tthis.parentFragment = component.parentFragment;\n\t\t\tthis.component = component;\n\t\t\tthis.key = key;\n\t\t\tthis.fragment = new Fragment( {\n\t\t\t\ttemplate: value,\n\t\t\t\troot: component.root,\n\t\t\t\towner: this\n\t\t\t} );\n\t\t\tthis.value = this.fragment.getValue();\n\t\t};\n\t\tComponentParameter.prototype = {\n\t\t\tbubble: function() {\n\t\t\t\tif ( !this.dirty ) {\n\t\t\t\t\tthis.dirty = true;\n\t\t\t\t\trunloop.addView( this );\n\t\t\t\t}\n\t\t\t},\n\t\t\tupdate: function() {\n\t\t\t\tvar value = this.fragment.getValue();\n\t\t\t\tthis.component.instance.viewmodel.set( this.key, value );\n\t\t\t\trunloop.addViewmodel( this.component.instance.viewmodel );\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.dirty = false;\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tthis.fragment.unbind();\n\t\t\t}\n\t\t};\n\t\treturn ComponentParameter;\n\t}( runloop, circular );\n\n\t/* virtualdom/items/Component/initialise/createModel/ReferenceExpressionParameter.js */\n\tvar ReferenceExpressionParameter = function( ReferenceExpressionResolver, createComponentBinding ) {\n\n\t\tvar ReferenceExpressionParameter = function( component, childKeypath, template, toBind ) {\n\t\t\tvar this$0 = this;\n\t\t\tthis.root = component.root;\n\t\t\tthis.parentFragment = component.parentFragment;\n\t\t\tthis.ready = false;\n\t\t\tthis.hash = null;\n\t\t\tthis.resolver = new ReferenceExpressionResolver( this, template, function( keypath ) {\n\t\t\t\t// Are we updating an existing binding?\n\t\t\t\tif ( this$0.binding || ( this$0.binding = component.bindings[ this$0.hash ] ) ) {\n\t\t\t\t\tcomponent.bindings[ this$0.hash ] = null;\n\t\t\t\t\tthis$0.binding.rebind( keypath );\n\t\t\t\t\tthis$0.hash = keypath + '=' + childKeypath;\n\t\t\t\t\tcomponent.bindings[ this$0.hash ];\n\t\t\t\t} else {\n\t\t\t\t\tif ( !this$0.ready ) {\n\t\t\t\t\t\t// The child instance isn't created yet, we need to create the binding later\n\t\t\t\t\t\ttoBind.push( {\n\t\t\t\t\t\t\tchildKeypath: childKeypath,\n\t\t\t\t\t\t\tparentKeypath: keypath\n\t\t\t\t\t\t} );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcreateComponentBinding( component, component.root, keypath, childKeypath );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis$0.value = component.root.viewmodel.get( keypath );\n\t\t\t} );\n\t\t};\n\t\tReferenceExpressionParameter.prototype = {\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tthis.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tthis.resolver.unbind();\n\t\t\t}\n\t\t};\n\t\treturn ReferenceExpressionParameter;\n\t}( ReferenceExpressionResolver, createComponentBinding );\n\n\t/* virtualdom/items/Component/initialise/createModel/_createModel.js */\n\tvar createModel = function( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter ) {\n\n\t\tvar __export;\n\t\t__export = function( component, defaultData, attributes, toBind ) {\n\t\t\tvar data = {},\n\t\t\t\tkey, value;\n\t\t\t// some parameters, e.g. foo=\"The value is {{bar}}\", are 'complex' - in\n\t\t\t// other words, we need to construct a string fragment to watch\n\t\t\t// when they change. We store these so they can be torn down later\n\t\t\tcomponent.complexParameters = [];\n\t\t\tfor ( key in attributes ) {\n\t\t\t\tif ( attributes.hasOwnProperty( key ) ) {\n\t\t\t\t\tvalue = getValue( component, key, attributes[ key ], toBind );\n\t\t\t\t\tif ( value !== undefined || defaultData[ key ] === undefined ) {\n\t\t\t\t\t\tdata[ key ] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn data;\n\t\t};\n\n\t\tfunction getValue( component, key, template, toBind ) {\n\t\t\tvar parameter, parsed, parentInstance, parentFragment, keypath, indexRef;\n\t\t\tparentInstance = component.root;\n\t\t\tparentFragment = component.parentFragment;\n\t\t\t// If this is a static value, great\n\t\t\tif ( typeof template === 'string' ) {\n\t\t\t\tparsed = parseJSON( template );\n\t\t\t\tif ( !parsed ) {\n\t\t\t\t\treturn template;\n\t\t\t\t}\n\t\t\t\treturn parsed.value;\n\t\t\t}\n\t\t\t// If null, we treat it as a boolean attribute (i.e. true)\n\t\t\tif ( template === null ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Single interpolator?\n\t\t\tif ( template.length === 1 && template[ 0 ].t === types.INTERPOLATOR ) {\n\t\t\t\t// If it's a regular interpolator, we bind to it\n\t\t\t\tif ( template[ 0 ].r ) {\n\t\t\t\t\t// Is it an index reference?\n\t\t\t\t\tif ( parentFragment.indexRefs && parentFragment.indexRefs[ indexRef = template[ 0 ].r ] !== undefined ) {\n\t\t\t\t\t\tcomponent.indexRefBindings[ indexRef ] = key;\n\t\t\t\t\t\treturn parentFragment.indexRefs[ indexRef ];\n\t\t\t\t\t}\n\t\t\t\t\t// TODO what about references that resolve late? Should these be considered?\n\t\t\t\t\tkeypath = resolveRef( parentInstance, template[ 0 ].r, parentFragment ) || template[ 0 ].r;\n\t\t\t\t\t// We need to set up bindings between parent and child, but\n\t\t\t\t\t// we can't do it yet because the child instance doesn't exist\n\t\t\t\t\t// yet - so we make a note instead\n\t\t\t\t\ttoBind.push( {\n\t\t\t\t\t\tchildKeypath: key,\n\t\t\t\t\t\tparentKeypath: keypath\n\t\t\t\t\t} );\n\t\t\t\t\treturn parentInstance.viewmodel.get( keypath );\n\t\t\t\t}\n\t\t\t\t// If it's a reference expression (e.g. `{{foo[bar]}}`), we need\n\t\t\t\t// to watch the keypath and create/destroy bindings\n\t\t\t\tif ( template[ 0 ].rx ) {\n\t\t\t\t\tparameter = new ReferenceExpressionParameter( component, key, template[ 0 ].rx, toBind );\n\t\t\t\t\tcomponent.complexParameters.push( parameter );\n\t\t\t\t\tparameter.ready = true;\n\t\t\t\t\treturn parameter.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// We have a 'complex parameter' - we need to create a full-blown string\n\t\t\t// fragment in order to evaluate and observe its value\n\t\t\tparameter = new ComponentParameter( component, key, template );\n\t\t\tcomponent.complexParameters.push( parameter );\n\t\t\treturn parameter.value;\n\t\t}\n\t\treturn __export;\n\t}( types, parseJSON, resolveRef, ComponentParameter, ReferenceExpressionParameter );\n\n\t/* virtualdom/items/Component/initialise/createInstance.js */\n\tvar createInstance = function( log ) {\n\n\t\treturn function( component, Component, data, contentDescriptor ) {\n\t\t\tvar instance, parentFragment, partials, ractive;\n\t\t\tparentFragment = component.parentFragment;\n\t\t\tractive = component.root;\n\t\t\t// Make contents available as a {{>content}} partial\n\t\t\tpartials = {\n\t\t\t\tcontent: contentDescriptor || []\n\t\t\t};\n\t\t\tif ( Component.defaults.el ) {\n\t\t\t\tlog.warn( {\n\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\tmessage: 'defaultElSpecified',\n\t\t\t\t\targs: {\n\t\t\t\t\t\tname: component.name\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\tinstance = new Component( {\n\t\t\t\tel: null,\n\t\t\t\tappend: true,\n\t\t\t\tdata: data,\n\t\t\t\tpartials: partials,\n\t\t\t\tmagic: ractive.magic || Component.defaults.magic,\n\t\t\t\tmodifyArrays: ractive.modifyArrays,\n\t\t\t\t_parent: ractive,\n\t\t\t\t_component: component,\n\t\t\t\t// need to inherit runtime parent adaptors\n\t\t\t\tadapt: ractive.adapt,\n\t\t\t\tyield: {\n\t\t\t\t\ttemplate: contentDescriptor,\n\t\t\t\t\tinstance: ractive\n\t\t\t\t}\n\t\t\t} );\n\t\t\treturn instance;\n\t\t};\n\t}( log );\n\n\t/* virtualdom/items/Component/initialise/createBindings.js */\n\tvar createBindings = function( createComponentBinding ) {\n\n\t\treturn function createInitialComponentBindings( component, toBind ) {\n\t\t\ttoBind.forEach( function createInitialComponentBinding( pair ) {\n\t\t\t\tvar childValue, parentValue;\n\t\t\t\tcreateComponentBinding( component, component.root, pair.parentKeypath, pair.childKeypath );\n\t\t\t\tchildValue = component.instance.viewmodel.get( pair.childKeypath );\n\t\t\t\tparentValue = component.root.viewmodel.get( pair.parentKeypath );\n\t\t\t\tif ( childValue !== undefined && parentValue === undefined ) {\n\t\t\t\t\tcomponent.root.viewmodel.set( pair.parentKeypath, childValue );\n\t\t\t\t}\n\t\t\t} );\n\t\t};\n\t}( createComponentBinding );\n\n\t/* virtualdom/items/Component/initialise/propagateEvents.js */\n\tvar propagateEvents = function( circular, fireEvent, log ) {\n\n\t\tvar __export;\n\t\tvar Fragment;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\t__export = function propagateEvents( component, eventsDescriptor ) {\n\t\t\tvar eventName;\n\t\t\tfor ( eventName in eventsDescriptor ) {\n\t\t\t\tif ( eventsDescriptor.hasOwnProperty( eventName ) ) {\n\t\t\t\t\tpropagateEvent( component.instance, component.root, eventName, eventsDescriptor[ eventName ] );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfunction propagateEvent( childInstance, parentInstance, eventName, proxyEventName ) {\n\t\t\tif ( typeof proxyEventName !== 'string' ) {\n\t\t\t\tlog.error( {\n\t\t\t\t\tdebug: parentInstance.debug,\n\t\t\t\t\tmessage: 'noComponentEventArguments'\n\t\t\t\t} );\n\t\t\t}\n\t\t\tchildInstance.on( eventName, function() {\n\t\t\t\tvar event, args;\n\t\t\t\t// semi-weak test, but what else? tag the event obj ._isEvent ?\n\t\t\t\tif ( arguments.length && arguments[ 0 ] && arguments[ 0 ].node ) {\n\t\t\t\t\tevent = Array.prototype.shift.call( arguments );\n\t\t\t\t}\n\t\t\t\targs = Array.prototype.slice.call( arguments );\n\t\t\t\tfireEvent( parentInstance, proxyEventName, {\n\t\t\t\t\tevent: event,\n\t\t\t\t\targs: args\n\t\t\t\t} );\n\t\t\t\t// cancel bubbling\n\t\t\t\treturn false;\n\t\t\t} );\n\t\t}\n\t\treturn __export;\n\t}( circular, Ractive$shared_fireEvent, log );\n\n\t/* virtualdom/items/Component/initialise/updateLiveQueries.js */\n\tvar updateLiveQueries = function( component ) {\n\t\tvar ancestor, query;\n\t\t// If there's a live query for this component type, add it\n\t\tancestor = component.root;\n\t\twhile ( ancestor ) {\n\t\t\tif ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\t\tquery.push( component.instance );\n\t\t\t}\n\t\t\tancestor = ancestor._parent;\n\t\t}\n\t};\n\n\t/* virtualdom/items/Component/prototype/init.js */\n\tvar virtualdom_items_Component$init = function( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries ) {\n\n\t\treturn function Component$init( options, Component ) {\n\t\t\tvar parentFragment, root, data, toBind;\n\t\t\tparentFragment = this.parentFragment = options.parentFragment;\n\t\t\troot = parentFragment.root;\n\t\t\tthis.root = root;\n\t\t\tthis.type = types.COMPONENT;\n\t\t\tthis.name = options.template.e;\n\t\t\tthis.index = options.index;\n\t\t\tthis.indexRefBindings = {};\n\t\t\tthis.bindings = [];\n\t\t\t// even though only one yielder is allowed, we need to have an array of them\n\t\t\t// as it's possible to cause a yielder to be created before the last one\n\t\t\t// was destroyed in the same turn of the runloop\n\t\t\tthis.yielders = [];\n\t\t\tif ( !Component ) {\n\t\t\t\tthrow new Error( 'Component \"' + this.name + '\" not found' );\n\t\t\t}\n\t\t\t// First, we need to create a model for the component - e.g. if we\n\t\t\t// encounter <widget foo='bar'/> then we need to create a widget\n\t\t\t// with `data: { foo: 'bar' }`.\n\t\t\t//\n\t\t\t// This may involve setting up some bindings, but we can't do it\n\t\t\t// yet so we take some notes instead\n\t\t\ttoBind = [];\n\t\t\tdata = createModel( this, Component.defaults.data || {}, options.template.a, toBind );\n\t\t\tcreateInstance( this, Component, data, options.template.f );\n\t\t\tcreateBindings( this, toBind );\n\t\t\tpropagateEvents( this, options.template.v );\n\t\t\t// intro, outro and decorator directives have no effect\n\t\t\tif ( options.template.t1 || options.template.t2 || options.template.o ) {\n\t\t\t\twarn( 'The \"intro\", \"outro\" and \"decorator\" directives have no effect on components' );\n\t\t\t}\n\t\t\tupdateLiveQueries( this );\n\t\t};\n\t}( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries );\n\n\t/* virtualdom/items/Component/prototype/rebind.js */\n\tvar virtualdom_items_Component$rebind = function( runloop, getNewKeypath ) {\n\n\t\treturn function Component$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\tvar childInstance = this.instance,\n\t\t\t\tparentInstance = childInstance._parent,\n\t\t\t\tindexRefAlias, query;\n\t\t\tthis.bindings.forEach( function( binding ) {\n\t\t\t\tvar updated;\n\t\t\t\tif ( binding.root !== parentInstance ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( updated = getNewKeypath( binding.keypath, oldKeypath, newKeypath ) ) {\n\t\t\t\t\tbinding.rebind( updated );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tthis.complexParameters.forEach( rebind );\n\t\t\tif ( this.yielders[ 0 ] ) {\n\t\t\t\trebind( this.yielders[ 0 ] );\n\t\t\t}\n\t\t\tif ( indexRefAlias = this.indexRefBindings[ indexRef ] ) {\n\t\t\t\trunloop.addViewmodel( childInstance.viewmodel );\n\t\t\t\tchildInstance.viewmodel.set( indexRefAlias, newIndex );\n\t\t\t}\n\t\t\tif ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {\n\t\t\t\tquery._makeDirty();\n\t\t\t}\n\n\t\t\tfunction rebind( x ) {\n\t\t\t\tx.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t}\n\t\t};\n\t}( runloop, getNewKeypath );\n\n\t/* virtualdom/items/Component/prototype/render.js */\n\tvar virtualdom_items_Component$render = function Component$render() {\n\t\tvar instance = this.instance;\n\t\tinstance.render( this.parentFragment.getNode() );\n\t\tthis.rendered = true;\n\t\treturn instance.fragment.detach();\n\t};\n\n\t/* virtualdom/items/Component/prototype/toString.js */\n\tvar virtualdom_items_Component$toString = function Component$toString() {\n\t\treturn this.instance.fragment.toString();\n\t};\n\n\t/* virtualdom/items/Component/prototype/unbind.js */\n\tvar virtualdom_items_Component$unbind = function() {\n\n\t\tvar __export;\n\t\t__export = function Component$unbind() {\n\t\t\tthis.complexParameters.forEach( unbind );\n\t\t\tthis.bindings.forEach( unbind );\n\t\t\tremoveFromLiveComponentQueries( this );\n\t\t\tthis.instance.fragment.unbind();\n\t\t};\n\n\t\tfunction unbind( thing ) {\n\t\t\tthing.unbind();\n\t\t}\n\n\t\tfunction removeFromLiveComponentQueries( component ) {\n\t\t\tvar instance, query;\n\t\t\tinstance = component.root;\n\t\t\tdo {\n\t\t\t\tif ( query = instance._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\t\t\tquery._remove( component );\n\t\t\t\t}\n\t\t\t} while ( instance = instance._parent );\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* virtualdom/items/Component/prototype/unrender.js */\n\tvar virtualdom_items_Component$unrender = function Component$unrender( shouldDestroy ) {\n\t\tthis.shouldDestroy = shouldDestroy;\n\t\tthis.instance.unrender();\n\t\tif ( shouldDestroy ) {\n\t\t\tthis.instance.teardown();\n\t\t}\n\t};\n\n\t/* virtualdom/items/Component/_Component.js */\n\tvar Component = function( detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, init, rebind, render, toString, unbind, unrender ) {\n\n\t\tvar Component = function( options, Constructor ) {\n\t\t\tthis.init( options, Constructor );\n\t\t};\n\t\tComponent.prototype = {\n\t\t\tdetach: detach,\n\t\t\tfind: find,\n\t\t\tfindAll: findAll,\n\t\t\tfindAllComponents: findAllComponents,\n\t\t\tfindComponent: findComponent,\n\t\t\tfindNextNode: findNextNode,\n\t\t\tfirstNode: firstNode,\n\t\t\tinit: init,\n\t\t\trebind: rebind,\n\t\t\trender: render,\n\t\t\ttoString: toString,\n\t\t\tunbind: unbind,\n\t\t\tunrender: unrender\n\t\t};\n\t\treturn Component;\n\t}( virtualdom_items_Component$detach, virtualdom_items_Component$find, virtualdom_items_Component$findAll, virtualdom_items_Component$findAllComponents, virtualdom_items_Component$findComponent, virtualdom_items_Component$findNextNode, virtualdom_items_Component$firstNode, virtualdom_items_Component$init, virtualdom_items_Component$rebind, virtualdom_items_Component$render, virtualdom_items_Component$toString, virtualdom_items_Component$unbind, virtualdom_items_Component$unrender );\n\n\t/* virtualdom/items/Comment.js */\n\tvar Comment = function( types, detach ) {\n\n\t\tvar Comment = function( options ) {\n\t\t\tthis.type = types.COMMENT;\n\t\t\tthis.value = options.template.c;\n\t\t};\n\t\tComment.prototype = {\n\t\t\tdetach: detach,\n\t\t\tfirstNode: function() {\n\t\t\t\treturn this.node;\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\tif ( !this.node ) {\n\t\t\t\t\tthis.node = document.createComment( this.value );\n\t\t\t\t}\n\t\t\t\treturn this.node;\n\t\t\t},\n\t\t\ttoString: function() {\n\t\t\t\treturn '<!--' + this.value + '-->';\n\t\t\t},\n\t\t\tunrender: function( shouldDestroy ) {\n\t\t\t\tif ( shouldDestroy ) {\n\t\t\t\t\tthis.node.parentNode.removeChild( this.node );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn Comment;\n\t}( types, detach );\n\n\t/* virtualdom/items/Yielder.js */\n\tvar Yielder = function( runloop, removeFromArray, circular ) {\n\n\t\tvar Fragment;\n\t\tcircular.push( function() {\n\t\t\tFragment = circular.Fragment;\n\t\t} );\n\t\tvar Yielder = function( options ) {\n\t\t\tvar componentInstance, component;\n\t\t\tcomponentInstance = options.parentFragment.root;\n\t\t\tthis.component = component = componentInstance.component;\n\t\t\tthis.surrogateParent = options.parentFragment;\n\t\t\tthis.parentFragment = component.parentFragment;\n\t\t\tthis.fragment = new Fragment( {\n\t\t\t\towner: this,\n\t\t\t\troot: componentInstance.yield.instance,\n\t\t\t\ttemplate: componentInstance.yield.template,\n\t\t\t\tpElement: this.surrogateParent.pElement\n\t\t\t} );\n\t\t\tcomponent.yielders.push( this );\n\t\t\trunloop.scheduleTask( function() {\n\t\t\t\tif ( component.yielders.length > 1 ) {\n\t\t\t\t\tthrow new Error( 'A component template can only have one {{yield}} declaration at a time' );\n\t\t\t\t}\n\t\t\t} );\n\t\t};\n\t\tYielder.prototype = {\n\t\t\tdetach: function() {\n\t\t\t\treturn this.fragment.detach();\n\t\t\t},\n\t\t\tfind: function( selector ) {\n\t\t\t\treturn this.fragment.find( selector );\n\t\t\t},\n\t\t\tfindAll: function( selector, query ) {\n\t\t\t\treturn this.fragment.findAll( selector, query );\n\t\t\t},\n\t\t\tfindComponent: function( selector ) {\n\t\t\t\treturn this.fragment.findComponent( selector );\n\t\t\t},\n\t\t\tfindAllComponents: function( selector, query ) {\n\t\t\t\treturn this.fragment.findAllComponents( selector, query );\n\t\t\t},\n\t\t\tfindNextNode: function() {\n\t\t\t\treturn this.surrogateParent.findNextNode( this );\n\t\t\t},\n\t\t\tfirstNode: function() {\n\t\t\t\treturn this.fragment.firstNode();\n\t\t\t},\n\t\t\tgetValue: function( options ) {\n\t\t\t\treturn this.fragment.getValue( options );\n\t\t\t},\n\t\t\trender: function() {\n\t\t\t\treturn this.fragment.render();\n\t\t\t},\n\t\t\tunbind: function() {\n\t\t\t\tthis.fragment.unbind();\n\t\t\t},\n\t\t\tunrender: function( shouldDestroy ) {\n\t\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\t\tremoveFromArray( this.component.yielders, this );\n\t\t\t},\n\t\t\trebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t\tthis.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t},\n\t\t\ttoString: function() {\n\t\t\t\treturn this.fragment.toString();\n\t\t\t}\n\t\t};\n\t\treturn Yielder;\n\t}( runloop, removeFromArray, circular );\n\n\t/* virtualdom/Fragment/prototype/init/createItem.js */\n\tvar virtualdom_Fragment$init_createItem = function( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder ) {\n\n\t\treturn function createItem( options ) {\n\t\t\tif ( typeof options.template === 'string' ) {\n\t\t\t\treturn new Text( options );\n\t\t\t}\n\t\t\tswitch ( options.template.t ) {\n\t\t\t\tcase types.INTERPOLATOR:\n\t\t\t\t\tif ( options.template.r === 'yield' ) {\n\t\t\t\t\t\treturn new Yielder( options );\n\t\t\t\t\t}\n\t\t\t\t\treturn new Interpolator( options );\n\t\t\t\tcase types.SECTION:\n\t\t\t\t\treturn new Section( options );\n\t\t\t\tcase types.TRIPLE:\n\t\t\t\t\treturn new Triple( options );\n\t\t\t\tcase types.ELEMENT:\n\t\t\t\t\tvar constructor;\n\t\t\t\t\tif ( constructor = getComponent( options.parentFragment.root, options.template.e ) ) {\n\t\t\t\t\t\treturn new Component( options, constructor );\n\t\t\t\t\t}\n\t\t\t\t\treturn new Element( options );\n\t\t\t\tcase types.PARTIAL:\n\t\t\t\t\treturn new Partial( options );\n\t\t\t\tcase types.COMMENT:\n\t\t\t\t\treturn new Comment( options );\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!' );\n\t\t\t}\n\t\t};\n\t}( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment, Yielder );\n\n\t/* virtualdom/Fragment/prototype/init.js */\n\tvar virtualdom_Fragment$init = function( types, create, createItem ) {\n\n\t\treturn function Fragment$init( options ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar parentFragment, parentRefs, ref;\n\t\t\t// The item that owns this fragment - an element, section, partial, or attribute\n\t\t\tthis.owner = options.owner;\n\t\t\tparentFragment = this.parent = this.owner.parentFragment;\n\t\t\t// inherited properties\n\t\t\tthis.root = options.root;\n\t\t\tthis.pElement = options.pElement;\n\t\t\tthis.context = options.context;\n\t\t\t// If parent item is a section, this may not be the only fragment\n\t\t\t// that belongs to it - we need to make a note of the index\n\t\t\tif ( this.owner.type === types.SECTION ) {\n\t\t\t\tthis.index = options.index;\n\t\t\t}\n\t\t\t// index references (the 'i' in {{#section:i}}...{{/section}}) need to cascade\n\t\t\t// down the tree\n\t\t\tif ( parentFragment ) {\n\t\t\t\tparentRefs = parentFragment.indexRefs;\n\t\t\t\tif ( parentRefs ) {\n\t\t\t\t\tthis.indexRefs = create( null );\n\t\t\t\t\t// avoids need for hasOwnProperty\n\t\t\t\t\tfor ( ref in parentRefs ) {\n\t\t\t\t\t\tthis.indexRefs[ ref ] = parentRefs[ ref ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( options.indexRef ) {\n\t\t\t\tif ( !this.indexRefs ) {\n\t\t\t\t\tthis.indexRefs = {};\n\t\t\t\t}\n\t\t\t\tthis.indexRefs[ options.indexRef ] = options.index;\n\t\t\t}\n\t\t\t// Time to create this fragment's child items\n\t\t\t// TEMP should this be happening?\n\t\t\tif ( typeof options.template === 'string' ) {\n\t\t\t\toptions.template = [ options.template ];\n\t\t\t} else if ( !options.template ) {\n\t\t\t\toptions.template = [];\n\t\t\t}\n\t\t\tthis.items = options.template.map( function( template, i ) {\n\t\t\t\treturn createItem( {\n\t\t\t\t\tparentFragment: this$0,\n\t\t\t\t\tpElement: options.pElement,\n\t\t\t\t\ttemplate: template,\n\t\t\t\t\tindex: i\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tthis.value = this.argsList = null;\n\t\t\tthis.dirtyArgs = this.dirtyValue = true;\n\t\t\tthis.bound = true;\n\t\t};\n\t}( types, create, virtualdom_Fragment$init_createItem );\n\n\t/* virtualdom/Fragment/prototype/rebind.js */\n\tvar virtualdom_Fragment$rebind = function( assignNewKeypath ) {\n\n\t\treturn function Fragment$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {\n\t\t\t// assign new context keypath if needed\n\t\t\tassignNewKeypath( this, 'context', oldKeypath, newKeypath );\n\t\t\tif ( this.indexRefs && this.indexRefs[ indexRef ] !== undefined ) {\n\t\t\t\tthis.indexRefs[ indexRef ] = newIndex;\n\t\t\t}\n\t\t\tthis.items.forEach( function( item ) {\n\t\t\t\tif ( item.rebind ) {\n\t\t\t\t\titem.rebind( indexRef, newIndex, oldKeypath, newKeypath );\n\t\t\t\t}\n\t\t\t} );\n\t\t};\n\t}( assignNewKeypath );\n\n\t/* virtualdom/Fragment/prototype/render.js */\n\tvar virtualdom_Fragment$render = function Fragment$render() {\n\t\tvar result;\n\t\tif ( this.items.length === 1 ) {\n\t\t\tresult = this.items[ 0 ].render();\n\t\t} else {\n\t\t\tresult = document.createDocumentFragment();\n\t\t\tthis.items.forEach( function( item ) {\n\t\t\t\tresult.appendChild( item.render() );\n\t\t\t} );\n\t\t}\n\t\tthis.rendered = true;\n\t\treturn result;\n\t};\n\n\t/* virtualdom/Fragment/prototype/toString.js */\n\tvar virtualdom_Fragment$toString = function Fragment$toString( escape ) {\n\t\tif ( !this.items ) {\n\t\t\treturn '';\n\t\t}\n\t\treturn this.items.map( function( item ) {\n\t\t\treturn item.toString( escape );\n\t\t} ).join( '' );\n\t};\n\n\t/* virtualdom/Fragment/prototype/unbind.js */\n\tvar virtualdom_Fragment$unbind = function() {\n\n\t\tvar __export;\n\t\t__export = function Fragment$unbind() {\n\t\t\tif ( !this.bound ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.items.forEach( unbindItem );\n\t\t\tthis.bound = false;\n\t\t};\n\n\t\tfunction unbindItem( item ) {\n\t\t\tif ( item.unbind ) {\n\t\t\t\titem.unbind();\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* virtualdom/Fragment/prototype/unrender.js */\n\tvar virtualdom_Fragment$unrender = function Fragment$unrender( shouldDestroy ) {\n\t\tif ( !this.rendered ) {\n\t\t\tthrow new Error( 'Attempted to unrender a fragment that was not rendered' );\n\t\t}\n\t\tthis.items.forEach( function( i ) {\n\t\t\treturn i.unrender( shouldDestroy );\n\t\t} );\n\t\tthis.rendered = false;\n\t};\n\n\t/* virtualdom/Fragment.js */\n\tvar Fragment = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getNode, getValue, init, rebind, render, toString, unbind, unrender, circular ) {\n\n\t\tvar Fragment = function( options ) {\n\t\t\tthis.init( options );\n\t\t};\n\t\tFragment.prototype = {\n\t\t\tbubble: bubble,\n\t\t\tdetach: detach,\n\t\t\tfind: find,\n\t\t\tfindAll: findAll,\n\t\t\tfindAllComponents: findAllComponents,\n\t\t\tfindComponent: findComponent,\n\t\t\tfindNextNode: findNextNode,\n\t\t\tfirstNode: firstNode,\n\t\t\tgetNode: getNode,\n\t\t\tgetValue: getValue,\n\t\t\tinit: init,\n\t\t\trebind: rebind,\n\t\t\trender: render,\n\t\t\ttoString: toString,\n\t\t\tunbind: unbind,\n\t\t\tunrender: unrender\n\t\t};\n\t\tcircular.Fragment = Fragment;\n\t\treturn Fragment;\n\t}( virtualdom_Fragment$bubble, virtualdom_Fragment$detach, virtualdom_Fragment$find, virtualdom_Fragment$findAll, virtualdom_Fragment$findAllComponents, virtualdom_Fragment$findComponent, virtualdom_Fragment$findNextNode, virtualdom_Fragment$firstNode, virtualdom_Fragment$getNode, virtualdom_Fragment$getValue, virtualdom_Fragment$init, virtualdom_Fragment$rebind, virtualdom_Fragment$render, virtualdom_Fragment$toString, virtualdom_Fragment$unbind, virtualdom_Fragment$unrender, circular );\n\n\t/* Ractive/prototype/reset.js */\n\tvar Ractive$reset = function( Hook, runloop, Fragment, config ) {\n\n\t\tvar shouldRerender = [\n\t\t\t\t'template',\n\t\t\t\t'partials',\n\t\t\t\t'components',\n\t\t\t\t'decorators',\n\t\t\t\t'events'\n\t\t\t],\n\t\t\tresetHook = new Hook( 'reset' );\n\t\treturn function Ractive$reset( data, callback ) {\n\t\t\tvar promise, wrapper, changes, i, rerender;\n\t\t\tif ( typeof data === 'function' && !callback ) {\n\t\t\t\tcallback = data;\n\t\t\t\tdata = {};\n\t\t\t} else {\n\t\t\t\tdata = data || {};\n\t\t\t}\n\t\t\tif ( typeof data !== 'object' ) {\n\t\t\t\tthrow new Error( 'The reset method takes either no arguments, or an object containing new data' );\n\t\t\t}\n\t\t\t// If the root object is wrapped, try and use the wrapper's reset value\n\t\t\tif ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {\n\t\t\t\tif ( wrapper.reset( data ) === false ) {\n\t\t\t\t\t// reset was rejected, we need to replace the object\n\t\t\t\t\tthis.data = data;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.data = data;\n\t\t\t}\n\t\t\t// reset config items and track if need to rerender\n\t\t\tchanges = config.reset( this );\n\t\t\ti = changes.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( shouldRerender.indexOf( changes[ i ] ) > -1 ) {\n\t\t\t\t\trerender = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( rerender ) {\n\t\t\t\tvar component;\n\t\t\t\tthis.viewmodel.mark( '' );\n\t\t\t\t// Is this is a component, we need to set the `shouldDestroy`\n\t\t\t\t// flag, otherwise it will assume by default that a parent node\n\t\t\t\t// will be detached, and therefore it doesn't need to bother\n\t\t\t\t// detaching its own nodes\n\t\t\t\tif ( component = this.component ) {\n\t\t\t\t\tcomponent.shouldDestroy = true;\n\t\t\t\t}\n\t\t\t\tthis.unrender();\n\t\t\t\tif ( component ) {\n\t\t\t\t\tcomponent.shouldDestroy = false;\n\t\t\t\t}\n\t\t\t\t// If the template changed, we need to destroy the parallel DOM\n\t\t\t\t// TODO if we're here, presumably it did?\n\t\t\t\tif ( this.fragment.template !== this.template ) {\n\t\t\t\t\tthis.fragment.unbind();\n\t\t\t\t\tthis.fragment = new Fragment( {\n\t\t\t\t\t\ttemplate: this.template,\n\t\t\t\t\t\troot: this,\n\t\t\t\t\t\towner: this\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\tpromise = this.render( this.el, this.anchor );\n\t\t\t} else {\n\t\t\t\tpromise = runloop.start( this, true );\n\t\t\t\tthis.viewmodel.mark( '' );\n\t\t\t\trunloop.end();\n\t\t\t}\n\t\t\tresetHook.fire( this, data );\n\t\t\tif ( callback ) {\n\t\t\t\tpromise.then( callback );\n\t\t\t}\n\t\t\treturn promise;\n\t\t};\n\t}( Ractive$shared_hooks_Hook, runloop, Fragment, config );\n\n\t/* Ractive/prototype/resetTemplate.js */\n\tvar Ractive$resetTemplate = function( config, Fragment ) {\n\n\t\treturn function Ractive$resetTemplate( template ) {\n\t\t\tvar transitionsEnabled, component;\n\t\t\tconfig.template.init( null, this, {\n\t\t\t\ttemplate: template\n\t\t\t} );\n\t\t\ttransitionsEnabled = this.transitionsEnabled;\n\t\t\tthis.transitionsEnabled = false;\n\t\t\t// Is this is a component, we need to set the `shouldDestroy`\n\t\t\t// flag, otherwise it will assume by default that a parent node\n\t\t\t// will be detached, and therefore it doesn't need to bother\n\t\t\t// detaching its own nodes\n\t\t\tif ( component = this.component ) {\n\t\t\t\tcomponent.shouldDestroy = true;\n\t\t\t}\n\t\t\tthis.unrender();\n\t\t\tif ( component ) {\n\t\t\t\tcomponent.shouldDestroy = false;\n\t\t\t}\n\t\t\t// remove existing fragment and create new one\n\t\t\tthis.fragment.unbind();\n\t\t\tthis.fragment = new Fragment( {\n\t\t\t\ttemplate: this.template,\n\t\t\t\troot: this,\n\t\t\t\towner: this\n\t\t\t} );\n\t\t\tthis.render( this.el, this.anchor );\n\t\t\tthis.transitionsEnabled = transitionsEnabled;\n\t\t};\n\t}( config, Fragment );\n\n\t/* Ractive/prototype/reverse.js */\n\tvar Ractive$reverse = function( makeArrayMethod ) {\n\n\t\treturn makeArrayMethod( 'reverse' );\n\t}( Ractive$shared_makeArrayMethod );\n\n\t/* Ractive/prototype/set.js */\n\tvar Ractive$set = function( runloop, isObject, normaliseKeypath, getMatchingKeypaths ) {\n\n\t\tvar wildcard = /\\*/;\n\t\treturn function Ractive$set( keypath, value, callback ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar map, promise;\n\t\t\tpromise = runloop.start( this, true );\n\t\t\t// Set multiple keypaths in one go\n\t\t\tif ( isObject( keypath ) ) {\n\t\t\t\tmap = keypath;\n\t\t\t\tcallback = value;\n\t\t\t\tfor ( keypath in map ) {\n\t\t\t\t\tif ( map.hasOwnProperty( keypath ) ) {\n\t\t\t\t\t\tvalue = map[ keypath ];\n\t\t\t\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\t\t\t\tthis.viewmodel.set( keypath, value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeypath = normaliseKeypath( keypath );\n\t\t\t\tif ( wildcard.test( keypath ) ) {\n\t\t\t\t\tgetMatchingKeypaths( this, keypath ).forEach( function( keypath ) {\n\t\t\t\t\t\tthis$0.viewmodel.set( keypath, value );\n\t\t\t\t\t} );\n\t\t\t\t} else {\n\t\t\t\t\tthis.viewmodel.set( keypath, value );\n\t\t\t\t}\n\t\t\t}\n\t\t\trunloop.end();\n\t\t\tif ( callback ) {\n\t\t\t\tpromise.then( callback.bind( this ) );\n\t\t\t}\n\t\t\treturn promise;\n\t\t};\n\t}( runloop, isObject, normaliseKeypath, getMatchingKeypaths );\n\n\t/* Ractive/prototype/shift.js */\n\tvar Ractive$shift = function( makeArrayMethod ) {\n\n\t\treturn makeArrayMethod( 'shift' );\n\t}( Ractive$shared_makeArrayMethod );\n\n\t/* Ractive/prototype/sort.js */\n\tvar Ractive$sort = function( makeArrayMethod ) {\n\n\t\treturn makeArrayMethod( 'sort' );\n\t}( Ractive$shared_makeArrayMethod );\n\n\t/* Ractive/prototype/splice.js */\n\tvar Ractive$splice = function( makeArrayMethod ) {\n\n\t\treturn makeArrayMethod( 'splice' );\n\t}( Ractive$shared_makeArrayMethod );\n\n\t/* Ractive/prototype/subtract.js */\n\tvar Ractive$subtract = function( add ) {\n\n\t\treturn function Ractive$subtract( keypath, d ) {\n\t\t\treturn add( this, keypath, d === undefined ? -1 : -d );\n\t\t};\n\t}( Ractive$shared_add );\n\n\t/* Ractive/prototype/teardown.js */\n\tvar Ractive$teardown = function( Hook, Promise, removeFromArray ) {\n\n\t\tvar teardownHook = new Hook( 'teardown' );\n\t\t// Teardown. This goes through the root fragment and all its children, removing observers\n\t\t// and generally cleaning up after itself\n\t\treturn function Ractive$teardown( callback ) {\n\t\t\tvar promise;\n\t\t\tthis.fragment.unbind();\n\t\t\tthis.viewmodel.teardown();\n\t\t\tif ( this.fragment.rendered && this.el.__ractive_instances__ ) {\n\t\t\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t\t\t}\n\t\t\tthis.shouldDestroy = true;\n\t\t\tpromise = this.fragment.rendered ? this.unrender() : Promise.resolve();\n\t\t\tteardownHook.fire( this );\n\t\t\tif ( callback ) {\n\t\t\t\t// TODO deprecate this?\n\t\t\t\tpromise.then( callback.bind( this ) );\n\t\t\t}\n\t\t\treturn promise;\n\t\t};\n\t}( Ractive$shared_hooks_Hook, Promise, removeFromArray );\n\n\t/* Ractive/prototype/toggle.js */\n\tvar Ractive$toggle = function( log ) {\n\n\t\treturn function Ractive$toggle( keypath, callback ) {\n\t\t\tvar value;\n\t\t\tif ( typeof keypath !== 'string' ) {\n\t\t\t\tlog.errorOnly( {\n\t\t\t\t\tdebug: this.debug,\n\t\t\t\t\tmesssage: 'badArguments',\n\t\t\t\t\targ: {\n\t\t\t\t\t\targuments: keypath\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\tvalue = this.get( keypath );\n\t\t\treturn this.set( keypath, !value, callback );\n\t\t};\n\t}( log );\n\n\t/* Ractive/prototype/toHTML.js */\n\tvar Ractive$toHTML = function Ractive$toHTML() {\n\t\treturn this.fragment.toString( true );\n\t};\n\n\t/* Ractive/prototype/unrender.js */\n\tvar Ractive$unrender = function( css, Hook, log, Promise, removeFromArray, runloop ) {\n\n\t\tvar unrenderHook = new Hook( 'unrender' );\n\t\treturn function Ractive$unrender() {\n\t\t\tvar this$0 = this;\n\t\t\tvar promise, shouldDestroy;\n\t\t\tif ( !this.fragment.rendered ) {\n\t\t\t\tlog.warn( {\n\t\t\t\t\tdebug: this.debug,\n\t\t\t\t\tmessage: 'ractive.unrender() was called on a Ractive instance that was not rendered'\n\t\t\t\t} );\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\t\tpromise = runloop.start( this, true );\n\t\t\t// If this is a component, and the component isn't marked for destruction,\n\t\t\t// don't detach nodes from the DOM unnecessarily\n\t\t\tshouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\t\t\tif ( this.constructor.css ) {\n\t\t\t\tpromise.then( function() {\n\t\t\t\t\tcss.remove( this$0.constructor );\n\t\t\t\t} );\n\t\t\t}\n\t\t\t// Cancel any animations in progress\n\t\t\twhile ( this._animations[ 0 ] ) {\n\t\t\t\tthis._animations[ 0 ].stop();\n\t\t\t}\n\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t\t\tunrenderHook.fire( this );\n\t\t\trunloop.end();\n\t\t\treturn promise;\n\t\t};\n\t}( global_css, Ractive$shared_hooks_Hook, log, Promise, removeFromArray, runloop );\n\n\t/* Ractive/prototype/unshift.js */\n\tvar Ractive$unshift = function( makeArrayMethod ) {\n\n\t\treturn makeArrayMethod( 'unshift' );\n\t}( Ractive$shared_makeArrayMethod );\n\n\t/* Ractive/prototype/update.js */\n\tvar Ractive$update = function( Hook, runloop ) {\n\n\t\tvar updateHook = new Hook( 'update' );\n\t\treturn function Ractive$update( keypath, callback ) {\n\t\t\tvar promise;\n\t\t\tif ( typeof keypath === 'function' ) {\n\t\t\t\tcallback = keypath;\n\t\t\t\tkeypath = '';\n\t\t\t} else {\n\t\t\t\tkeypath = keypath || '';\n\t\t\t}\n\t\t\tpromise = runloop.start( this, true );\n\t\t\tthis.viewmodel.mark( keypath );\n\t\t\trunloop.end();\n\t\t\tupdateHook.fire( this, keypath );\n\t\t\tif ( callback ) {\n\t\t\t\tpromise.then( callback.bind( this ) );\n\t\t\t}\n\t\t\treturn promise;\n\t\t};\n\t}( Ractive$shared_hooks_Hook, runloop );\n\n\t/* Ractive/prototype/updateModel.js */\n\tvar Ractive$updateModel = function( arrayContentsMatch, isEqual ) {\n\n\t\tvar __export;\n\t\t__export = function Ractive$updateModel( keypath, cascade ) {\n\t\t\tvar values;\n\t\t\tif ( typeof keypath !== 'string' ) {\n\t\t\t\tkeypath = '';\n\t\t\t\tcascade = true;\n\t\t\t}\n\t\t\tconsolidateChangedValues( this, keypath, values = {}, cascade );\n\t\t\treturn this.set( values );\n\t\t};\n\n\t\tfunction consolidateChangedValues( ractive, keypath, values, cascade ) {\n\t\t\tvar bindings, childDeps, i, binding, oldValue, newValue, checkboxGroups = [];\n\t\t\tbindings = ractive._twowayBindings[ keypath ];\n\t\t\tif ( bindings && ( i = bindings.length ) ) {\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tbinding = bindings[ i ];\n\t\t\t\t\t// special case - radio name bindings\n\t\t\t\t\tif ( binding.radioName && !binding.element.node.checked ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// special case - checkbox name bindings come in groups, so\n\t\t\t\t\t// we want to get the value once at most\n\t\t\t\t\tif ( binding.checkboxName ) {\n\t\t\t\t\t\tif ( !checkboxGroups[ binding.keypath ] && !binding.changed() ) {\n\t\t\t\t\t\t\tcheckboxGroups.push( binding.keypath );\n\t\t\t\t\t\t\tcheckboxGroups[ binding.keypath ] = binding;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\toldValue = binding.attribute.value;\n\t\t\t\t\tnewValue = binding.getValue();\n\t\t\t\t\tif ( arrayContentsMatch( oldValue, newValue ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !isEqual( oldValue, newValue ) ) {\n\t\t\t\t\t\tvalues[ keypath ] = newValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`\n\t\t\tif ( checkboxGroups.length ) {\n\t\t\t\tcheckboxGroups.forEach( function( keypath ) {\n\t\t\t\t\tvar binding, oldValue, newValue;\n\t\t\t\t\tbinding = checkboxGroups[ keypath ];\n\t\t\t\t\t// one to represent the entire group\n\t\t\t\t\toldValue = binding.attribute.value;\n\t\t\t\t\tnewValue = binding.getValue();\n\t\t\t\t\tif ( !arrayContentsMatch( oldValue, newValue ) ) {\n\t\t\t\t\t\tvalues[ keypath ] = newValue;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\tif ( !cascade ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// cascade\n\t\t\tchildDeps = ractive.viewmodel.depsMap[ 'default' ][ keypath ];\n\t\t\tif ( childDeps ) {\n\t\t\t\ti = childDeps.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tconsolidateChangedValues( ractive, childDeps[ i ], values, cascade );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}( arrayContentsMatch, isEqual );\n\n\t/* Ractive/prototype.js */\n\tvar prototype = function( add, animate, detach, find, findAll, findAllComponents, findComponent, fire, get, insert, merge, observe, off, on, pop, push, render, reset, resetTemplate, reverse, set, shift, sort, splice, subtract, teardown, toggle, toHTML, unrender, unshift, update, updateModel ) {\n\n\t\treturn {\n\t\t\tadd: add,\n\t\t\tanimate: animate,\n\t\t\tdetach: detach,\n\t\t\tfind: find,\n\t\t\tfindAll: findAll,\n\t\t\tfindAllComponents: findAllComponents,\n\t\t\tfindComponent: findComponent,\n\t\t\tfire: fire,\n\t\t\tget: get,\n\t\t\tinsert: insert,\n\t\t\tmerge: merge,\n\t\t\tobserve: observe,\n\t\t\toff: off,\n\t\t\ton: on,\n\t\t\tpop: pop,\n\t\t\tpush: push,\n\t\t\trender: render,\n\t\t\treset: reset,\n\t\t\tresetTemplate: resetTemplate,\n\t\t\treverse: reverse,\n\t\t\tset: set,\n\t\t\tshift: shift,\n\t\t\tsort: sort,\n\t\t\tsplice: splice,\n\t\t\tsubtract: subtract,\n\t\t\tteardown: teardown,\n\t\t\ttoggle: toggle,\n\t\t\ttoHTML: toHTML,\n\t\t\tunrender: unrender,\n\t\t\tunshift: unshift,\n\t\t\tupdate: update,\n\t\t\tupdateModel: updateModel\n\t\t};\n\t}( Ractive$add, Ractive$animate, Ractive$detach, Ractive$find, Ractive$findAll, Ractive$findAllComponents, Ractive$findComponent, Ractive$fire, Ractive$get, Ractive$insert, Ractive$merge, Ractive$observe, Ractive$off, Ractive$on, Ractive$pop, Ractive$push, Ractive$render, Ractive$reset, Ractive$resetTemplate, Ractive$reverse, Ractive$set, Ractive$shift, Ractive$sort, Ractive$splice, Ractive$subtract, Ractive$teardown, Ractive$toggle, Ractive$toHTML, Ractive$unrender, Ractive$unshift, Ractive$update, Ractive$updateModel );\n\n\t/* utils/getGuid.js */\n\tvar getGuid = function() {\n\t\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace( /[xy]/g, function( c ) {\n\t\t\tvar r, v;\n\t\t\tr = Math.random() * 16 | 0;\n\t\t\tv = c == 'x' ? r : r & 3 | 8;\n\t\t\treturn v.toString( 16 );\n\t\t} );\n\t};\n\n\t/* utils/getNextNumber.js */\n\tvar getNextNumber = function() {\n\n\t\tvar i = 0;\n\t\treturn function() {\n\t\t\treturn 'r-' + i++;\n\t\t};\n\t}();\n\n\t/* viewmodel/prototype/get/arrayAdaptor/processWrapper.js */\n\tvar viewmodel$get_arrayAdaptor_processWrapper = function( wrapper, array, methodName, newIndices ) {\n\t\tvar root = wrapper.root,\n\t\t\tkeypath = wrapper.keypath;\n\t\t// If this is a sort or reverse, we just do root.set()...\n\t\t// TODO use merge logic?\n\t\tif ( methodName === 'sort' || methodName === 'reverse' ) {\n\t\t\troot.viewmodel.set( keypath, array );\n\t\t\treturn;\n\t\t}\n\t\troot.viewmodel.smartUpdate( keypath, array, newIndices );\n\t};\n\n\t/* viewmodel/prototype/get/arrayAdaptor/patch.js */\n\tvar viewmodel$get_arrayAdaptor_patch = function( runloop, defineProperty, getNewIndices, processWrapper ) {\n\n\t\tvar patchedArrayProto = [],\n\t\t\tmutatorMethods = [\n\t\t\t\t'pop',\n\t\t\t\t'push',\n\t\t\t\t'reverse',\n\t\t\t\t'shift',\n\t\t\t\t'sort',\n\t\t\t\t'splice',\n\t\t\t\t'unshift'\n\t\t\t],\n\t\t\ttestObj, patchArrayMethods, unpatchArrayMethods;\n\t\tmutatorMethods.forEach( function( methodName ) {\n\t\t\tvar method = function() {\n\t\t\t\tvar SLICE$0 = Array.prototype.slice;\n\t\t\t\tvar args = SLICE$0.call( arguments, 0 );\n\t\t\t\tvar newIndices, result, wrapper, i;\n\t\t\t\tnewIndices = getNewIndices( this, methodName, args );\n\t\t\t\t// apply the underlying method\n\t\t\t\tresult = Array.prototype[ methodName ].apply( this, arguments );\n\t\t\t\t// trigger changes\n\t\t\t\trunloop.start();\n\t\t\t\tthis._ractive.setting = true;\n\t\t\t\ti = this._ractive.wrappers.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\twrapper = this._ractive.wrappers[ i ];\n\t\t\t\t\trunloop.addViewmodel( wrapper.root.viewmodel );\n\t\t\t\t\tprocessWrapper( wrapper, this, methodName, newIndices );\n\t\t\t\t}\n\t\t\t\trunloop.end();\n\t\t\t\tthis._ractive.setting = false;\n\t\t\t\treturn result;\n\t\t\t};\n\t\t\tdefineProperty( patchedArrayProto, methodName, {\n\t\t\t\tvalue: method\n\t\t\t} );\n\t\t} );\n\t\t// can we use prototype chain injection?\n\t\t// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\n\t\ttestObj = {};\n\t\tif ( testObj.__proto__ ) {\n\t\t\t// yes, we can\n\t\t\tpatchArrayMethods = function( array ) {\n\t\t\t\tarray.__proto__ = patchedArrayProto;\n\t\t\t};\n\t\t\tunpatchArrayMethods = function( array ) {\n\t\t\t\tarray.__proto__ = Array.prototype;\n\t\t\t};\n\t\t} else {\n\t\t\t// no, we can't\n\t\t\tpatchArrayMethods = function( array ) {\n\t\t\t\tvar i, methodName;\n\t\t\t\ti = mutatorMethods.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tmethodName = mutatorMethods[ i ];\n\t\t\t\t\tdefineProperty( array, methodName, {\n\t\t\t\t\t\tvalue: patchedArrayProto[ methodName ],\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t};\n\t\t\tunpatchArrayMethods = function( array ) {\n\t\t\t\tvar i;\n\t\t\t\ti = mutatorMethods.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tdelete array[ mutatorMethods[ i ] ];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tpatchArrayMethods.unpatch = unpatchArrayMethods;\n\t\treturn patchArrayMethods;\n\t}( runloop, defineProperty, getNewIndices, viewmodel$get_arrayAdaptor_processWrapper );\n\n\t/* viewmodel/prototype/get/arrayAdaptor.js */\n\tvar viewmodel$get_arrayAdaptor = function( defineProperty, isArray, patch ) {\n\n\t\tvar arrayAdaptor,\n\t\t\t// helpers\n\t\t\tArrayWrapper, errorMessage;\n\t\tarrayAdaptor = {\n\t\t\tfilter: function( object ) {\n\t\t\t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n\t\t\t\t// or the array didn't trigger the get() itself\n\t\t\t\treturn isArray( object ) && ( !object._ractive || !object._ractive.setting );\n\t\t\t},\n\t\t\twrap: function( ractive, array, keypath ) {\n\t\t\t\treturn new ArrayWrapper( ractive, array, keypath );\n\t\t\t}\n\t\t};\n\t\tArrayWrapper = function( ractive, array, keypath ) {\n\t\t\tthis.root = ractive;\n\t\t\tthis.value = array;\n\t\t\tthis.keypath = keypath;\n\t\t\t// if this array hasn't already been ractified, ractify it\n\t\t\tif ( !array._ractive ) {\n\t\t\t\t// define a non-enumerable _ractive property to store the wrappers\n\t\t\t\tdefineProperty( array, '_ractive', {\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\twrappers: [],\n\t\t\t\t\t\tinstances: [],\n\t\t\t\t\t\tsetting: false\n\t\t\t\t\t},\n\t\t\t\t\tconfigurable: true\n\t\t\t\t} );\n\t\t\t\tpatch( array );\n\t\t\t}\n\t\t\t// store the ractive instance, so we can handle transitions later\n\t\t\tif ( !array._ractive.instances[ ractive._guid ] ) {\n\t\t\t\tarray._ractive.instances[ ractive._guid ] = 0;\n\t\t\t\tarray._ractive.instances.push( ractive );\n\t\t\t}\n\t\t\tarray._ractive.instances[ ractive._guid ] += 1;\n\t\t\tarray._ractive.wrappers.push( this );\n\t\t};\n\t\tArrayWrapper.prototype = {\n\t\t\tget: function() {\n\t\t\t\treturn this.value;\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar array, storage, wrappers, instances, index;\n\t\t\t\tarray = this.value;\n\t\t\t\tstorage = array._ractive;\n\t\t\t\twrappers = storage.wrappers;\n\t\t\t\tinstances = storage.instances;\n\t\t\t\t// if teardown() was invoked because we're clearing the cache as a result of\n\t\t\t\t// a change that the array itself triggered, we can save ourselves the teardown\n\t\t\t\t// and immediate setup\n\t\t\t\tif ( storage.setting ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tindex = wrappers.indexOf( this );\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tthrow new Error( errorMessage );\n\t\t\t\t}\n\t\t\t\twrappers.splice( index, 1 );\n\t\t\t\t// if nothing else depends on this array, we can revert it to its\n\t\t\t\t// natural state\n\t\t\t\tif ( !wrappers.length ) {\n\t\t\t\t\tdelete array._ractive;\n\t\t\t\t\tpatch.unpatch( this.value );\n\t\t\t\t} else {\n\t\t\t\t\t// remove ractive instance if possible\n\t\t\t\t\tinstances[ this.root._guid ] -= 1;\n\t\t\t\t\tif ( !instances[ this.root._guid ] ) {\n\t\t\t\t\t\tindex = instances.indexOf( this.root );\n\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\tthrow new Error( errorMessage );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinstances.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\terrorMessage = 'Something went wrong in a rather interesting way';\n\t\treturn arrayAdaptor;\n\t}( defineProperty, isArray, viewmodel$get_arrayAdaptor_patch );\n\n\t/* viewmodel/prototype/get/magicArrayAdaptor.js */\n\tvar viewmodel$get_magicArrayAdaptor = function( magicAdaptor, arrayAdaptor ) {\n\n\t\tvar magicArrayAdaptor, MagicArrayWrapper;\n\t\tif ( magicAdaptor ) {\n\t\t\tmagicArrayAdaptor = {\n\t\t\t\tfilter: function( object, keypath, ractive ) {\n\t\t\t\t\treturn magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );\n\t\t\t\t},\n\t\t\t\twrap: function( ractive, array, keypath ) {\n\t\t\t\t\treturn new MagicArrayWrapper( ractive, array, keypath );\n\t\t\t\t}\n\t\t\t};\n\t\t\tMagicArrayWrapper = function( ractive, array, keypath ) {\n\t\t\t\tthis.value = array;\n\t\t\t\tthis.magic = true;\n\t\t\t\tthis.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );\n\t\t\t\tthis.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );\n\t\t\t};\n\t\t\tMagicArrayWrapper.prototype = {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn this.value;\n\t\t\t\t},\n\t\t\t\tteardown: function() {\n\t\t\t\t\tthis.arrayWrapper.teardown();\n\t\t\t\t\tthis.magicWrapper.teardown();\n\t\t\t\t},\n\t\t\t\treset: function( value ) {\n\t\t\t\t\treturn this.magicWrapper.reset( value );\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn magicArrayAdaptor;\n\t}( viewmodel$get_magicAdaptor, viewmodel$get_arrayAdaptor );\n\n\t/* viewmodel/prototype/adapt.js */\n\tvar viewmodel$adapt = function( config, arrayAdaptor, log, magicAdaptor, magicArrayAdaptor ) {\n\n\t\tvar __export;\n\t\tvar prefixers = {};\n\t\t__export = function Viewmodel$adapt( keypath, value ) {\n\t\t\tvar ractive = this.ractive,\n\t\t\t\tlen, i, adaptor, wrapped;\n\t\t\t// Do we have an adaptor for this value?\n\t\t\tlen = ractive.adapt.length;\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tadaptor = ractive.adapt[ i ];\n\t\t\t\t// Adaptors can be specified as e.g. [ 'Backbone.Model', 'Backbone.Collection' ] -\n\t\t\t\t// we need to get the actual adaptor if that's the case\n\t\t\t\tif ( typeof adaptor === 'string' ) {\n\t\t\t\t\tvar found = config.registries.adaptors.find( ractive, adaptor );\n\t\t\t\t\tif ( !found ) {\n\t\t\t\t\t\t// will throw. \"return\" for safety, if we downgrade :)\n\t\t\t\t\t\treturn log.critical( {\n\t\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\t\tmessage: 'missingPlugin',\n\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\tplugin: 'adaptor',\n\t\t\t\t\t\t\t\tname: adaptor\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\tadaptor = ractive.adapt[ i ] = found;\n\t\t\t\t}\n\t\t\t\tif ( adaptor.filter( value, keypath, ractive ) ) {\n\t\t\t\t\twrapped = this.wrapped[ keypath ] = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );\n\t\t\t\t\twrapped.value = value;\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( ractive.magic ) {\n\t\t\t\tif ( magicArrayAdaptor.filter( value, keypath, ractive ) ) {\n\t\t\t\t\tthis.wrapped[ keypath ] = magicArrayAdaptor.wrap( ractive, value, keypath );\n\t\t\t\t} else if ( magicAdaptor.filter( value, keypath, ractive ) ) {\n\t\t\t\t\tthis.wrapped[ keypath ] = magicAdaptor.wrap( ractive, value, keypath );\n\t\t\t\t}\n\t\t\t} else if ( ractive.modifyArrays && arrayAdaptor.filter( value, keypath, ractive ) ) {\n\t\t\t\tthis.wrapped[ keypath ] = arrayAdaptor.wrap( ractive, value, keypath );\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\t\tfunction prefixKeypath( obj, prefix ) {\n\t\t\tvar prefixed = {},\n\t\t\t\tkey;\n\t\t\tif ( !prefix ) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t\tprefix += '.';\n\t\t\tfor ( key in obj ) {\n\t\t\t\tif ( obj.hasOwnProperty( key ) ) {\n\t\t\t\t\tprefixed[ prefix + key ] = obj[ key ];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prefixed;\n\t\t}\n\n\t\tfunction getPrefixer( rootKeypath ) {\n\t\t\tvar rootDot;\n\t\t\tif ( !prefixers[ rootKeypath ] ) {\n\t\t\t\trootDot = rootKeypath ? rootKeypath + '.' : '';\n\t\t\t\tprefixers[ rootKeypath ] = function( relativeKeypath, value ) {\n\t\t\t\t\tvar obj;\n\t\t\t\t\tif ( typeof relativeKeypath === 'string' ) {\n\t\t\t\t\t\tobj = {};\n\t\t\t\t\t\tobj[ rootDot + relativeKeypath ] = value;\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t}\n\t\t\t\t\tif ( typeof relativeKeypath === 'object' ) {\n\t\t\t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n\t\t\t\t\t\treturn rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn prefixers[ rootKeypath ];\n\t\t}\n\t\treturn __export;\n\t}( config, viewmodel$get_arrayAdaptor, log, viewmodel$get_magicAdaptor, viewmodel$get_magicArrayAdaptor );\n\n\t/* viewmodel/helpers/getUpstreamChanges.js */\n\tvar getUpstreamChanges = function getUpstreamChanges( changes ) {\n\t\tvar upstreamChanges = [ '' ],\n\t\t\ti, keypath, keys, upstreamKeypath;\n\t\ti = changes.length;\n\t\twhile ( i-- ) {\n\t\t\tkeypath = changes[ i ];\n\t\t\tkeys = keypath.split( '.' );\n\t\t\twhile ( keys.length > 1 ) {\n\t\t\t\tkeys.pop();\n\t\t\t\tupstreamKeypath = keys.join( '.' );\n\t\t\t\tif ( upstreamChanges.indexOf( upstreamKeypath ) === -1 ) {\n\t\t\t\t\tupstreamChanges.push( upstreamKeypath );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn upstreamChanges;\n\t};\n\n\t/* viewmodel/prototype/applyChanges/getPotentialWildcardMatches.js */\n\tvar viewmodel$applyChanges_getPotentialWildcardMatches = function() {\n\n\t\tvar __export;\n\t\tvar starMaps = {};\n\t\t// This function takes a keypath such as 'foo.bar.baz', and returns\n\t\t// all the variants of that keypath that include a wildcard in place\n\t\t// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.\n\t\t// These are then checked against the dependants map (ractive.viewmodel.depsMap)\n\t\t// to see if any pattern observers are downstream of one or more of\n\t\t// these wildcard keypaths (e.g. 'foo.bar.*.status')\n\t\t__export = function getPotentialWildcardMatches( keypath ) {\n\t\t\tvar keys, starMap, mapper, result;\n\t\t\tkeys = keypath.split( '.' );\n\t\t\tstarMap = getStarMap( keys.length );\n\t\t\tmapper = function( star, i ) {\n\t\t\t\treturn star ? '*' : keys[ i ];\n\t\t\t};\n\t\t\tresult = starMap.map( function( mask ) {\n\t\t\t\treturn mask.map( mapper ).join( '.' );\n\t\t\t} );\n\t\t\treturn result;\n\t\t};\n\t\t// This function returns all the possible true/false combinations for\n\t\t// a given number - e.g. for two, the possible combinations are\n\t\t// [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n\t\t// It does so by getting all the binary values between 0 and e.g. 11\n\t\tfunction getStarMap( length ) {\n\t\t\tvar ones = '',\n\t\t\t\tmax, binary, starMap, mapper, i;\n\t\t\tif ( !starMaps[ length ] ) {\n\t\t\t\tstarMap = [];\n\t\t\t\twhile ( ones.length < length ) {\n\t\t\t\t\tones += 1;\n\t\t\t\t}\n\t\t\t\tmax = parseInt( ones, 2 );\n\t\t\t\tmapper = function( digit ) {\n\t\t\t\t\treturn digit === '1';\n\t\t\t\t};\n\t\t\t\tfor ( i = 0; i <= max; i += 1 ) {\n\t\t\t\t\tbinary = i.toString( 2 );\n\t\t\t\t\twhile ( binary.length < length ) {\n\t\t\t\t\t\tbinary = '0' + binary;\n\t\t\t\t\t}\n\t\t\t\t\tstarMap[ i ] = Array.prototype.map.call( binary, mapper );\n\t\t\t\t}\n\t\t\t\tstarMaps[ length ] = starMap;\n\t\t\t}\n\t\t\treturn starMaps[ length ];\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* viewmodel/prototype/applyChanges/notifyPatternObservers.js */\n\tvar viewmodel$applyChanges_notifyPatternObservers = function( getPotentialWildcardMatches ) {\n\n\t\tvar __export;\n\t\tvar lastKey = /[^\\.]+$/;\n\t\t__export = notifyPatternObservers;\n\n\t\tfunction notifyPatternObservers( viewmodel, keypath, onlyDirect ) {\n\t\t\tvar potentialWildcardMatches;\n\t\t\tupdateMatchingPatternObservers( viewmodel, keypath );\n\t\t\tif ( onlyDirect ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpotentialWildcardMatches = getPotentialWildcardMatches( keypath );\n\t\t\tpotentialWildcardMatches.forEach( function( upstreamPattern ) {\n\t\t\t\tcascade( viewmodel, upstreamPattern, keypath );\n\t\t\t} );\n\t\t}\n\n\t\tfunction cascade( viewmodel, upstreamPattern, keypath ) {\n\t\t\tvar group, map, actualChildKeypath;\n\t\t\tgroup = viewmodel.depsMap.patternObservers;\n\t\t\tmap = group[ upstreamPattern ];\n\t\t\tif ( map ) {\n\t\t\t\tmap.forEach( function( childKeypath ) {\n\t\t\t\t\tvar key = lastKey.exec( childKeypath )[ 0 ];\n\t\t\t\t\t// 'baz'\n\t\t\t\t\tactualChildKeypath = keypath ? keypath + '.' + key : key;\n\t\t\t\t\t// 'foo.bar.baz'\n\t\t\t\t\tupdateMatchingPatternObservers( viewmodel, actualChildKeypath );\n\t\t\t\t\tcascade( viewmodel, childKeypath, actualChildKeypath );\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tfunction updateMatchingPatternObservers( viewmodel, keypath ) {\n\t\t\tviewmodel.patternObservers.forEach( function( observer ) {\n\t\t\t\tif ( observer.regex.test( keypath ) ) {\n\t\t\t\t\tobserver.update( keypath );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t\treturn __export;\n\t}( viewmodel$applyChanges_getPotentialWildcardMatches );\n\n\t/* viewmodel/prototype/applyChanges.js */\n\tvar viewmodel$applyChanges = function( getUpstreamChanges, notifyPatternObservers ) {\n\n\t\tvar __export;\n\t\tvar dependantGroups = [\n\t\t\t'observers',\n\t\t\t'default'\n\t\t];\n\t\t__export = function Viewmodel$applyChanges() {\n\t\t\tvar this$0 = this;\n\t\t\tvar self = this,\n\t\t\t\tchanges, upstreamChanges, hash = {};\n\t\t\tchanges = this.changes;\n\t\t\tif ( !changes.length ) {\n\t\t\t\t// TODO we end up here on initial render. Perhaps we shouldn't?\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfunction cascade( keypath ) {\n\t\t\t\tvar map, dependants, keys;\n\t\t\t\tif ( self.noCascade.hasOwnProperty( keypath ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( dependants = self.deps.computed[ keypath ] ) {\n\t\t\t\t\tdependants.forEach( invalidate );\n\t\t\t\t\tkeys = dependants.map( getKey );\n\t\t\t\t\tkeys.forEach( mark );\n\t\t\t\t\tkeys.forEach( cascade );\n\t\t\t\t}\n\t\t\t\tif ( map = self.depsMap.computed[ keypath ] ) {\n\t\t\t\t\tmap.forEach( cascade );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction mark( keypath ) {\n\t\t\t\tself.mark( keypath );\n\t\t\t}\n\t\t\tchanges.forEach( cascade );\n\t\t\tupstreamChanges = getUpstreamChanges( changes );\n\t\t\tupstreamChanges.forEach( function( keypath ) {\n\t\t\t\tvar dependants, keys;\n\t\t\t\tif ( dependants = self.deps.computed[ keypath ] ) {\n\t\t\t\t\tdependants.forEach( invalidate );\n\t\t\t\t\tkeys = dependants.map( getKey );\n\t\t\t\t\tkeys.forEach( mark );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tthis.changes = [];\n\t\t\t// Pattern observers are a weird special case\n\t\t\tif ( this.patternObservers.length ) {\n\t\t\t\tupstreamChanges.forEach( function( keypath ) {\n\t\t\t\t\treturn notifyPatternObservers( this$0, keypath, true );\n\t\t\t\t} );\n\t\t\t\tchanges.forEach( function( keypath ) {\n\t\t\t\t\treturn notifyPatternObservers( this$0, keypath );\n\t\t\t\t} );\n\t\t\t}\n\t\t\tdependantGroups.forEach( function( group ) {\n\t\t\t\tif ( !this$0.deps[ group ] ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tupstreamChanges.forEach( function( keypath ) {\n\t\t\t\t\treturn notifyUpstreamDependants( this$0, keypath, group );\n\t\t\t\t} );\n\t\t\t\tnotifyAllDependants( this$0, changes, group );\n\t\t\t} );\n\t\t\t// Return a hash of keypaths to updated values\n\t\t\tchanges.forEach( function( keypath ) {\n\t\t\t\thash[ keypath ] = this$0.get( keypath );\n\t\t\t} );\n\t\t\tthis.implicitChanges = {};\n\t\t\tthis.noCascade = {};\n\t\t\treturn hash;\n\t\t};\n\n\t\tfunction invalidate( computation ) {\n\t\t\tcomputation.invalidate();\n\t\t}\n\n\t\tfunction getKey( computation ) {\n\t\t\treturn computation.key;\n\t\t}\n\n\t\tfunction notifyUpstreamDependants( viewmodel, keypath, groupName ) {\n\t\t\tvar dependants, value;\n\t\t\tif ( dependants = findDependants( viewmodel, keypath, groupName ) ) {\n\t\t\t\tvalue = viewmodel.get( keypath );\n\t\t\t\tdependants.forEach( function( d ) {\n\t\t\t\t\treturn d.setValue( value );\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tfunction notifyAllDependants( viewmodel, keypaths, groupName ) {\n\t\t\tvar queue = [];\n\t\t\taddKeypaths( keypaths );\n\t\t\tqueue.forEach( dispatch );\n\n\t\t\tfunction addKeypaths( keypaths ) {\n\t\t\t\tkeypaths.forEach( addKeypath );\n\t\t\t\tkeypaths.forEach( cascade );\n\t\t\t}\n\n\t\t\tfunction addKeypath( keypath ) {\n\t\t\t\tvar deps = findDependants( viewmodel, keypath, groupName );\n\t\t\t\tif ( deps ) {\n\t\t\t\t\tqueue.push( {\n\t\t\t\t\t\tkeypath: keypath,\n\t\t\t\t\t\tdeps: deps\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction cascade( keypath ) {\n\t\t\t\tvar childDeps;\n\t\t\t\tif ( childDeps = viewmodel.depsMap[ groupName ][ keypath ] ) {\n\t\t\t\t\taddKeypaths( childDeps );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction dispatch( set ) {\n\t\t\t\tvar value = viewmodel.get( set.keypath );\n\t\t\t\tset.deps.forEach( function( d ) {\n\t\t\t\t\treturn d.setValue( value );\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tfunction findDependants( viewmodel, keypath, groupName ) {\n\t\t\tvar group = viewmodel.deps[ groupName ];\n\t\t\treturn group ? group[ keypath ] : null;\n\t\t}\n\t\treturn __export;\n\t}( getUpstreamChanges, viewmodel$applyChanges_notifyPatternObservers );\n\n\t/* viewmodel/prototype/capture.js */\n\tvar viewmodel$capture = function Viewmodel$capture() {\n\t\tthis.captureGroups.push( [] );\n\t};\n\n\t/* viewmodel/prototype/clearCache.js */\n\tvar viewmodel$clearCache = function Viewmodel$clearCache( keypath, dontTeardownWrapper ) {\n\t\tvar cacheMap, wrapper;\n\t\tif ( !dontTeardownWrapper ) {\n\t\t\t// Is there a wrapped property at this keypath?\n\t\t\tif ( wrapper = this.wrapped[ keypath ] ) {\n\t\t\t\t// Did we unwrap it?\n\t\t\t\tif ( wrapper.teardown() !== false ) {\n\t\t\t\t\t// Is this right?\n\t\t\t\t\t// What's the meaning of returning false from teardown?\n\t\t\t\t\t// Could there be a GC ramification if this is a \"real\" ractive.teardown()?\n\t\t\t\t\tthis.wrapped[ keypath ] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.cache[ keypath ] = undefined;\n\t\tif ( cacheMap = this.cacheMap[ keypath ] ) {\n\t\t\twhile ( cacheMap.length ) {\n\t\t\t\tthis.clearCache( cacheMap.pop() );\n\t\t\t}\n\t\t}\n\t};\n\n\t/* viewmodel/Computation/getComputationSignature.js */\n\tvar getComputationSignature = function() {\n\n\t\tvar __export;\n\t\tvar pattern = /\\$\\{([^\\}]+)\\}/g;\n\t\t__export = function( signature ) {\n\t\t\tif ( typeof signature === 'function' ) {\n\t\t\t\treturn {\n\t\t\t\t\tget: signature\n\t\t\t\t};\n\t\t\t}\n\t\t\tif ( typeof signature === 'string' ) {\n\t\t\t\treturn {\n\t\t\t\t\tget: createFunctionFromString( signature )\n\t\t\t\t};\n\t\t\t}\n\t\t\tif ( typeof signature === 'object' && typeof signature.get === 'string' ) {\n\t\t\t\tsignature = {\n\t\t\t\t\tget: createFunctionFromString( signature.get ),\n\t\t\t\t\tset: signature.set\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn signature;\n\t\t};\n\n\t\tfunction createFunctionFromString( signature ) {\n\t\t\tvar functionBody = 'var __ractive=this;return(' + signature.replace( pattern, function( match, keypath ) {\n\t\t\t\treturn '__ractive.get(\"' + keypath + '\")';\n\t\t\t} ) + ')';\n\t\t\treturn new Function( functionBody );\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* viewmodel/Computation/Computation.js */\n\tvar Computation = function( log, isEqual ) {\n\n\t\tvar Computation = function( ractive, key, signature ) {\n\t\t\tvar this$0 = this;\n\t\t\tthis.ractive = ractive;\n\t\t\tthis.viewmodel = ractive.viewmodel;\n\t\t\tthis.key = key;\n\t\t\tthis.getter = signature.get;\n\t\t\tthis.setter = signature.set;\n\t\t\tthis.hardDeps = signature.deps || [];\n\t\t\tthis.softDeps = [];\n\t\t\tthis.depValues = {};\n\t\t\tif ( this.hardDeps ) {\n\t\t\t\tthis.hardDeps.forEach( function( d ) {\n\t\t\t\t\treturn ractive.viewmodel.register( d, this$0, 'computed' );\n\t\t\t\t} );\n\t\t\t}\n\t\t\tthis._dirty = this._firstRun = true;\n\t\t};\n\t\tComputation.prototype = {\n\t\t\tconstructor: Computation,\n\t\t\tinit: function() {\n\t\t\t\tvar initial;\n\t\t\t\tthis.bypass = true;\n\t\t\t\tinitial = this.ractive.viewmodel.get( this.key );\n\t\t\t\tthis.ractive.viewmodel.clearCache( this.key );\n\t\t\t\tthis.bypass = false;\n\t\t\t\tif ( this.setter && initial !== undefined ) {\n\t\t\t\t\tthis.set( initial );\n\t\t\t\t}\n\t\t\t},\n\t\t\tinvalidate: function() {\n\t\t\t\tthis._dirty = true;\n\t\t\t},\n\t\t\tget: function() {\n\t\t\t\tvar this$0 = this;\n\t\t\t\tvar ractive, newDeps, args, dependenciesChanged, dependencyValuesChanged = false;\n\t\t\t\tif ( this.getting ) {\n\t\t\t\t\t// prevent double-computation (e.g. caused by array mutation inside computation)\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.getting = true;\n\t\t\t\tif ( this._dirty ) {\n\t\t\t\t\tractive = this.ractive;\n\t\t\t\t\t// determine whether the inputs have changed, in case this depends on\n\t\t\t\t\t// other computed values\n\t\t\t\t\tif ( this._firstRun || !this.hardDeps.length && !this.softDeps.length ) {\n\t\t\t\t\t\tdependencyValuesChanged = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tthis.hardDeps,\n\t\t\t\t\t\t\tthis.softDeps\n\t\t\t\t\t\t].forEach( function( deps ) {\n\t\t\t\t\t\t\tvar keypath, value, i;\n\t\t\t\t\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti = deps.length;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tkeypath = deps[ i ];\n\t\t\t\t\t\t\t\tvalue = ractive.viewmodel.get( keypath );\n\t\t\t\t\t\t\t\tif ( !isEqual( value, this$0.depValues[ keypath ] ) ) {\n\t\t\t\t\t\t\t\t\tthis$0.depValues[ keypath ] = value;\n\t\t\t\t\t\t\t\t\tdependencyValuesChanged = true;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\t\t\tractive.viewmodel.capture();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif ( this.hardDeps.length ) {\n\t\t\t\t\t\t\t\targs = this.hardDeps.map( function( keypath ) {\n\t\t\t\t\t\t\t\t\treturn this$0.viewmodel.get( keypath );\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t\tthis.value = this.getter.apply( ractive, args );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.value = this.getter.call( ractive );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\tlog.warn( {\n\t\t\t\t\t\t\t\tdebug: ractive.debug,\n\t\t\t\t\t\t\t\tmessage: 'failedComputation',\n\t\t\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\t\t\tkey: this.key,\n\t\t\t\t\t\t\t\t\terr: err.message || err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tthis.value = void 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewDeps = ractive.viewmodel.release();\n\t\t\t\t\t\tdependenciesChanged = this.updateDependencies( newDeps );\n\t\t\t\t\t\tif ( dependenciesChanged ) {\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tthis.hardDeps,\n\t\t\t\t\t\t\t\tthis.softDeps\n\t\t\t\t\t\t\t].forEach( function( deps ) {\n\t\t\t\t\t\t\t\tdeps.forEach( function( keypath ) {\n\t\t\t\t\t\t\t\t\tthis$0.depValues[ keypath ] = ractive.viewmodel.get( keypath );\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._dirty = false;\n\t\t\t\t}\n\t\t\t\tthis.getting = this._firstRun = false;\n\t\t\t\treturn this.value;\n\t\t\t},\n\t\t\tset: function( value ) {\n\t\t\t\tif ( this.setting ) {\n\t\t\t\t\tthis.value = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( !this.setter ) {\n\t\t\t\t\tthrow new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );\n\t\t\t\t}\n\t\t\t\tthis.setter.call( this.ractive, value );\n\t\t\t},\n\t\t\tupdateDependencies: function( newDeps ) {\n\t\t\t\tvar i, oldDeps, keypath, dependenciesChanged;\n\t\t\t\toldDeps = this.softDeps;\n\t\t\t\t// remove dependencies that are no longer used\n\t\t\t\ti = oldDeps.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tkeypath = oldDeps[ i ];\n\t\t\t\t\tif ( newDeps.indexOf( keypath ) === -1 ) {\n\t\t\t\t\t\tdependenciesChanged = true;\n\t\t\t\t\t\tthis.viewmodel.unregister( keypath, this, 'computed' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// create references for any new dependencies\n\t\t\t\ti = newDeps.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tkeypath = newDeps[ i ];\n\t\t\t\t\tif ( oldDeps.indexOf( keypath ) === -1 && ( !this.hardDeps || this.hardDeps.indexOf( keypath ) === -1 ) ) {\n\t\t\t\t\t\tdependenciesChanged = true;\n\t\t\t\t\t\tthis.viewmodel.register( keypath, this, 'computed' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( dependenciesChanged ) {\n\t\t\t\t\tthis.softDeps = newDeps.slice();\n\t\t\t\t}\n\t\t\t\treturn dependenciesChanged;\n\t\t\t}\n\t\t};\n\t\treturn Computation;\n\t}( log, isEqual );\n\n\t/* viewmodel/prototype/compute.js */\n\tvar viewmodel$compute = function( getComputationSignature, Computation ) {\n\n\t\treturn function Viewmodel$compute( key, signature ) {\n\t\t\tsignature = getComputationSignature( signature );\n\t\t\treturn this.computations[ key ] = new Computation( this.ractive, key, signature );\n\t\t};\n\t}( getComputationSignature, Computation );\n\n\t/* viewmodel/prototype/get/FAILED_LOOKUP.js */\n\tvar viewmodel$get_FAILED_LOOKUP = {\n\t\tFAILED_LOOKUP: true\n\t};\n\n\t/* viewmodel/prototype/get/UnresolvedImplicitDependency.js */\n\tvar viewmodel$get_UnresolvedImplicitDependency = function( removeFromArray, runloop ) {\n\n\t\tvar empty = {};\n\t\tvar UnresolvedImplicitDependency = function( viewmodel, keypath ) {\n\t\t\tthis.viewmodel = viewmodel;\n\t\t\tthis.root = viewmodel.ractive;\n\t\t\t// TODO eliminate this\n\t\t\tthis.ref = keypath;\n\t\t\tthis.parentFragment = empty;\n\t\t\tviewmodel.unresolvedImplicitDependencies[ keypath ] = true;\n\t\t\tviewmodel.unresolvedImplicitDependencies.push( this );\n\t\t\trunloop.addUnresolved( this );\n\t\t};\n\t\tUnresolvedImplicitDependency.prototype = {\n\t\t\tresolve: function() {\n\t\t\t\tthis.viewmodel.mark( this.ref );\n\t\t\t\tthis.viewmodel.unresolvedImplicitDependencies[ this.ref ] = false;\n\t\t\t\tremoveFromArray( this.viewmodel.unresolvedImplicitDependencies, this );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\trunloop.removeUnresolved( this );\n\t\t\t}\n\t\t};\n\t\treturn UnresolvedImplicitDependency;\n\t}( removeFromArray, runloop );\n\n\t/* viewmodel/prototype/get.js */\n\tvar viewmodel$get = function( FAILED_LOOKUP, UnresolvedImplicitDependency ) {\n\n\t\tvar __export;\n\t\tvar empty = {};\n\t\t__export = function Viewmodel$get( keypath ) {\n\t\t\tvar options = arguments[ 1 ];\n\t\t\tif ( options === void 0 )\n\t\t\t\toptions = empty;\n\t\t\tvar ractive = this.ractive,\n\t\t\t\tcache = this.cache,\n\t\t\t\tvalue, computation, wrapped, captureGroup;\n\t\t\tif ( cache[ keypath ] === undefined ) {\n\t\t\t\t// Is this a computed property?\n\t\t\t\tif ( ( computation = this.computations[ keypath ] ) && !computation.bypass ) {\n\t\t\t\t\tvalue = computation.get();\n\t\t\t\t} else if ( wrapped = this.wrapped[ keypath ] ) {\n\t\t\t\t\tvalue = wrapped.value;\n\t\t\t\t} else if ( !keypath ) {\n\t\t\t\t\tthis.adapt( '', ractive.data );\n\t\t\t\t\tvalue = ractive.data;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = retrieve( this, keypath );\n\t\t\t\t}\n\t\t\t\tcache[ keypath ] = value;\n\t\t\t} else {\n\t\t\t\tvalue = cache[ keypath ];\n\t\t\t}\n\t\t\tif ( options.evaluateWrapped && ( wrapped = this.wrapped[ keypath ] ) ) {\n\t\t\t\tvalue = wrapped.get();\n\t\t\t}\n\t\t\t// capture the keypath, if we're inside a computation\n\t\t\tif ( options.capture && ( captureGroup = this.captureGroups[ this.captureGroups.length - 1 ] ) ) {\n\t\t\t\tif ( !~captureGroup.indexOf( keypath ) ) {\n\t\t\t\t\tcaptureGroup.push( keypath );\n\t\t\t\t\t// if we couldn't resolve the keypath, we need to make it as a failed\n\t\t\t\t\t// lookup, so that the computation updates correctly once we CAN\n\t\t\t\t\t// resolve the keypath\n\t\t\t\t\tif ( value === FAILED_LOOKUP && this.unresolvedImplicitDependencies[ keypath ] !== true ) {\n\t\t\t\t\t\tnew UnresolvedImplicitDependency( this, keypath );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value === FAILED_LOOKUP ? void 0 : value;\n\t\t};\n\n\t\tfunction retrieve( viewmodel, keypath ) {\n\t\t\tvar keys, key, parentKeypath, parentValue, cacheMap, value, wrapped;\n\t\t\tkeys = keypath.split( '.' );\n\t\t\tkey = keys.pop();\n\t\t\tparentKeypath = keys.join( '.' );\n\t\t\tparentValue = viewmodel.get( parentKeypath );\n\t\t\tif ( wrapped = viewmodel.wrapped[ parentKeypath ] ) {\n\t\t\t\tparentValue = wrapped.get();\n\t\t\t}\n\t\t\tif ( parentValue === null || parentValue === undefined ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// update cache map\n\t\t\tif ( !( cacheMap = viewmodel.cacheMap[ parentKeypath ] ) ) {\n\t\t\t\tviewmodel.cacheMap[ parentKeypath ] = [ keypath ];\n\t\t\t} else {\n\t\t\t\tif ( cacheMap.indexOf( keypath ) === -1 ) {\n\t\t\t\t\tcacheMap.push( keypath );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If this property doesn't exist, we return a sentinel value\n\t\t\t// so that we know to query parent scope (if such there be)\n\t\t\tif ( typeof parentValue === 'object' && !( key in parentValue ) ) {\n\t\t\t\treturn viewmodel.cache[ keypath ] = FAILED_LOOKUP;\n\t\t\t}\n\t\t\tvalue = parentValue[ key ];\n\t\t\t// Do we have an adaptor for this value?\n\t\t\tviewmodel.adapt( keypath, value, false );\n\t\t\t// Update cache\n\t\t\tviewmodel.cache[ keypath ] = value;\n\t\t\treturn value;\n\t\t}\n\t\treturn __export;\n\t}( viewmodel$get_FAILED_LOOKUP, viewmodel$get_UnresolvedImplicitDependency );\n\n\t/* viewmodel/prototype/init.js */\n\tvar viewmodel$init = function() {\n\n\t\tvar __export;\n\t\t__export = function Viewmodel$init() {\n\t\t\tvar key, computation, computations = [];\n\t\t\tfor ( key in this.ractive.computed ) {\n\t\t\t\tcomputation = this.compute( key, this.ractive.computed[ key ] );\n\t\t\t\tcomputations.push( computation );\n\t\t\t}\n\t\t\tcomputations.forEach( init );\n\t\t};\n\n\t\tfunction init( computation ) {\n\t\t\tcomputation.init();\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* viewmodel/prototype/mark.js */\n\tvar viewmodel$mark = function Viewmodel$mark( keypath, options ) {\n\t\tvar computation;\n\t\t// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)\n\t\t// should not be picked up by pattern observers\n\t\tif ( options ) {\n\t\t\tif ( options.implicit ) {\n\t\t\t\tthis.implicitChanges[ keypath ] = true;\n\t\t\t}\n\t\t\tif ( options.noCascade ) {\n\t\t\t\tthis.noCascade[ keypath ] = true;\n\t\t\t}\n\t\t}\n\t\tif ( computation = this.computations[ keypath ] ) {\n\t\t\tcomputation.invalidate();\n\t\t}\n\t\tif ( this.changes.indexOf( keypath ) === -1 ) {\n\t\t\tthis.changes.push( keypath );\n\t\t\tthis.clearCache( keypath );\n\t\t}\n\t};\n\n\t/* viewmodel/prototype/merge/mapOldToNewIndex.js */\n\tvar viewmodel$merge_mapOldToNewIndex = function( oldArray, newArray ) {\n\t\tvar usedIndices, firstUnusedIndex, newIndices, changed;\n\t\tusedIndices = {};\n\t\tfirstUnusedIndex = 0;\n\t\tnewIndices = oldArray.map( function( item, i ) {\n\t\t\tvar index, start, len;\n\t\t\tstart = firstUnusedIndex;\n\t\t\tlen = newArray.length;\n\t\t\tdo {\n\t\t\t\tindex = newArray.indexOf( item, start );\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tchanged = true;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tstart = index + 1;\n\t\t\t} while ( usedIndices[ index ] && start < len );\n\t\t\t// keep track of the first unused index, so we don't search\n\t\t\t// the whole of newArray for each item in oldArray unnecessarily\n\t\t\tif ( index === firstUnusedIndex ) {\n\t\t\t\tfirstUnusedIndex += 1;\n\t\t\t}\n\t\t\tif ( index !== i ) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tusedIndices[ index ] = true;\n\t\t\treturn index;\n\t\t} );\n\t\treturn newIndices;\n\t};\n\n\t/* viewmodel/prototype/merge.js */\n\tvar viewmodel$merge = function( warn, mapOldToNewIndex ) {\n\n\t\tvar __export;\n\t\tvar comparators = {};\n\t\t__export = function Viewmodel$merge( keypath, currentArray, array, options ) {\n\t\t\tvar oldArray, newArray, comparator, newIndices;\n\t\t\tthis.mark( keypath );\n\t\t\tif ( options && options.compare ) {\n\t\t\t\tcomparator = getComparatorFunction( options.compare );\n\t\t\t\ttry {\n\t\t\t\t\toldArray = currentArray.map( comparator );\n\t\t\t\t\tnewArray = array.map( comparator );\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\t// fallback to an identity check - worst case scenario we have\n\t\t\t\t\t// to do more DOM manipulation than we thought...\n\t\t\t\t\t// ...unless we're in debug mode of course\n\t\t\t\t\tif ( this.debug ) {\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t} else {\n\t\t\t\t\t\twarn( 'Merge operation: comparison failed. Falling back to identity checking' );\n\t\t\t\t\t}\n\t\t\t\t\toldArray = currentArray;\n\t\t\t\t\tnewArray = array;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toldArray = currentArray;\n\t\t\t\tnewArray = array;\n\t\t\t}\n\t\t\t// find new indices for members of oldArray\n\t\t\tnewIndices = mapOldToNewIndex( oldArray, newArray );\n\t\t\tthis.smartUpdate( keypath, array, newIndices, currentArray.length !== array.length );\n\t\t};\n\n\t\tfunction stringify( item ) {\n\t\t\treturn JSON.stringify( item );\n\t\t}\n\n\t\tfunction getComparatorFunction( comparator ) {\n\t\t\t// If `compare` is `true`, we use JSON.stringify to compare\n\t\t\t// objects that are the same shape, but non-identical - i.e.\n\t\t\t// { foo: 'bar' } !== { foo: 'bar' }\n\t\t\tif ( comparator === true ) {\n\t\t\t\treturn stringify;\n\t\t\t}\n\t\t\tif ( typeof comparator === 'string' ) {\n\t\t\t\tif ( !comparators[ comparator ] ) {\n\t\t\t\t\tcomparators[ comparator ] = function( item ) {\n\t\t\t\t\t\treturn item[ comparator ];\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn comparators[ comparator ];\n\t\t\t}\n\t\t\tif ( typeof comparator === 'function' ) {\n\t\t\t\treturn comparator;\n\t\t\t}\n\t\t\tthrow new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );\n\t\t}\n\t\treturn __export;\n\t}( warn, viewmodel$merge_mapOldToNewIndex );\n\n\t/* viewmodel/prototype/register.js */\n\tvar viewmodel$register = function() {\n\n\t\tvar __export;\n\t\t__export = function Viewmodel$register( keypath, dependant ) {\n\t\t\tvar group = arguments[ 2 ];\n\t\t\tif ( group === void 0 )\n\t\t\t\tgroup = 'default';\n\t\t\tvar depsByKeypath, deps;\n\t\t\tif ( dependant.isStatic ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdepsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );\n\t\t\tdeps = depsByKeypath[ keypath ] || ( depsByKeypath[ keypath ] = [] );\n\t\t\tdeps.push( dependant );\n\t\t\tif ( !keypath ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tupdateDependantsMap( this, keypath, group );\n\t\t};\n\n\t\tfunction updateDependantsMap( viewmodel, keypath, group ) {\n\t\t\tvar keys, parentKeypath, map, parent;\n\t\t\t// update dependants map\n\t\t\tkeys = keypath.split( '.' );\n\t\t\twhile ( keys.length ) {\n\t\t\t\tkeys.pop();\n\t\t\t\tparentKeypath = keys.join( '.' );\n\t\t\t\tmap = viewmodel.depsMap[ group ] || ( viewmodel.depsMap[ group ] = {} );\n\t\t\t\tparent = map[ parentKeypath ] || ( map[ parentKeypath ] = [] );\n\t\t\t\tif ( parent[ keypath ] === undefined ) {\n\t\t\t\t\tparent[ keypath ] = 0;\n\t\t\t\t\tparent.push( keypath );\n\t\t\t\t}\n\t\t\t\tparent[ keypath ] += 1;\n\t\t\t\tkeypath = parentKeypath;\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* viewmodel/prototype/release.js */\n\tvar viewmodel$release = function Viewmodel$release() {\n\t\treturn this.captureGroups.pop();\n\t};\n\n\t/* viewmodel/prototype/set.js */\n\tvar viewmodel$set = function( isEqual, createBranch ) {\n\n\t\tvar __export;\n\t\t__export = function Viewmodel$set( keypath, value, silent ) {\n\t\t\tvar computation, wrapper, dontTeardownWrapper;\n\t\t\tcomputation = this.computations[ keypath ];\n\t\t\tif ( computation ) {\n\t\t\t\tif ( computation.setting ) {\n\t\t\t\t\t// let the other computation set() handle things...\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcomputation.set( value );\n\t\t\t\tvalue = computation.get();\n\t\t\t}\n\t\t\tif ( isEqual( this.cache[ keypath ], value ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twrapper = this.wrapped[ keypath ];\n\t\t\t// If we have a wrapper with a `reset()` method, we try and use it. If the\n\t\t\t// `reset()` method returns false, the wrapper should be torn down, and\n\t\t\t// (most likely) a new one should be created later\n\t\t\tif ( wrapper && wrapper.reset ) {\n\t\t\t\tdontTeardownWrapper = wrapper.reset( value ) !== false;\n\t\t\t\tif ( dontTeardownWrapper ) {\n\t\t\t\t\tvalue = wrapper.get();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !computation && !dontTeardownWrapper ) {\n\t\t\t\tresolveSet( this, keypath, value );\n\t\t\t}\n\t\t\tif ( !silent ) {\n\t\t\t\tthis.mark( keypath );\n\t\t\t} else {\n\t\t\t\t// We're setting a parent of the original target keypath (i.e.\n\t\t\t\t// creating a fresh branch) - we need to clear the cache, but\n\t\t\t\t// not mark it as a change\n\t\t\t\tthis.clearCache( keypath );\n\t\t\t}\n\t\t};\n\n\t\tfunction resolveSet( viewmodel, keypath, value ) {\n\t\t\tvar keys, lastKey, parentKeypath, wrapper, parentValue, wrapperSet, valueSet;\n\t\t\twrapperSet = function() {\n\t\t\t\tif ( wrapper.set ) {\n\t\t\t\t\twrapper.set( lastKey, value );\n\t\t\t\t} else {\n\t\t\t\t\tparentValue = wrapper.get();\n\t\t\t\t\tvalueSet();\n\t\t\t\t}\n\t\t\t};\n\t\t\tvalueSet = function() {\n\t\t\t\tif ( !parentValue ) {\n\t\t\t\t\tparentValue = createBranch( lastKey );\n\t\t\t\t\tviewmodel.set( parentKeypath, parentValue, true );\n\t\t\t\t}\n\t\t\t\tparentValue[ lastKey ] = value;\n\t\t\t};\n\t\t\tkeys = keypath.split( '.' );\n\t\t\tlastKey = keys.pop();\n\t\t\tparentKeypath = keys.join( '.' );\n\t\t\twrapper = viewmodel.wrapped[ parentKeypath ];\n\t\t\tif ( wrapper ) {\n\t\t\t\twrapperSet();\n\t\t\t} else {\n\t\t\t\tparentValue = viewmodel.get( parentKeypath );\n\t\t\t\t// may have been wrapped via the above .get()\n\t\t\t\t// call on viewmodel if this is first access via .set()!\n\t\t\t\tif ( wrapper = viewmodel.wrapped[ parentKeypath ] ) {\n\t\t\t\t\twrapperSet();\n\t\t\t\t} else {\n\t\t\t\t\tvalueSet();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}( isEqual, createBranch );\n\n\t/* viewmodel/prototype/smartUpdate.js */\n\tvar viewmodel$smartUpdate = function() {\n\n\t\tvar __export;\n\t\tvar implicitOption = {\n\t\t\t\timplicit: true\n\t\t\t},\n\t\t\tnoCascadeOption = {\n\t\t\t\tnoCascade: true\n\t\t\t};\n\t\t__export = function Viewmodel$smartUpdate( keypath, array, newIndices ) {\n\t\t\tvar this$0 = this;\n\t\t\tvar dependants, oldLength;\n\t\t\toldLength = newIndices.length;\n\t\t\t// Indices that are being removed should be marked as dirty\n\t\t\tnewIndices.forEach( function( newIndex, oldIndex ) {\n\t\t\t\tif ( newIndex === -1 ) {\n\t\t\t\t\tthis$0.mark( keypath + '.' + oldIndex, noCascadeOption );\n\t\t\t\t}\n\t\t\t} );\n\t\t\t// Update the model\n\t\t\t// TODO allow existing array to be updated in place, rather than replaced?\n\t\t\tthis.set( keypath, array, true );\n\t\t\tif ( dependants = this.deps[ 'default' ][ keypath ] ) {\n\t\t\t\tdependants.filter( canShuffle ).forEach( function( d ) {\n\t\t\t\t\treturn d.shuffle( newIndices, array );\n\t\t\t\t} );\n\t\t\t}\n\t\t\tif ( oldLength !== array.length ) {\n\t\t\t\tthis.mark( keypath + '.length', implicitOption );\n\t\t\t\tfor ( var i = oldLength; i < array.length; i += 1 ) {\n\t\t\t\t\tthis.mark( keypath + '.' + i );\n\t\t\t\t}\n\t\t\t\t// don't allow removed indexes beyond end of new array to trigger recomputations\n\t\t\t\tfor ( var i$0 = array.length; i$0 < oldLength; i$0 += 1 ) {\n\t\t\t\t\tthis.mark( keypath + '.' + i$0, noCascadeOption );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfunction canShuffle( dependant ) {\n\t\t\treturn typeof dependant.shuffle === 'function';\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* viewmodel/prototype/teardown.js */\n\tvar viewmodel$teardown = function Viewmodel$teardown() {\n\t\tvar this$0 = this;\n\t\tvar unresolvedImplicitDependency;\n\t\t// Clear entire cache - this has the desired side-effect\n\t\t// of unwrapping adapted values (e.g. arrays)\n\t\tObject.keys( this.cache ).forEach( function( keypath ) {\n\t\t\treturn this$0.clearCache( keypath );\n\t\t} );\n\t\t// Teardown any failed lookups - we don't need them to resolve any more\n\t\twhile ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {\n\t\t\tunresolvedImplicitDependency.teardown();\n\t\t}\n\t};\n\n\t/* viewmodel/prototype/unregister.js */\n\tvar viewmodel$unregister = function() {\n\n\t\tvar __export;\n\t\t__export = function Viewmodel$unregister( keypath, dependant ) {\n\t\t\tvar group = arguments[ 2 ];\n\t\t\tif ( group === void 0 )\n\t\t\t\tgroup = 'default';\n\t\t\tvar deps, index;\n\t\t\tif ( dependant.isStatic ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdeps = this.deps[ group ][ keypath ];\n\t\t\tindex = deps.indexOf( dependant );\n\t\t\tif ( index === -1 ) {\n\t\t\t\tthrow new Error( 'Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks' );\n\t\t\t}\n\t\t\tdeps.splice( index, 1 );\n\t\t\tif ( !keypath ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tupdateDependantsMap( this, keypath, group );\n\t\t};\n\n\t\tfunction updateDependantsMap( viewmodel, keypath, group ) {\n\t\t\tvar keys, parentKeypath, map, parent;\n\t\t\t// update dependants map\n\t\t\tkeys = keypath.split( '.' );\n\t\t\twhile ( keys.length ) {\n\t\t\t\tkeys.pop();\n\t\t\t\tparentKeypath = keys.join( '.' );\n\t\t\t\tmap = viewmodel.depsMap[ group ];\n\t\t\t\tparent = map[ parentKeypath ];\n\t\t\t\tparent[ keypath ] -= 1;\n\t\t\t\tif ( !parent[ keypath ] ) {\n\t\t\t\t\t// remove from parent deps map\n\t\t\t\t\tparent.splice( parent.indexOf( keypath ), 1 );\n\t\t\t\t\tparent[ keypath ] = undefined;\n\t\t\t\t}\n\t\t\t\tkeypath = parentKeypath;\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}();\n\n\t/* viewmodel/adaptConfig.js */\n\tvar adaptConfig = function() {\n\n\t\t// should this be combined with prototype/adapt.js?\n\t\tvar configure = {\n\t\t\tlookup: function( target, adaptors ) {\n\t\t\t\tvar i, adapt = target.adapt;\n\t\t\t\tif ( !adapt || !adapt.length ) {\n\t\t\t\t\treturn adapt;\n\t\t\t\t}\n\t\t\t\tif ( adaptors && Object.keys( adaptors ).length && ( i = adapt.length ) ) {\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tvar adaptor = adapt[ i ];\n\t\t\t\t\t\tif ( typeof adaptor === 'string' ) {\n\t\t\t\t\t\t\tadapt[ i ] = adaptors[ adaptor ] || adaptor;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn adapt;\n\t\t\t},\n\t\t\tcombine: function( parent, adapt ) {\n\t\t\t\t// normalize 'Foo' to [ 'Foo' ]\n\t\t\t\tparent = arrayIfString( parent );\n\t\t\t\tadapt = arrayIfString( adapt );\n\t\t\t\t// no parent? return adapt\n\t\t\t\tif ( !parent || !parent.length ) {\n\t\t\t\t\treturn adapt;\n\t\t\t\t}\n\t\t\t\t// no adapt? return 'copy' of parent\n\t\t\t\tif ( !adapt || !adapt.length ) {\n\t\t\t\t\treturn parent.slice();\n\t\t\t\t}\n\t\t\t\t// add parent adaptors to options\n\t\t\t\tparent.forEach( function( a ) {\n\t\t\t\t\t// don't put in duplicates\n\t\t\t\t\tif ( adapt.indexOf( a ) === -1 ) {\n\t\t\t\t\t\tadapt.push( a );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn adapt;\n\t\t\t}\n\t\t};\n\n\t\tfunction arrayIfString( adapt ) {\n\t\t\tif ( typeof adapt === 'string' ) {\n\t\t\t\tadapt = [ adapt ];\n\t\t\t}\n\t\t\treturn adapt;\n\t\t}\n\t\treturn configure;\n\t}();\n\n\t/* viewmodel/Viewmodel.js */\n\tvar Viewmodel = function( create, adapt, applyChanges, capture, clearCache, compute, get, init, mark, merge, register, release, set, smartUpdate, teardown, unregister, adaptConfig ) {\n\n\t\tvar noMagic;\n\t\ttry {\n\t\t\tObject.defineProperty( {}, 'test', {\n\t\t\t\tvalue: 0\n\t\t\t} );\n\t\t} catch ( err ) {\n\t\t\tnoMagic = true;\n\t\t}\n\t\tvar Viewmodel = function( ractive ) {\n\t\t\tthis.ractive = ractive;\n\t\t\t// TODO eventually, we shouldn't need this reference\n\t\t\tViewmodel.extend( ractive.constructor, ractive );\n\t\t\tthis.cache = {};\n\t\t\t// we need to be able to use hasOwnProperty, so can't inherit from null\n\t\t\tthis.cacheMap = create( null );\n\t\t\tthis.deps = {\n\t\t\t\tcomputed: {},\n\t\t\t\t'default': {}\n\t\t\t};\n\t\t\tthis.depsMap = {\n\t\t\t\tcomputed: {},\n\t\t\t\t'default': {}\n\t\t\t};\n\t\t\tthis.patternObservers = [];\n\t\t\tthis.wrapped = create( null );\n\t\t\tthis.computations = create( null );\n\t\t\tthis.captureGroups = [];\n\t\t\tthis.unresolvedImplicitDependencies = [];\n\t\t\tthis.changes = [];\n\t\t\tthis.implicitChanges = {};\n\t\t\tthis.noCascade = {};\n\t\t};\n\t\tViewmodel.extend = function( Parent, instance ) {\n\t\t\tif ( instance.magic && noMagic ) {\n\t\t\t\tthrow new Error( 'Getters and setters (magic mode) are not supported in this browser' );\n\t\t\t}\n\t\t\tinstance.adapt = adaptConfig.combine( Parent.prototype.adapt, instance.adapt ) || [];\n\t\t\tinstance.adapt = adaptConfig.lookup( instance, instance.adaptors );\n\t\t};\n\t\tViewmodel.prototype = {\n\t\t\tadapt: adapt,\n\t\t\tapplyChanges: applyChanges,\n\t\t\tcapture: capture,\n\t\t\tclearCache: clearCache,\n\t\t\tcompute: compute,\n\t\t\tget: get,\n\t\t\tinit: init,\n\t\t\tmark: mark,\n\t\t\tmerge: merge,\n\t\t\tregister: register,\n\t\t\trelease: release,\n\t\t\tset: set,\n\t\t\tsmartUpdate: smartUpdate,\n\t\t\tteardown: teardown,\n\t\t\tunregister: unregister\n\t\t};\n\t\treturn Viewmodel;\n\t}( create, viewmodel$adapt, viewmodel$applyChanges, viewmodel$capture, viewmodel$clearCache, viewmodel$compute, viewmodel$get, viewmodel$init, viewmodel$mark, viewmodel$merge, viewmodel$register, viewmodel$release, viewmodel$set, viewmodel$smartUpdate, viewmodel$teardown, viewmodel$unregister, adaptConfig );\n\n\t/* Ractive/initialise.js */\n\tvar Ractive_initialise = function( config, create, Fragment, getElement, getNextNumber, Hook, HookQueue, Viewmodel ) {\n\n\t\tvar __export;\n\t\tvar constructHook = new Hook( 'construct' ),\n\t\t\tconfigHook = new Hook( 'config' ),\n\t\t\tinitHook = new HookQueue( 'init' );\n\t\t__export = function initialiseRactiveInstance( ractive ) {\n\t\t\tvar options = arguments[ 1 ];\n\t\t\tif ( options === void 0 )\n\t\t\t\toptions = {};\n\t\t\tvar el;\n\t\t\tinitialiseProperties( ractive, options );\n\t\t\t// make this option do what would be expected if someone\n\t\t\t// did include it on a new Ractive() or new Component() call.\n\t\t\t// Silly to do so (put a hook on the very options being used),\n\t\t\t// but handle it correctly, consistent with the intent.\n\t\t\tconstructHook.fire( config.getConstructTarget( ractive, options ), options );\n\t\t\t// init config from Parent and options\n\t\t\tconfig.init( ractive.constructor, ractive, options );\n\t\t\tconfigHook.fire( ractive );\n\t\t\t// Teardown any existing instances *before* trying to set up the new one -\n\t\t\t// avoids certain weird bugs\n\t\t\tif ( el = getElement( ractive.el ) ) {\n\t\t\t\tif ( !ractive.append ) {\n\t\t\t\t\tif ( el.__ractive_instances__ ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tel.__ractive_instances__.splice( 0, el.__ractive_instances__.length ).forEach( function( r ) {\n\t\t\t\t\t\t\t\treturn r.teardown();\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} catch ( err ) {}\n\t\t\t\t\t}\n\t\t\t\t\tel.innerHTML = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tinitHook.begin( ractive );\n\t\t\t// TEMPORARY. This is so we can implement Viewmodel gradually\n\t\t\tractive.viewmodel = new Viewmodel( ractive );\n\t\t\t// hacky circular problem until we get this sorted out\n\t\t\t// if viewmodel immediately processes computed properties,\n\t\t\t// they may call ractive.get, which calls ractive.viewmodel,\n\t\t\t// which hasn't been set till line above finishes.\n\t\t\tractive.viewmodel.init();\n\t\t\t// Render our *root fragment*\n\t\t\tif ( ractive.template ) {\n\t\t\t\tractive.fragment = new Fragment( {\n\t\t\t\t\ttemplate: ractive.template,\n\t\t\t\t\troot: ractive,\n\t\t\t\t\towner: ractive\n\t\t\t\t} );\n\t\t\t}\n\t\t\tinitHook.end( ractive );\n\t\t\t// render automatically ( if `el` is specified )\n\t\t\tif ( el ) {\n\t\t\t\tractive.render( el, ractive.append );\n\t\t\t}\n\t\t};\n\n\t\tfunction initialiseProperties( ractive, options ) {\n\t\t\t// Generate a unique identifier, for places where you'd use a weak map if it\n\t\t\t// existed\n\t\t\tractive._guid = getNextNumber();\n\t\t\t// events\n\t\t\tractive._subs = create( null );\n\t\t\t// storage for item configuration from instantiation to reset,\n\t\t\t// like dynamic functions or original values\n\t\t\tractive._config = {};\n\t\t\t// two-way bindings\n\t\t\tractive._twowayBindings = create( null );\n\t\t\t// animations (so we can stop any in progress at teardown)\n\t\t\tractive._animations = [];\n\t\t\t// nodes registry\n\t\t\tractive.nodes = {};\n\t\t\t// live queries\n\t\t\tractive._liveQueries = [];\n\t\t\tractive._liveComponentQueries = [];\n\t\t\t// If this is a component, store a reference to the parent\n\t\t\tif ( options._parent && options._component ) {\n\t\t\t\tractive._parent = options._parent;\n\t\t\t\tractive.component = options._component;\n\t\t\t\t// And store a reference to the instance on the component\n\t\t\t\toptions._component.instance = ractive;\n\t\t\t}\n\t\t}\n\t\treturn __export;\n\t}( config, create, Fragment, getElement, getNextNumber, Ractive$shared_hooks_Hook, Ractive$shared_hooks_HookQueue, Viewmodel );\n\n\t/* extend/initChildInstance.js */\n\tvar initChildInstance = function( initialise ) {\n\n\t\treturn function initChildInstance( child, Child, options ) {\n\t\t\tif ( child.beforeInit ) {\n\t\t\t\tchild.beforeInit( options );\n\t\t\t}\n\t\t\tinitialise( child, options );\n\t\t};\n\t}( Ractive_initialise );\n\n\t/* extend/unwrapExtended.js */\n\tvar unwrapExtended = function( wrap, config, circular ) {\n\n\t\tvar __export;\n\t\tvar Ractive;\n\t\tcircular.push( function() {\n\t\t\tRactive = circular.Ractive;\n\t\t} );\n\t\t__export = function unwrapExtended( Child ) {\n\t\t\tif ( !( Child.prototype instanceof Ractive ) ) {\n\t\t\t\treturn Child;\n\t\t\t}\n\t\t\tvar options = {};\n\t\t\twhile ( Child ) {\n\t\t\t\tconfig.registries.forEach( function( r ) {\n\t\t\t\t\taddRegistry( r.useDefaults ? Child.prototype : Child, options, r.name );\n\t\t\t\t} );\n\t\t\t\tObject.keys( Child.prototype ).forEach( function( key ) {\n\t\t\t\t\tif ( key === 'computed' ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar value = Child.prototype[ key ];\n\t\t\t\t\tif ( !( key in options ) ) {\n\t\t\t\t\t\toptions[ key ] = value._method ? value._method : value;\n\t\t\t\t\t} else if ( typeof options[ key ] === 'function' && typeof value === 'function' && options[ key ]._method ) {\n\t\t\t\t\t\tvar result, needsSuper = value._method;\n\t\t\t\t\t\tif ( needsSuper ) {\n\t\t\t\t\t\t\tvalue = value._method;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// rewrap bound directly to parent fn\n\t\t\t\t\t\tresult = wrap( options[ key ]._method, value );\n\t\t\t\t\t\tif ( needsSuper ) {\n\t\t\t\t\t\t\tresult._method = result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptions[ key ] = result;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tif ( Child._parent !== Ractive ) {\n\t\t\t\t\tChild = Child._parent;\n\t\t\t\t} else {\n\t\t\t\t\tChild = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn options;\n\t\t};\n\n\t\tfunction addRegistry( target, options, name ) {\n\t\t\tvar registry, keys = Object.keys( target[ name ] );\n\t\t\tif ( !keys.length ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( !( registry = options[ name ] ) ) {\n\t\t\t\tregistry = options[ name ] = {};\n\t\t\t}\n\t\t\tkeys.filter( function( key ) {\n\t\t\t\treturn !( key in registry );\n\t\t\t} ).forEach( function( key ) {\n\t\t\t\treturn registry[ key ] = target[ name ][ key ];\n\t\t\t} );\n\t\t}\n\t\treturn __export;\n\t}( wrapMethod, config, circular );\n\n\t/* extend/_extend.js */\n\tvar Ractive_extend = function( create, defineProperties, getGuid, config, initChildInstance, Viewmodel, unwrap ) {\n\n\t\treturn function extend() {\n\t\t\tvar options = arguments[ 0 ];\n\t\t\tif ( options === void 0 )\n\t\t\t\toptions = {};\n\t\t\tvar Parent = this,\n\t\t\t\tChild, proto, staticProperties;\n\t\t\t// if we're extending with another Ractive instance, inherit its\n\t\t\t// prototype methods and default options as well\n\t\t\toptions = unwrap( options );\n\t\t\t// create Child constructor\n\t\t\tChild = function( options ) {\n\t\t\t\tinitChildInstance( this, Child, options );\n\t\t\t};\n\t\t\tproto = create( Parent.prototype );\n\t\t\tproto.constructor = Child;\n\t\t\tstaticProperties = {\n\t\t\t\t// each component needs a guid, for managing CSS etc\n\t\t\t\t_guid: {\n\t\t\t\t\tvalue: getGuid()\n\t\t\t\t},\n\t\t\t\t// alias prototype as defaults\n\t\t\t\tdefaults: {\n\t\t\t\t\tvalue: proto\n\t\t\t\t},\n\t\t\t\t// extendable\n\t\t\t\textend: {\n\t\t\t\t\tvalue: extend,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tconfigurable: true\n\t\t\t\t},\n\t\t\t\t// Parent - for IE8, can't use Object.getPrototypeOf\n\t\t\t\t_parent: {\n\t\t\t\t\tvalue: Parent\n\t\t\t\t}\n\t\t\t};\n\t\t\tdefineProperties( Child, staticProperties );\n\t\t\t// extend configuration\n\t\t\tconfig.extend( Parent, proto, options );\n\t\t\tViewmodel.extend( Parent, proto );\n\t\t\tChild.prototype = proto;\n\t\t\treturn Child;\n\t\t};\n\t}( create, defineProperties, getGuid, config, initChildInstance, Viewmodel, unwrapExtended );\n\n\t/* Ractive.js */\n\tvar Ractive = function( defaults, easing, interpolators, svg, magic, defineProperties, proto, Promise, extendObj, extend, parse, initialise, circular ) {\n\n\t\tvar Ractive, properties;\n\t\t// Main Ractive required object\n\t\tRactive = function( options ) {\n\t\t\tinitialise( this, options );\n\t\t};\n\t\t// Ractive properties\n\t\tproperties = {\n\t\t\t// static methods:\n\t\t\textend: {\n\t\t\t\tvalue: extend\n\t\t\t},\n\t\t\tparse: {\n\t\t\t\tvalue: parse\n\t\t\t},\n\t\t\t// Namespaced constructors\n\t\t\tPromise: {\n\t\t\t\tvalue: Promise\n\t\t\t},\n\t\t\t// support\n\t\t\tsvg: {\n\t\t\t\tvalue: svg\n\t\t\t},\n\t\t\tmagic: {\n\t\t\t\tvalue: magic\n\t\t\t},\n\t\t\t// version\n\t\t\tVERSION: {\n\t\t\t\tvalue: '0.6.0'\n\t\t\t},\n\t\t\t// Plugins\n\t\t\tadaptors: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: {}\n\t\t\t},\n\t\t\tcomponents: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: {}\n\t\t\t},\n\t\t\tdecorators: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: {}\n\t\t\t},\n\t\t\teasing: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: easing\n\t\t\t},\n\t\t\tevents: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: {}\n\t\t\t},\n\t\t\tinterpolators: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: interpolators\n\t\t\t},\n\t\t\tpartials: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: {}\n\t\t\t},\n\t\t\ttransitions: {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: {}\n\t\t\t}\n\t\t};\n\t\t// Ractive properties\n\t\tdefineProperties( Ractive, properties );\n\t\tRactive.prototype = extendObj( proto, defaults );\n\t\tRactive.prototype.constructor = Ractive;\n\t\t// alias prototype as defaults\n\t\tRactive.defaults = Ractive.prototype;\n\t\t// Certain modules have circular dependencies. If we were bundling a\n\t\t// module loader, e.g. almond.js, this wouldn't be a problem, but we're\n\t\t// not - we're using amdclean as part of the build process. Because of\n\t\t// this, we need to wait until all modules have loaded before those\n\t\t// circular dependencies can be required.\n\t\tcircular.Ractive = Ractive;\n\t\twhile ( circular.length ) {\n\t\t\tcircular.pop()();\n\t\t}\n\t\t// Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n\t\t// older browsers, these are made available via a shim - here, we do a quick\n\t\t// pre-flight check to make sure that either a) we're not in a shit browser,\n\t\t// or b) we're using a Ractive-legacy.js build\n\t\tvar FUNCTION = 'function';\n\t\tif ( typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION ) {\n\t\t\tthrow new Error( 'It looks like you\\'re attempting to use Ractive.js in an older browser. You\\'ll need to use one of the \\'legacy builds\\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );\n\t\t}\n\t\treturn Ractive;\n\t}( options, easing, interpolators, svg, magic, defineProperties, prototype, Promise, extend, Ractive_extend, parse, Ractive_initialise, circular );\n\n\n\t// export as Common JS module...\n\tif ( typeof module !== \"undefined\" && module.exports ) {\n\t\tmodule.exports = Ractive;\n\t}\n\n\t// ... or as AMD module\n\telse if ( typeof define === \"function\" && define.amd ) {\n\t\tdefine( function() {\n\t\t\treturn Ractive;\n\t\t} );\n\t}\n\n\t// ... or as browser global\n\tglobal.Ractive = Ractive;\n\n\tRactive.noConflict = function() {\n\t\tglobal.Ractive = noConflict;\n\t\treturn Ractive;\n\t};\n\n}( typeof window !== 'undefined' ? window : this ) );\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/ractive/ractive.js\n ** module id = 4\n ** module chunks = 0\n **/","/*\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Dispatcher\n * @typechecks\n */\n\n\"use strict\";\n\nvar invariant = require('./invariant');\n\nvar _lastID = 1;\nvar _prefix = 'ID_';\n\n/**\n * Dispatcher is used to broadcast payloads to registered callbacks. This is\n * different from generic pub-sub systems in two ways:\n *\n *   1) Callbacks are not subscribed to particular events. Every payload is\n *      dispatched to every registered callback.\n *   2) Callbacks can be deferred in whole or part until other callbacks have\n *      been executed.\n *\n * For example, consider this hypothetical flight destination form, which\n * selects a default city when a country is selected:\n *\n *   var flightDispatcher = new Dispatcher();\n *\n *   // Keeps track of which country is selected\n *   var CountryStore = {country: null};\n *\n *   // Keeps track of which city is selected\n *   var CityStore = {city: null};\n *\n *   // Keeps track of the base flight price of the selected city\n *   var FlightPriceStore = {price: null}\n *\n * When a user changes the selected city, we dispatch the payload:\n *\n *   flightDispatcher.dispatch({\n *     actionType: 'city-update',\n *     selectedCity: 'paris'\n *   });\n *\n * This payload is digested by `CityStore`:\n *\n *   flightDispatcher.register(function(payload) {\n *     if (payload.actionType === 'city-update') {\n *       CityStore.city = payload.selectedCity;\n *     }\n *   });\n *\n * When the user selects a country, we dispatch the payload:\n *\n *   flightDispatcher.dispatch({\n *     actionType: 'country-update',\n *     selectedCountry: 'australia'\n *   });\n *\n * This payload is digested by both stores:\n *\n *    CountryStore.dispatchToken = flightDispatcher.register(function(payload) {\n *     if (payload.actionType === 'country-update') {\n *       CountryStore.country = payload.selectedCountry;\n *     }\n *   });\n *\n * When the callback to update `CountryStore` is registered, we save a reference\n * to the returned token. Using this token with `waitFor()`, we can guarantee\n * that `CountryStore` is updated before the callback that updates `CityStore`\n * needs to query its data.\n *\n *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {\n *     if (payload.actionType === 'country-update') {\n *       // `CountryStore.country` may not be updated.\n *       flightDispatcher.waitFor([CountryStore.dispatchToken]);\n *       // `CountryStore.country` is now guaranteed to be updated.\n *\n *       // Select the default city for the new country\n *       CityStore.city = getDefaultCityForCountry(CountryStore.country);\n *     }\n *   });\n *\n * The usage of `waitFor()` can be chained, for example:\n *\n *   FlightPriceStore.dispatchToken =\n *     flightDispatcher.register(function(payload) {\n *       switch (payload.actionType) {\n *         case 'country-update':\n *           flightDispatcher.waitFor([CityStore.dispatchToken]);\n *           FlightPriceStore.price =\n *             getFlightPriceStore(CountryStore.country, CityStore.city);\n *           break;\n *\n *         case 'city-update':\n *           FlightPriceStore.price =\n *             FlightPriceStore(CountryStore.country, CityStore.city);\n *           break;\n *     }\n *   });\n *\n * The `country-update` payload will be guaranteed to invoke the stores'\n * registered callbacks in order: `CountryStore`, `CityStore`, then\n * `FlightPriceStore`.\n */\n\n  function Dispatcher() {\n    this.$Dispatcher_callbacks = {};\n    this.$Dispatcher_isPending = {};\n    this.$Dispatcher_isHandled = {};\n    this.$Dispatcher_isDispatching = false;\n    this.$Dispatcher_pendingPayload = null;\n  }\n\n  /**\n   * Registers a callback to be invoked with every dispatched payload. Returns\n   * a token that can be used with `waitFor()`.\n   *\n   * @param {function} callback\n   * @return {string}\n   */\n  Dispatcher.prototype.register=function(callback) {\n    var id = _prefix + _lastID++;\n    this.$Dispatcher_callbacks[id] = callback;\n    return id;\n  };\n\n  /**\n   * Removes a callback based on its token.\n   *\n   * @param {string} id\n   */\n  Dispatcher.prototype.unregister=function(id) {\n    invariant(\n      this.$Dispatcher_callbacks[id],\n      'Dispatcher.unregister(...): `%s` does not map to a registered callback.',\n      id\n    );\n    delete this.$Dispatcher_callbacks[id];\n  };\n\n  /**\n   * Waits for the callbacks specified to be invoked before continuing execution\n   * of the current callback. This method should only be used by a callback in\n   * response to a dispatched payload.\n   *\n   * @param {array<string>} ids\n   */\n  Dispatcher.prototype.waitFor=function(ids) {\n    invariant(\n      this.$Dispatcher_isDispatching,\n      'Dispatcher.waitFor(...): Must be invoked while dispatching.'\n    );\n    for (var ii = 0; ii < ids.length; ii++) {\n      var id = ids[ii];\n      if (this.$Dispatcher_isPending[id]) {\n        invariant(\n          this.$Dispatcher_isHandled[id],\n          'Dispatcher.waitFor(...): Circular dependency detected while ' +\n          'waiting for `%s`.',\n          id\n        );\n        continue;\n      }\n      invariant(\n        this.$Dispatcher_callbacks[id],\n        'Dispatcher.waitFor(...): `%s` does not map to a registered callback.',\n        id\n      );\n      this.$Dispatcher_invokeCallback(id);\n    }\n  };\n\n  /**\n   * Dispatches a payload to all registered callbacks.\n   *\n   * @param {object} payload\n   */\n  Dispatcher.prototype.dispatch=function(payload) {\n    invariant(\n      !this.$Dispatcher_isDispatching,\n      'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'\n    );\n    this.$Dispatcher_startDispatching(payload);\n    try {\n      for (var id in this.$Dispatcher_callbacks) {\n        if (this.$Dispatcher_isPending[id]) {\n          continue;\n        }\n        this.$Dispatcher_invokeCallback(id);\n      }\n    } finally {\n      this.$Dispatcher_stopDispatching();\n    }\n  };\n\n  /**\n   * Is this Dispatcher currently dispatching.\n   *\n   * @return {boolean}\n   */\n  Dispatcher.prototype.isDispatching=function() {\n    return this.$Dispatcher_isDispatching;\n  };\n\n  /**\n   * Call the callback stored with the given id. Also do some internal\n   * bookkeeping.\n   *\n   * @param {string} id\n   * @internal\n   */\n  Dispatcher.prototype.$Dispatcher_invokeCallback=function(id) {\n    this.$Dispatcher_isPending[id] = true;\n    this.$Dispatcher_callbacks[id](this.$Dispatcher_pendingPayload);\n    this.$Dispatcher_isHandled[id] = true;\n  };\n\n  /**\n   * Set up bookkeeping needed when dispatching.\n   *\n   * @param {object} payload\n   * @internal\n   */\n  Dispatcher.prototype.$Dispatcher_startDispatching=function(payload) {\n    for (var id in this.$Dispatcher_callbacks) {\n      this.$Dispatcher_isPending[id] = false;\n      this.$Dispatcher_isHandled[id] = false;\n    }\n    this.$Dispatcher_pendingPayload = payload;\n    this.$Dispatcher_isDispatching = true;\n  };\n\n  /**\n   * Clear bookkeeping used for dispatching.\n   *\n   * @internal\n   */\n  Dispatcher.prototype.$Dispatcher_stopDispatching=function() {\n    this.$Dispatcher_pendingPayload = null;\n    this.$Dispatcher_isDispatching = false;\n  };\n\n\nmodule.exports = Dispatcher;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/flux/lib/Dispatcher.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule invariant\n */\n\n\"use strict\";\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (false) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        'Invariant Violation: ' +\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/flux/lib/invariant.js\n ** module id = 11\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"vendor.bundle.js"}